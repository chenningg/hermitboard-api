// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/chenningg/hermitboard-api/ent/migrate"
	"github.com/chenningg/hermitboard-api/pulid"

	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/authtype"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/staffaccount"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// Asset is the client for interacting with the Asset builders.
	Asset *AssetClient
	// AssetClass is the client for interacting with the AssetClass builders.
	AssetClass *AssetClassClient
	// AuthRole is the client for interacting with the AuthRole builders.
	AuthRole *AuthRoleClient
	// AuthType is the client for interacting with the AuthType builders.
	AuthType *AuthTypeClient
	// Blockchain is the client for interacting with the Blockchain builders.
	Blockchain *BlockchainClient
	// Cryptocurrency is the client for interacting with the Cryptocurrency builders.
	Cryptocurrency *CryptocurrencyClient
	// DailyAssetPrice is the client for interacting with the DailyAssetPrice builders.
	DailyAssetPrice *DailyAssetPriceClient
	// Exchange is the client for interacting with the Exchange builders.
	Exchange *ExchangeClient
	// Portfolio is the client for interacting with the Portfolio builders.
	Portfolio *PortfolioClient
	// StaffAccount is the client for interacting with the StaffAccount builders.
	StaffAccount *StaffAccountClient
	// Transaction is the client for interacting with the Transaction builders.
	Transaction *TransactionClient
	// TransactionType is the client for interacting with the TransactionType builders.
	TransactionType *TransactionTypeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.Asset = NewAssetClient(c.config)
	c.AssetClass = NewAssetClassClient(c.config)
	c.AuthRole = NewAuthRoleClient(c.config)
	c.AuthType = NewAuthTypeClient(c.config)
	c.Blockchain = NewBlockchainClient(c.config)
	c.Cryptocurrency = NewCryptocurrencyClient(c.config)
	c.DailyAssetPrice = NewDailyAssetPriceClient(c.config)
	c.Exchange = NewExchangeClient(c.config)
	c.Portfolio = NewPortfolioClient(c.config)
	c.StaffAccount = NewStaffAccountClient(c.config)
	c.Transaction = NewTransactionClient(c.config)
	c.TransactionType = NewTransactionTypeClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Account:         NewAccountClient(cfg),
		Asset:           NewAssetClient(cfg),
		AssetClass:      NewAssetClassClient(cfg),
		AuthRole:        NewAuthRoleClient(cfg),
		AuthType:        NewAuthTypeClient(cfg),
		Blockchain:      NewBlockchainClient(cfg),
		Cryptocurrency:  NewCryptocurrencyClient(cfg),
		DailyAssetPrice: NewDailyAssetPriceClient(cfg),
		Exchange:        NewExchangeClient(cfg),
		Portfolio:       NewPortfolioClient(cfg),
		StaffAccount:    NewStaffAccountClient(cfg),
		Transaction:     NewTransactionClient(cfg),
		TransactionType: NewTransactionTypeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Account:         NewAccountClient(cfg),
		Asset:           NewAssetClient(cfg),
		AssetClass:      NewAssetClassClient(cfg),
		AuthRole:        NewAuthRoleClient(cfg),
		AuthType:        NewAuthTypeClient(cfg),
		Blockchain:      NewBlockchainClient(cfg),
		Cryptocurrency:  NewCryptocurrencyClient(cfg),
		DailyAssetPrice: NewDailyAssetPriceClient(cfg),
		Exchange:        NewExchangeClient(cfg),
		Portfolio:       NewPortfolioClient(cfg),
		StaffAccount:    NewStaffAccountClient(cfg),
		Transaction:     NewTransactionClient(cfg),
		TransactionType: NewTransactionTypeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Account.Use(hooks...)
	c.Asset.Use(hooks...)
	c.AssetClass.Use(hooks...)
	c.AuthRole.Use(hooks...)
	c.AuthType.Use(hooks...)
	c.Blockchain.Use(hooks...)
	c.Cryptocurrency.Use(hooks...)
	c.DailyAssetPrice.Use(hooks...)
	c.Exchange.Use(hooks...)
	c.Portfolio.Use(hooks...)
	c.StaffAccount.Use(hooks...)
	c.Transaction.Use(hooks...)
	c.TransactionType.Use(hooks...)
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(a))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id pulid.PULID) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id pulid.PULID) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id pulid.PULID) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id pulid.PULID) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthRoles queries the auth_roles edge of a Account.
func (c *AccountClient) QueryAuthRoles(a *Account) *AuthRoleQuery {
	query := &AuthRoleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(authrole.Table, authrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, account.AuthRolesTable, account.AuthRolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPortfolios queries the portfolios edge of a Account.
func (c *AccountClient) QueryPortfolios(a *Account) *PortfolioQuery {
	query := &PortfolioQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(portfolio.Table, portfolio.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.PortfoliosTable, account.PortfoliosColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthType queries the auth_type edge of a Account.
func (c *AccountClient) QueryAuthType(a *Account) *AuthTypeQuery {
	query := &AuthTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(authtype.Table, authtype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, account.AuthTypeTable, account.AuthTypeColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// AssetClient is a client for the Asset schema.
type AssetClient struct {
	config
}

// NewAssetClient returns a client for the Asset from the given config.
func NewAssetClient(c config) *AssetClient {
	return &AssetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `asset.Hooks(f(g(h())))`.
func (c *AssetClient) Use(hooks ...Hook) {
	c.hooks.Asset = append(c.hooks.Asset, hooks...)
}

// Create returns a builder for creating a Asset entity.
func (c *AssetClient) Create() *AssetCreate {
	mutation := newAssetMutation(c.config, OpCreate)
	return &AssetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Asset entities.
func (c *AssetClient) CreateBulk(builders ...*AssetCreate) *AssetCreateBulk {
	return &AssetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Asset.
func (c *AssetClient) Update() *AssetUpdate {
	mutation := newAssetMutation(c.config, OpUpdate)
	return &AssetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetClient) UpdateOne(a *Asset) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAsset(a))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetClient) UpdateOneID(id pulid.PULID) *AssetUpdateOne {
	mutation := newAssetMutation(c.config, OpUpdateOne, withAssetID(id))
	return &AssetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Asset.
func (c *AssetClient) Delete() *AssetDelete {
	mutation := newAssetMutation(c.config, OpDelete)
	return &AssetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetClient) DeleteOne(a *Asset) *AssetDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AssetClient) DeleteOneID(id pulid.PULID) *AssetDeleteOne {
	builder := c.Delete().Where(asset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetDeleteOne{builder}
}

// Query returns a query builder for Asset.
func (c *AssetClient) Query() *AssetQuery {
	return &AssetQuery{
		config: c.config,
	}
}

// Get returns a Asset entity by its id.
func (c *AssetClient) Get(ctx context.Context, id pulid.PULID) (*Asset, error) {
	return c.Query().Where(asset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetClient) GetX(ctx context.Context, id pulid.PULID) *Asset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssetClass queries the asset_class edge of a Asset.
func (c *AssetClient) QueryAssetClass(a *Asset) *AssetClassQuery {
	query := &AssetClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(assetclass.Table, assetclass.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, asset.AssetClassTable, asset.AssetClassColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCryptocurrency queries the cryptocurrency edge of a Asset.
func (c *AssetClient) QueryCryptocurrency(a *Asset) *CryptocurrencyQuery {
	query := &CryptocurrencyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(cryptocurrency.Table, cryptocurrency.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, asset.CryptocurrencyTable, asset.CryptocurrencyColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactionBases queries the transaction_bases edge of a Asset.
func (c *AssetClient) QueryTransactionBases(a *Asset) *TransactionQuery {
	query := &TransactionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, asset.TransactionBasesTable, asset.TransactionBasesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactionQuotes queries the transaction_quotes edge of a Asset.
func (c *AssetClient) QueryTransactionQuotes(a *Asset) *TransactionQuery {
	query := &TransactionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, asset.TransactionQuotesTable, asset.TransactionQuotesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDailyAssetPrices queries the daily_asset_prices edge of a Asset.
func (c *AssetClient) QueryDailyAssetPrices(a *Asset) *DailyAssetPriceQuery {
	query := &DailyAssetPriceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(asset.Table, asset.FieldID, id),
			sqlgraph.To(dailyassetprice.Table, dailyassetprice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, asset.DailyAssetPricesTable, asset.DailyAssetPricesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetClient) Hooks() []Hook {
	return c.hooks.Asset
}

// AssetClassClient is a client for the AssetClass schema.
type AssetClassClient struct {
	config
}

// NewAssetClassClient returns a client for the AssetClass from the given config.
func NewAssetClassClient(c config) *AssetClassClient {
	return &AssetClassClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assetclass.Hooks(f(g(h())))`.
func (c *AssetClassClient) Use(hooks ...Hook) {
	c.hooks.AssetClass = append(c.hooks.AssetClass, hooks...)
}

// Create returns a builder for creating a AssetClass entity.
func (c *AssetClassClient) Create() *AssetClassCreate {
	mutation := newAssetClassMutation(c.config, OpCreate)
	return &AssetClassCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssetClass entities.
func (c *AssetClassClient) CreateBulk(builders ...*AssetClassCreate) *AssetClassCreateBulk {
	return &AssetClassCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssetClass.
func (c *AssetClassClient) Update() *AssetClassUpdate {
	mutation := newAssetClassMutation(c.config, OpUpdate)
	return &AssetClassUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssetClassClient) UpdateOne(ac *AssetClass) *AssetClassUpdateOne {
	mutation := newAssetClassMutation(c.config, OpUpdateOne, withAssetClass(ac))
	return &AssetClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssetClassClient) UpdateOneID(id pulid.PULID) *AssetClassUpdateOne {
	mutation := newAssetClassMutation(c.config, OpUpdateOne, withAssetClassID(id))
	return &AssetClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssetClass.
func (c *AssetClassClient) Delete() *AssetClassDelete {
	mutation := newAssetClassMutation(c.config, OpDelete)
	return &AssetClassDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AssetClassClient) DeleteOne(ac *AssetClass) *AssetClassDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AssetClassClient) DeleteOneID(id pulid.PULID) *AssetClassDeleteOne {
	builder := c.Delete().Where(assetclass.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssetClassDeleteOne{builder}
}

// Query returns a query builder for AssetClass.
func (c *AssetClassClient) Query() *AssetClassQuery {
	return &AssetClassQuery{
		config: c.config,
	}
}

// Get returns a AssetClass entity by its id.
func (c *AssetClassClient) Get(ctx context.Context, id pulid.PULID) (*AssetClass, error) {
	return c.Query().Where(assetclass.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssetClassClient) GetX(ctx context.Context, id pulid.PULID) *AssetClass {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAssets queries the assets edge of a AssetClass.
func (c *AssetClassClient) QueryAssets(ac *AssetClass) *AssetQuery {
	query := &AssetQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assetclass.Table, assetclass.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, assetclass.AssetsTable, assetclass.AssetsColumn),
		)
		fromV = sqlgraph.Neighbors(ac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssetClassClient) Hooks() []Hook {
	return c.hooks.AssetClass
}

// AuthRoleClient is a client for the AuthRole schema.
type AuthRoleClient struct {
	config
}

// NewAuthRoleClient returns a client for the AuthRole from the given config.
func NewAuthRoleClient(c config) *AuthRoleClient {
	return &AuthRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authrole.Hooks(f(g(h())))`.
func (c *AuthRoleClient) Use(hooks ...Hook) {
	c.hooks.AuthRole = append(c.hooks.AuthRole, hooks...)
}

// Create returns a builder for creating a AuthRole entity.
func (c *AuthRoleClient) Create() *AuthRoleCreate {
	mutation := newAuthRoleMutation(c.config, OpCreate)
	return &AuthRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthRole entities.
func (c *AuthRoleClient) CreateBulk(builders ...*AuthRoleCreate) *AuthRoleCreateBulk {
	return &AuthRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthRole.
func (c *AuthRoleClient) Update() *AuthRoleUpdate {
	mutation := newAuthRoleMutation(c.config, OpUpdate)
	return &AuthRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthRoleClient) UpdateOne(ar *AuthRole) *AuthRoleUpdateOne {
	mutation := newAuthRoleMutation(c.config, OpUpdateOne, withAuthRole(ar))
	return &AuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthRoleClient) UpdateOneID(id pulid.PULID) *AuthRoleUpdateOne {
	mutation := newAuthRoleMutation(c.config, OpUpdateOne, withAuthRoleID(id))
	return &AuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthRole.
func (c *AuthRoleClient) Delete() *AuthRoleDelete {
	mutation := newAuthRoleMutation(c.config, OpDelete)
	return &AuthRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthRoleClient) DeleteOne(ar *AuthRole) *AuthRoleDeleteOne {
	return c.DeleteOneID(ar.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AuthRoleClient) DeleteOneID(id pulid.PULID) *AuthRoleDeleteOne {
	builder := c.Delete().Where(authrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthRoleDeleteOne{builder}
}

// Query returns a query builder for AuthRole.
func (c *AuthRoleClient) Query() *AuthRoleQuery {
	return &AuthRoleQuery{
		config: c.config,
	}
}

// Get returns a AuthRole entity by its id.
func (c *AuthRoleClient) Get(ctx context.Context, id pulid.PULID) (*AuthRole, error) {
	return c.Query().Where(authrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthRoleClient) GetX(ctx context.Context, id pulid.PULID) *AuthRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccounts queries the accounts edge of a AuthRole.
func (c *AuthRoleClient) QueryAccounts(ar *AuthRole) *AccountQuery {
	query := &AccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authrole.Table, authrole.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, authrole.AccountsTable, authrole.AccountsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffAccounts queries the staff_accounts edge of a AuthRole.
func (c *AuthRoleClient) QueryStaffAccounts(ar *AuthRole) *StaffAccountQuery {
	query := &StaffAccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ar.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authrole.Table, authrole.FieldID, id),
			sqlgraph.To(staffaccount.Table, staffaccount.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, authrole.StaffAccountsTable, authrole.StaffAccountsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ar.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthRoleClient) Hooks() []Hook {
	return c.hooks.AuthRole
}

// AuthTypeClient is a client for the AuthType schema.
type AuthTypeClient struct {
	config
}

// NewAuthTypeClient returns a client for the AuthType from the given config.
func NewAuthTypeClient(c config) *AuthTypeClient {
	return &AuthTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authtype.Hooks(f(g(h())))`.
func (c *AuthTypeClient) Use(hooks ...Hook) {
	c.hooks.AuthType = append(c.hooks.AuthType, hooks...)
}

// Create returns a builder for creating a AuthType entity.
func (c *AuthTypeClient) Create() *AuthTypeCreate {
	mutation := newAuthTypeMutation(c.config, OpCreate)
	return &AuthTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthType entities.
func (c *AuthTypeClient) CreateBulk(builders ...*AuthTypeCreate) *AuthTypeCreateBulk {
	return &AuthTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthType.
func (c *AuthTypeClient) Update() *AuthTypeUpdate {
	mutation := newAuthTypeMutation(c.config, OpUpdate)
	return &AuthTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthTypeClient) UpdateOne(at *AuthType) *AuthTypeUpdateOne {
	mutation := newAuthTypeMutation(c.config, OpUpdateOne, withAuthType(at))
	return &AuthTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthTypeClient) UpdateOneID(id pulid.PULID) *AuthTypeUpdateOne {
	mutation := newAuthTypeMutation(c.config, OpUpdateOne, withAuthTypeID(id))
	return &AuthTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthType.
func (c *AuthTypeClient) Delete() *AuthTypeDelete {
	mutation := newAuthTypeMutation(c.config, OpDelete)
	return &AuthTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthTypeClient) DeleteOne(at *AuthType) *AuthTypeDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *AuthTypeClient) DeleteOneID(id pulid.PULID) *AuthTypeDeleteOne {
	builder := c.Delete().Where(authtype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthTypeDeleteOne{builder}
}

// Query returns a query builder for AuthType.
func (c *AuthTypeClient) Query() *AuthTypeQuery {
	return &AuthTypeQuery{
		config: c.config,
	}
}

// Get returns a AuthType entity by its id.
func (c *AuthTypeClient) Get(ctx context.Context, id pulid.PULID) (*AuthType, error) {
	return c.Query().Where(authtype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthTypeClient) GetX(ctx context.Context, id pulid.PULID) *AuthType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccounts queries the accounts edge of a AuthType.
func (c *AuthTypeClient) QueryAccounts(at *AuthType) *AccountQuery {
	query := &AccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authtype.Table, authtype.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, authtype.AccountsTable, authtype.AccountsColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffAccounts queries the staff_accounts edge of a AuthType.
func (c *AuthTypeClient) QueryStaffAccounts(at *AuthType) *StaffAccountQuery {
	query := &StaffAccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authtype.Table, authtype.FieldID, id),
			sqlgraph.To(staffaccount.Table, staffaccount.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, authtype.StaffAccountsTable, authtype.StaffAccountsColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthTypeClient) Hooks() []Hook {
	return c.hooks.AuthType
}

// BlockchainClient is a client for the Blockchain schema.
type BlockchainClient struct {
	config
}

// NewBlockchainClient returns a client for the Blockchain from the given config.
func NewBlockchainClient(c config) *BlockchainClient {
	return &BlockchainClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockchain.Hooks(f(g(h())))`.
func (c *BlockchainClient) Use(hooks ...Hook) {
	c.hooks.Blockchain = append(c.hooks.Blockchain, hooks...)
}

// Create returns a builder for creating a Blockchain entity.
func (c *BlockchainClient) Create() *BlockchainCreate {
	mutation := newBlockchainMutation(c.config, OpCreate)
	return &BlockchainCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Blockchain entities.
func (c *BlockchainClient) CreateBulk(builders ...*BlockchainCreate) *BlockchainCreateBulk {
	return &BlockchainCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Blockchain.
func (c *BlockchainClient) Update() *BlockchainUpdate {
	mutation := newBlockchainMutation(c.config, OpUpdate)
	return &BlockchainUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockchainClient) UpdateOne(b *Blockchain) *BlockchainUpdateOne {
	mutation := newBlockchainMutation(c.config, OpUpdateOne, withBlockchain(b))
	return &BlockchainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockchainClient) UpdateOneID(id pulid.PULID) *BlockchainUpdateOne {
	mutation := newBlockchainMutation(c.config, OpUpdateOne, withBlockchainID(id))
	return &BlockchainUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Blockchain.
func (c *BlockchainClient) Delete() *BlockchainDelete {
	mutation := newBlockchainMutation(c.config, OpDelete)
	return &BlockchainDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockchainClient) DeleteOne(b *Blockchain) *BlockchainDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *BlockchainClient) DeleteOneID(id pulid.PULID) *BlockchainDeleteOne {
	builder := c.Delete().Where(blockchain.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockchainDeleteOne{builder}
}

// Query returns a query builder for Blockchain.
func (c *BlockchainClient) Query() *BlockchainQuery {
	return &BlockchainQuery{
		config: c.config,
	}
}

// Get returns a Blockchain entity by its id.
func (c *BlockchainClient) Get(ctx context.Context, id pulid.PULID) (*Blockchain, error) {
	return c.Query().Where(blockchain.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockchainClient) GetX(ctx context.Context, id pulid.PULID) *Blockchain {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCryptocurrencies queries the cryptocurrencies edge of a Blockchain.
func (c *BlockchainClient) QueryCryptocurrencies(b *Blockchain) *CryptocurrencyQuery {
	query := &CryptocurrencyQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockchain.Table, blockchain.FieldID, id),
			sqlgraph.To(cryptocurrency.Table, cryptocurrency.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, blockchain.CryptocurrenciesTable, blockchain.CryptocurrenciesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactions queries the transactions edge of a Blockchain.
func (c *BlockchainClient) QueryTransactions(b *Blockchain) *TransactionQuery {
	query := &TransactionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blockchain.Table, blockchain.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, blockchain.TransactionsTable, blockchain.TransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlockchainClient) Hooks() []Hook {
	return c.hooks.Blockchain
}

// CryptocurrencyClient is a client for the Cryptocurrency schema.
type CryptocurrencyClient struct {
	config
}

// NewCryptocurrencyClient returns a client for the Cryptocurrency from the given config.
func NewCryptocurrencyClient(c config) *CryptocurrencyClient {
	return &CryptocurrencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cryptocurrency.Hooks(f(g(h())))`.
func (c *CryptocurrencyClient) Use(hooks ...Hook) {
	c.hooks.Cryptocurrency = append(c.hooks.Cryptocurrency, hooks...)
}

// Create returns a builder for creating a Cryptocurrency entity.
func (c *CryptocurrencyClient) Create() *CryptocurrencyCreate {
	mutation := newCryptocurrencyMutation(c.config, OpCreate)
	return &CryptocurrencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Cryptocurrency entities.
func (c *CryptocurrencyClient) CreateBulk(builders ...*CryptocurrencyCreate) *CryptocurrencyCreateBulk {
	return &CryptocurrencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Cryptocurrency.
func (c *CryptocurrencyClient) Update() *CryptocurrencyUpdate {
	mutation := newCryptocurrencyMutation(c.config, OpUpdate)
	return &CryptocurrencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CryptocurrencyClient) UpdateOne(cr *Cryptocurrency) *CryptocurrencyUpdateOne {
	mutation := newCryptocurrencyMutation(c.config, OpUpdateOne, withCryptocurrency(cr))
	return &CryptocurrencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CryptocurrencyClient) UpdateOneID(id pulid.PULID) *CryptocurrencyUpdateOne {
	mutation := newCryptocurrencyMutation(c.config, OpUpdateOne, withCryptocurrencyID(id))
	return &CryptocurrencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Cryptocurrency.
func (c *CryptocurrencyClient) Delete() *CryptocurrencyDelete {
	mutation := newCryptocurrencyMutation(c.config, OpDelete)
	return &CryptocurrencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CryptocurrencyClient) DeleteOne(cr *Cryptocurrency) *CryptocurrencyDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *CryptocurrencyClient) DeleteOneID(id pulid.PULID) *CryptocurrencyDeleteOne {
	builder := c.Delete().Where(cryptocurrency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CryptocurrencyDeleteOne{builder}
}

// Query returns a query builder for Cryptocurrency.
func (c *CryptocurrencyClient) Query() *CryptocurrencyQuery {
	return &CryptocurrencyQuery{
		config: c.config,
	}
}

// Get returns a Cryptocurrency entity by its id.
func (c *CryptocurrencyClient) Get(ctx context.Context, id pulid.PULID) (*Cryptocurrency, error) {
	return c.Query().Where(cryptocurrency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CryptocurrencyClient) GetX(ctx context.Context, id pulid.PULID) *Cryptocurrency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the asset edge of a Cryptocurrency.
func (c *CryptocurrencyClient) QueryAsset(cr *Cryptocurrency) *AssetQuery {
	query := &AssetQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cryptocurrency.Table, cryptocurrency.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, cryptocurrency.AssetTable, cryptocurrency.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockchains queries the blockchains edge of a Cryptocurrency.
func (c *CryptocurrencyClient) QueryBlockchains(cr *Cryptocurrency) *BlockchainQuery {
	query := &BlockchainQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cryptocurrency.Table, cryptocurrency.FieldID, id),
			sqlgraph.To(blockchain.Table, blockchain.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, cryptocurrency.BlockchainsTable, cryptocurrency.BlockchainsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CryptocurrencyClient) Hooks() []Hook {
	return c.hooks.Cryptocurrency
}

// DailyAssetPriceClient is a client for the DailyAssetPrice schema.
type DailyAssetPriceClient struct {
	config
}

// NewDailyAssetPriceClient returns a client for the DailyAssetPrice from the given config.
func NewDailyAssetPriceClient(c config) *DailyAssetPriceClient {
	return &DailyAssetPriceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dailyassetprice.Hooks(f(g(h())))`.
func (c *DailyAssetPriceClient) Use(hooks ...Hook) {
	c.hooks.DailyAssetPrice = append(c.hooks.DailyAssetPrice, hooks...)
}

// Create returns a builder for creating a DailyAssetPrice entity.
func (c *DailyAssetPriceClient) Create() *DailyAssetPriceCreate {
	mutation := newDailyAssetPriceMutation(c.config, OpCreate)
	return &DailyAssetPriceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DailyAssetPrice entities.
func (c *DailyAssetPriceClient) CreateBulk(builders ...*DailyAssetPriceCreate) *DailyAssetPriceCreateBulk {
	return &DailyAssetPriceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DailyAssetPrice.
func (c *DailyAssetPriceClient) Update() *DailyAssetPriceUpdate {
	mutation := newDailyAssetPriceMutation(c.config, OpUpdate)
	return &DailyAssetPriceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DailyAssetPriceClient) UpdateOne(dap *DailyAssetPrice) *DailyAssetPriceUpdateOne {
	mutation := newDailyAssetPriceMutation(c.config, OpUpdateOne, withDailyAssetPrice(dap))
	return &DailyAssetPriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DailyAssetPriceClient) UpdateOneID(id pulid.PULID) *DailyAssetPriceUpdateOne {
	mutation := newDailyAssetPriceMutation(c.config, OpUpdateOne, withDailyAssetPriceID(id))
	return &DailyAssetPriceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DailyAssetPrice.
func (c *DailyAssetPriceClient) Delete() *DailyAssetPriceDelete {
	mutation := newDailyAssetPriceMutation(c.config, OpDelete)
	return &DailyAssetPriceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DailyAssetPriceClient) DeleteOne(dap *DailyAssetPrice) *DailyAssetPriceDeleteOne {
	return c.DeleteOneID(dap.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *DailyAssetPriceClient) DeleteOneID(id pulid.PULID) *DailyAssetPriceDeleteOne {
	builder := c.Delete().Where(dailyassetprice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DailyAssetPriceDeleteOne{builder}
}

// Query returns a query builder for DailyAssetPrice.
func (c *DailyAssetPriceClient) Query() *DailyAssetPriceQuery {
	return &DailyAssetPriceQuery{
		config: c.config,
	}
}

// Get returns a DailyAssetPrice entity by its id.
func (c *DailyAssetPriceClient) Get(ctx context.Context, id pulid.PULID) (*DailyAssetPrice, error) {
	return c.Query().Where(dailyassetprice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DailyAssetPriceClient) GetX(ctx context.Context, id pulid.PULID) *DailyAssetPrice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAsset queries the asset edge of a DailyAssetPrice.
func (c *DailyAssetPriceClient) QueryAsset(dap *DailyAssetPrice) *AssetQuery {
	query := &AssetQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := dap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dailyassetprice.Table, dailyassetprice.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dailyassetprice.AssetTable, dailyassetprice.AssetColumn),
		)
		fromV = sqlgraph.Neighbors(dap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DailyAssetPriceClient) Hooks() []Hook {
	return c.hooks.DailyAssetPrice
}

// ExchangeClient is a client for the Exchange schema.
type ExchangeClient struct {
	config
}

// NewExchangeClient returns a client for the Exchange from the given config.
func NewExchangeClient(c config) *ExchangeClient {
	return &ExchangeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exchange.Hooks(f(g(h())))`.
func (c *ExchangeClient) Use(hooks ...Hook) {
	c.hooks.Exchange = append(c.hooks.Exchange, hooks...)
}

// Create returns a builder for creating a Exchange entity.
func (c *ExchangeClient) Create() *ExchangeCreate {
	mutation := newExchangeMutation(c.config, OpCreate)
	return &ExchangeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Exchange entities.
func (c *ExchangeClient) CreateBulk(builders ...*ExchangeCreate) *ExchangeCreateBulk {
	return &ExchangeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Exchange.
func (c *ExchangeClient) Update() *ExchangeUpdate {
	mutation := newExchangeMutation(c.config, OpUpdate)
	return &ExchangeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExchangeClient) UpdateOne(e *Exchange) *ExchangeUpdateOne {
	mutation := newExchangeMutation(c.config, OpUpdateOne, withExchange(e))
	return &ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExchangeClient) UpdateOneID(id pulid.PULID) *ExchangeUpdateOne {
	mutation := newExchangeMutation(c.config, OpUpdateOne, withExchangeID(id))
	return &ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Exchange.
func (c *ExchangeClient) Delete() *ExchangeDelete {
	mutation := newExchangeMutation(c.config, OpDelete)
	return &ExchangeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExchangeClient) DeleteOne(e *Exchange) *ExchangeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ExchangeClient) DeleteOneID(id pulid.PULID) *ExchangeDeleteOne {
	builder := c.Delete().Where(exchange.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExchangeDeleteOne{builder}
}

// Query returns a query builder for Exchange.
func (c *ExchangeClient) Query() *ExchangeQuery {
	return &ExchangeQuery{
		config: c.config,
	}
}

// Get returns a Exchange entity by its id.
func (c *ExchangeClient) Get(ctx context.Context, id pulid.PULID) (*Exchange, error) {
	return c.Query().Where(exchange.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExchangeClient) GetX(ctx context.Context, id pulid.PULID) *Exchange {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTransactions queries the transactions edge of a Exchange.
func (c *ExchangeClient) QueryTransactions(e *Exchange) *TransactionQuery {
	query := &TransactionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exchange.Table, exchange.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exchange.TransactionsTable, exchange.TransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExchangeClient) Hooks() []Hook {
	return c.hooks.Exchange
}

// PortfolioClient is a client for the Portfolio schema.
type PortfolioClient struct {
	config
}

// NewPortfolioClient returns a client for the Portfolio from the given config.
func NewPortfolioClient(c config) *PortfolioClient {
	return &PortfolioClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `portfolio.Hooks(f(g(h())))`.
func (c *PortfolioClient) Use(hooks ...Hook) {
	c.hooks.Portfolio = append(c.hooks.Portfolio, hooks...)
}

// Create returns a builder for creating a Portfolio entity.
func (c *PortfolioClient) Create() *PortfolioCreate {
	mutation := newPortfolioMutation(c.config, OpCreate)
	return &PortfolioCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Portfolio entities.
func (c *PortfolioClient) CreateBulk(builders ...*PortfolioCreate) *PortfolioCreateBulk {
	return &PortfolioCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Portfolio.
func (c *PortfolioClient) Update() *PortfolioUpdate {
	mutation := newPortfolioMutation(c.config, OpUpdate)
	return &PortfolioUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PortfolioClient) UpdateOne(po *Portfolio) *PortfolioUpdateOne {
	mutation := newPortfolioMutation(c.config, OpUpdateOne, withPortfolio(po))
	return &PortfolioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PortfolioClient) UpdateOneID(id pulid.PULID) *PortfolioUpdateOne {
	mutation := newPortfolioMutation(c.config, OpUpdateOne, withPortfolioID(id))
	return &PortfolioUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Portfolio.
func (c *PortfolioClient) Delete() *PortfolioDelete {
	mutation := newPortfolioMutation(c.config, OpDelete)
	return &PortfolioDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PortfolioClient) DeleteOne(po *Portfolio) *PortfolioDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *PortfolioClient) DeleteOneID(id pulid.PULID) *PortfolioDeleteOne {
	builder := c.Delete().Where(portfolio.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PortfolioDeleteOne{builder}
}

// Query returns a query builder for Portfolio.
func (c *PortfolioClient) Query() *PortfolioQuery {
	return &PortfolioQuery{
		config: c.config,
	}
}

// Get returns a Portfolio entity by its id.
func (c *PortfolioClient) Get(ctx context.Context, id pulid.PULID) (*Portfolio, error) {
	return c.Query().Where(portfolio.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PortfolioClient) GetX(ctx context.Context, id pulid.PULID) *Portfolio {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a Portfolio.
func (c *PortfolioClient) QueryAccount(po *Portfolio) *AccountQuery {
	query := &AccountQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(portfolio.Table, portfolio.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, portfolio.AccountTable, portfolio.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTransactions queries the transactions edge of a Portfolio.
func (c *PortfolioClient) QueryTransactions(po *Portfolio) *TransactionQuery {
	query := &TransactionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(portfolio.Table, portfolio.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, portfolio.TransactionsTable, portfolio.TransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PortfolioClient) Hooks() []Hook {
	return c.hooks.Portfolio
}

// StaffAccountClient is a client for the StaffAccount schema.
type StaffAccountClient struct {
	config
}

// NewStaffAccountClient returns a client for the StaffAccount from the given config.
func NewStaffAccountClient(c config) *StaffAccountClient {
	return &StaffAccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `staffaccount.Hooks(f(g(h())))`.
func (c *StaffAccountClient) Use(hooks ...Hook) {
	c.hooks.StaffAccount = append(c.hooks.StaffAccount, hooks...)
}

// Create returns a builder for creating a StaffAccount entity.
func (c *StaffAccountClient) Create() *StaffAccountCreate {
	mutation := newStaffAccountMutation(c.config, OpCreate)
	return &StaffAccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of StaffAccount entities.
func (c *StaffAccountClient) CreateBulk(builders ...*StaffAccountCreate) *StaffAccountCreateBulk {
	return &StaffAccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for StaffAccount.
func (c *StaffAccountClient) Update() *StaffAccountUpdate {
	mutation := newStaffAccountMutation(c.config, OpUpdate)
	return &StaffAccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StaffAccountClient) UpdateOne(sa *StaffAccount) *StaffAccountUpdateOne {
	mutation := newStaffAccountMutation(c.config, OpUpdateOne, withStaffAccount(sa))
	return &StaffAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StaffAccountClient) UpdateOneID(id pulid.PULID) *StaffAccountUpdateOne {
	mutation := newStaffAccountMutation(c.config, OpUpdateOne, withStaffAccountID(id))
	return &StaffAccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for StaffAccount.
func (c *StaffAccountClient) Delete() *StaffAccountDelete {
	mutation := newStaffAccountMutation(c.config, OpDelete)
	return &StaffAccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StaffAccountClient) DeleteOne(sa *StaffAccount) *StaffAccountDeleteOne {
	return c.DeleteOneID(sa.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *StaffAccountClient) DeleteOneID(id pulid.PULID) *StaffAccountDeleteOne {
	builder := c.Delete().Where(staffaccount.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StaffAccountDeleteOne{builder}
}

// Query returns a query builder for StaffAccount.
func (c *StaffAccountClient) Query() *StaffAccountQuery {
	return &StaffAccountQuery{
		config: c.config,
	}
}

// Get returns a StaffAccount entity by its id.
func (c *StaffAccountClient) Get(ctx context.Context, id pulid.PULID) (*StaffAccount, error) {
	return c.Query().Where(staffaccount.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StaffAccountClient) GetX(ctx context.Context, id pulid.PULID) *StaffAccount {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthRoles queries the auth_roles edge of a StaffAccount.
func (c *StaffAccountClient) QueryAuthRoles(sa *StaffAccount) *AuthRoleQuery {
	query := &AuthRoleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staffaccount.Table, staffaccount.FieldID, id),
			sqlgraph.To(authrole.Table, authrole.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, staffaccount.AuthRolesTable, staffaccount.AuthRolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthType queries the auth_type edge of a StaffAccount.
func (c *StaffAccountClient) QueryAuthType(sa *StaffAccount) *AuthTypeQuery {
	query := &AuthTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staffaccount.Table, staffaccount.FieldID, id),
			sqlgraph.To(authtype.Table, authtype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, staffaccount.AuthTypeTable, staffaccount.AuthTypeColumn),
		)
		fromV = sqlgraph.Neighbors(sa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StaffAccountClient) Hooks() []Hook {
	return c.hooks.StaffAccount
}

// TransactionClient is a client for the Transaction schema.
type TransactionClient struct {
	config
}

// NewTransactionClient returns a client for the Transaction from the given config.
func NewTransactionClient(c config) *TransactionClient {
	return &TransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transaction.Hooks(f(g(h())))`.
func (c *TransactionClient) Use(hooks ...Hook) {
	c.hooks.Transaction = append(c.hooks.Transaction, hooks...)
}

// Create returns a builder for creating a Transaction entity.
func (c *TransactionClient) Create() *TransactionCreate {
	mutation := newTransactionMutation(c.config, OpCreate)
	return &TransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Transaction entities.
func (c *TransactionClient) CreateBulk(builders ...*TransactionCreate) *TransactionCreateBulk {
	return &TransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Transaction.
func (c *TransactionClient) Update() *TransactionUpdate {
	mutation := newTransactionMutation(c.config, OpUpdate)
	return &TransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransactionClient) UpdateOne(t *Transaction) *TransactionUpdateOne {
	mutation := newTransactionMutation(c.config, OpUpdateOne, withTransaction(t))
	return &TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransactionClient) UpdateOneID(id pulid.PULID) *TransactionUpdateOne {
	mutation := newTransactionMutation(c.config, OpUpdateOne, withTransactionID(id))
	return &TransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Transaction.
func (c *TransactionClient) Delete() *TransactionDelete {
	mutation := newTransactionMutation(c.config, OpDelete)
	return &TransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransactionClient) DeleteOne(t *Transaction) *TransactionDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TransactionClient) DeleteOneID(id pulid.PULID) *TransactionDeleteOne {
	builder := c.Delete().Where(transaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransactionDeleteOne{builder}
}

// Query returns a query builder for Transaction.
func (c *TransactionClient) Query() *TransactionQuery {
	return &TransactionQuery{
		config: c.config,
	}
}

// Get returns a Transaction entity by its id.
func (c *TransactionClient) Get(ctx context.Context, id pulid.PULID) (*Transaction, error) {
	return c.Query().Where(transaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransactionClient) GetX(ctx context.Context, id pulid.PULID) *Transaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTransactionType queries the transaction_type edge of a Transaction.
func (c *TransactionClient) QueryTransactionType(t *Transaction) *TransactionTypeQuery {
	query := &TransactionTypeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(transactiontype.Table, transactiontype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transaction.TransactionTypeTable, transaction.TransactionTypeColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBaseAsset queries the base_asset edge of a Transaction.
func (c *TransactionClient) QueryBaseAsset(t *Transaction) *AssetQuery {
	query := &AssetQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transaction.BaseAssetTable, transaction.BaseAssetColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuoteAsset queries the quote_asset edge of a Transaction.
func (c *TransactionClient) QueryQuoteAsset(t *Transaction) *AssetQuery {
	query := &AssetQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(asset.Table, asset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transaction.QuoteAssetTable, transaction.QuoteAssetColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPortfolio queries the portfolio edge of a Transaction.
func (c *TransactionClient) QueryPortfolio(t *Transaction) *PortfolioQuery {
	query := &PortfolioQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(portfolio.Table, portfolio.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transaction.PortfolioTable, transaction.PortfolioColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExchange queries the exchange edge of a Transaction.
func (c *TransactionClient) QueryExchange(t *Transaction) *ExchangeQuery {
	query := &ExchangeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(exchange.Table, exchange.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, transaction.ExchangeTable, transaction.ExchangeColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlockchain queries the blockchain edge of a Transaction.
func (c *TransactionClient) QueryBlockchain(t *Transaction) *BlockchainQuery {
	query := &BlockchainQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transaction.Table, transaction.FieldID, id),
			sqlgraph.To(blockchain.Table, blockchain.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, transaction.BlockchainTable, transaction.BlockchainColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransactionClient) Hooks() []Hook {
	return c.hooks.Transaction
}

// TransactionTypeClient is a client for the TransactionType schema.
type TransactionTypeClient struct {
	config
}

// NewTransactionTypeClient returns a client for the TransactionType from the given config.
func NewTransactionTypeClient(c config) *TransactionTypeClient {
	return &TransactionTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `transactiontype.Hooks(f(g(h())))`.
func (c *TransactionTypeClient) Use(hooks ...Hook) {
	c.hooks.TransactionType = append(c.hooks.TransactionType, hooks...)
}

// Create returns a builder for creating a TransactionType entity.
func (c *TransactionTypeClient) Create() *TransactionTypeCreate {
	mutation := newTransactionTypeMutation(c.config, OpCreate)
	return &TransactionTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TransactionType entities.
func (c *TransactionTypeClient) CreateBulk(builders ...*TransactionTypeCreate) *TransactionTypeCreateBulk {
	return &TransactionTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TransactionType.
func (c *TransactionTypeClient) Update() *TransactionTypeUpdate {
	mutation := newTransactionTypeMutation(c.config, OpUpdate)
	return &TransactionTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TransactionTypeClient) UpdateOne(tt *TransactionType) *TransactionTypeUpdateOne {
	mutation := newTransactionTypeMutation(c.config, OpUpdateOne, withTransactionType(tt))
	return &TransactionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TransactionTypeClient) UpdateOneID(id pulid.PULID) *TransactionTypeUpdateOne {
	mutation := newTransactionTypeMutation(c.config, OpUpdateOne, withTransactionTypeID(id))
	return &TransactionTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TransactionType.
func (c *TransactionTypeClient) Delete() *TransactionTypeDelete {
	mutation := newTransactionTypeMutation(c.config, OpDelete)
	return &TransactionTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TransactionTypeClient) DeleteOne(tt *TransactionType) *TransactionTypeDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *TransactionTypeClient) DeleteOneID(id pulid.PULID) *TransactionTypeDeleteOne {
	builder := c.Delete().Where(transactiontype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TransactionTypeDeleteOne{builder}
}

// Query returns a query builder for TransactionType.
func (c *TransactionTypeClient) Query() *TransactionTypeQuery {
	return &TransactionTypeQuery{
		config: c.config,
	}
}

// Get returns a TransactionType entity by its id.
func (c *TransactionTypeClient) Get(ctx context.Context, id pulid.PULID) (*TransactionType, error) {
	return c.Query().Where(transactiontype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TransactionTypeClient) GetX(ctx context.Context, id pulid.PULID) *TransactionType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTransactions queries the transactions edge of a TransactionType.
func (c *TransactionTypeClient) QueryTransactions(tt *TransactionType) *TransactionQuery {
	query := &TransactionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(transactiontype.Table, transactiontype.FieldID, id),
			sqlgraph.To(transaction.Table, transaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, transactiontype.TransactionsTable, transactiontype.TransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TransactionTypeClient) Hooks() []Hook {
	return c.hooks.TransactionType
}
