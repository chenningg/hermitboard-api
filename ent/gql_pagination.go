// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/accountauthrole"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/blockchaincryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/schema/pulid"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    pulid.PULID `msgpack:"i"`
	Value Value       `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccountEdge is the edge representation of Account.
type AccountEdge struct {
	Node   *Account `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AccountConnection is the connection containing edges to Account.
type AccountConnection struct {
	Edges      []*AccountEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *AccountConnection) build(nodes []*Account, pager *accountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Account
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Account {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Account {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountPaginateOption enables pagination customization.
type AccountPaginateOption func(*accountPager) error

// WithAccountOrder configures pagination ordering.
func WithAccountOrder(order *AccountOrder) AccountPaginateOption {
	if order == nil {
		order = DefaultAccountOrder
	}
	o := *order
	return func(pager *accountPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountFilter configures pagination filter.
func WithAccountFilter(filter func(*AccountQuery) (*AccountQuery, error)) AccountPaginateOption {
	return func(pager *accountPager) error {
		if filter == nil {
			return errors.New("AccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountPager struct {
	order  *AccountOrder
	filter func(*AccountQuery) (*AccountQuery, error)
}

func newAccountPager(opts []AccountPaginateOption) (*accountPager, error) {
	pager := &accountPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountOrder
	}
	return pager, nil
}

func (p *accountPager) applyFilter(query *AccountQuery) (*AccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountPager) toCursor(a *Account) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *accountPager) applyCursors(query *AccountQuery, after, before *Cursor) *AccountQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAccountOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *accountPager) applyOrder(query *AccountQuery, reverse bool) *AccountQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAccountOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAccountOrder.Field.field))
	}
	return query
}

func (p *accountPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountOrder.Field {
			b.Comma().Ident(DefaultAccountOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Account.
func (a *AccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountPaginateOption,
) (*AccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AccountConnection{Edges: []*AccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AccountOrderFieldAuthType orders Account by auth_type.
	AccountOrderFieldAuthType = &AccountOrderField{
		field: account.FieldAuthType,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.AuthType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AccountOrderField) String() string {
	var str string
	switch f.field {
	case account.FieldAuthType:
		str = "AUTH_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AccountOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AccountOrderField %T must be a string", v)
	}
	switch str {
	case "AUTH_TYPE":
		*f = *AccountOrderFieldAuthType
	default:
		return fmt.Errorf("%s is not a valid AccountOrderField", str)
	}
	return nil
}

// AccountOrderField defines the ordering field of Account.
type AccountOrderField struct {
	field    string
	toCursor func(*Account) Cursor
}

// AccountOrder defines the ordering of Account.
type AccountOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AccountOrderField `json:"field"`
}

// DefaultAccountOrder is the default ordering of Account.
var DefaultAccountOrder = &AccountOrder{
	Direction: OrderDirectionAsc,
	Field: &AccountOrderField{
		field: account.FieldID,
		toCursor: func(a *Account) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Account into AccountEdge.
func (a *Account) ToEdge(order *AccountOrder) *AccountEdge {
	if order == nil {
		order = DefaultAccountOrder
	}
	return &AccountEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AccountAuthRoleEdge is the edge representation of AccountAuthRole.
type AccountAuthRoleEdge struct {
	Node   *AccountAuthRole `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// AccountAuthRoleConnection is the connection containing edges to AccountAuthRole.
type AccountAuthRoleConnection struct {
	Edges      []*AccountAuthRoleEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *AccountAuthRoleConnection) build(nodes []*AccountAuthRole, pager *accountauthrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AccountAuthRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccountAuthRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccountAuthRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountAuthRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountAuthRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountAuthRolePaginateOption enables pagination customization.
type AccountAuthRolePaginateOption func(*accountauthrolePager) error

// WithAccountAuthRoleOrder configures pagination ordering.
func WithAccountAuthRoleOrder(order *AccountAuthRoleOrder) AccountAuthRolePaginateOption {
	if order == nil {
		order = DefaultAccountAuthRoleOrder
	}
	o := *order
	return func(pager *accountauthrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountAuthRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountAuthRoleFilter configures pagination filter.
func WithAccountAuthRoleFilter(filter func(*AccountAuthRoleQuery) (*AccountAuthRoleQuery, error)) AccountAuthRolePaginateOption {
	return func(pager *accountauthrolePager) error {
		if filter == nil {
			return errors.New("AccountAuthRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountauthrolePager struct {
	order  *AccountAuthRoleOrder
	filter func(*AccountAuthRoleQuery) (*AccountAuthRoleQuery, error)
}

func newAccountAuthRolePager(opts []AccountAuthRolePaginateOption) (*accountauthrolePager, error) {
	pager := &accountauthrolePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountAuthRoleOrder
	}
	return pager, nil
}

func (p *accountauthrolePager) applyFilter(query *AccountAuthRoleQuery) (*AccountAuthRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountauthrolePager) toCursor(aar *AccountAuthRole) Cursor {
	return p.order.Field.toCursor(aar)
}

func (p *accountauthrolePager) applyCursors(query *AccountAuthRoleQuery, after, before *Cursor) *AccountAuthRoleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAccountAuthRoleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *accountauthrolePager) applyOrder(query *AccountAuthRoleQuery, reverse bool) *AccountAuthRoleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAccountAuthRoleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAccountAuthRoleOrder.Field.field))
	}
	return query
}

func (p *accountauthrolePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountAuthRoleOrder.Field {
			b.Comma().Ident(DefaultAccountAuthRoleOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AccountAuthRole.
func (aar *AccountAuthRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountAuthRolePaginateOption,
) (*AccountAuthRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountAuthRolePager(opts)
	if err != nil {
		return nil, err
	}
	if aar, err = pager.applyFilter(aar); err != nil {
		return nil, err
	}
	conn := &AccountAuthRoleConnection{Edges: []*AccountAuthRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = aar.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	aar = pager.applyCursors(aar, after, before)
	aar = pager.applyOrder(aar, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		aar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := aar.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := aar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AccountAuthRoleOrderField defines the ordering field of AccountAuthRole.
type AccountAuthRoleOrderField struct {
	field    string
	toCursor func(*AccountAuthRole) Cursor
}

// AccountAuthRoleOrder defines the ordering of AccountAuthRole.
type AccountAuthRoleOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *AccountAuthRoleOrderField `json:"field"`
}

// DefaultAccountAuthRoleOrder is the default ordering of AccountAuthRole.
var DefaultAccountAuthRoleOrder = &AccountAuthRoleOrder{
	Direction: OrderDirectionAsc,
	Field: &AccountAuthRoleOrderField{
		field: accountauthrole.FieldID,
		toCursor: func(aar *AccountAuthRole) Cursor {
			return Cursor{ID: aar.ID}
		},
	},
}

// ToEdge converts AccountAuthRole into AccountAuthRoleEdge.
func (aar *AccountAuthRole) ToEdge(order *AccountAuthRoleOrder) *AccountAuthRoleEdge {
	if order == nil {
		order = DefaultAccountAuthRoleOrder
	}
	return &AccountAuthRoleEdge{
		Node:   aar,
		Cursor: order.Field.toCursor(aar),
	}
}

// AssetEdge is the edge representation of Asset.
type AssetEdge struct {
	Node   *Asset `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AssetConnection is the connection containing edges to Asset.
type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AssetConnection) build(nodes []*Asset, pager *assetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Asset
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Asset {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Asset {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetPaginateOption enables pagination customization.
type AssetPaginateOption func(*assetPager) error

// WithAssetOrder configures pagination ordering.
func WithAssetOrder(order *AssetOrder) AssetPaginateOption {
	if order == nil {
		order = DefaultAssetOrder
	}
	o := *order
	return func(pager *assetPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetFilter configures pagination filter.
func WithAssetFilter(filter func(*AssetQuery) (*AssetQuery, error)) AssetPaginateOption {
	return func(pager *assetPager) error {
		if filter == nil {
			return errors.New("AssetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetPager struct {
	order  *AssetOrder
	filter func(*AssetQuery) (*AssetQuery, error)
}

func newAssetPager(opts []AssetPaginateOption) (*assetPager, error) {
	pager := &assetPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetOrder
	}
	return pager, nil
}

func (p *assetPager) applyFilter(query *AssetQuery) (*AssetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetPager) toCursor(a *Asset) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *assetPager) applyCursors(query *AssetQuery, after, before *Cursor) *AssetQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAssetOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *assetPager) applyOrder(query *AssetQuery, reverse bool) *AssetQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAssetOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAssetOrder.Field.field))
	}
	return query
}

func (p *assetPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetOrder.Field {
			b.Comma().Ident(DefaultAssetOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Asset.
func (a *AssetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetPaginateOption,
) (*AssetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AssetConnection{Edges: []*AssetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AssetOrderField defines the ordering field of Asset.
type AssetOrderField struct {
	field    string
	toCursor func(*Asset) Cursor
}

// AssetOrder defines the ordering of Asset.
type AssetOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AssetOrderField `json:"field"`
}

// DefaultAssetOrder is the default ordering of Asset.
var DefaultAssetOrder = &AssetOrder{
	Direction: OrderDirectionAsc,
	Field: &AssetOrderField{
		field: asset.FieldID,
		toCursor: func(a *Asset) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Asset into AssetEdge.
func (a *Asset) ToEdge(order *AssetOrder) *AssetEdge {
	if order == nil {
		order = DefaultAssetOrder
	}
	return &AssetEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AssetClassEdge is the edge representation of AssetClass.
type AssetClassEdge struct {
	Node   *AssetClass `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AssetClassConnection is the connection containing edges to AssetClass.
type AssetClassConnection struct {
	Edges      []*AssetClassEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AssetClassConnection) build(nodes []*AssetClass, pager *assetclassPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AssetClass
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssetClass {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssetClass {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetClassEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetClassEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetClassPaginateOption enables pagination customization.
type AssetClassPaginateOption func(*assetclassPager) error

// WithAssetClassOrder configures pagination ordering.
func WithAssetClassOrder(order *AssetClassOrder) AssetClassPaginateOption {
	if order == nil {
		order = DefaultAssetClassOrder
	}
	o := *order
	return func(pager *assetclassPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetClassOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetClassFilter configures pagination filter.
func WithAssetClassFilter(filter func(*AssetClassQuery) (*AssetClassQuery, error)) AssetClassPaginateOption {
	return func(pager *assetclassPager) error {
		if filter == nil {
			return errors.New("AssetClassQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetclassPager struct {
	order  *AssetClassOrder
	filter func(*AssetClassQuery) (*AssetClassQuery, error)
}

func newAssetClassPager(opts []AssetClassPaginateOption) (*assetclassPager, error) {
	pager := &assetclassPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetClassOrder
	}
	return pager, nil
}

func (p *assetclassPager) applyFilter(query *AssetClassQuery) (*AssetClassQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetclassPager) toCursor(ac *AssetClass) Cursor {
	return p.order.Field.toCursor(ac)
}

func (p *assetclassPager) applyCursors(query *AssetClassQuery, after, before *Cursor) *AssetClassQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAssetClassOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *assetclassPager) applyOrder(query *AssetClassQuery, reverse bool) *AssetClassQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAssetClassOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAssetClassOrder.Field.field))
	}
	return query
}

func (p *assetclassPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetClassOrder.Field {
			b.Comma().Ident(DefaultAssetClassOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssetClass.
func (ac *AssetClassQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetClassPaginateOption,
) (*AssetClassConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetClassPager(opts)
	if err != nil {
		return nil, err
	}
	if ac, err = pager.applyFilter(ac); err != nil {
		return nil, err
	}
	conn := &AssetClassConnection{Edges: []*AssetClassEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ac.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ac = pager.applyCursors(ac, after, before)
	ac = pager.applyOrder(ac, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ac.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ac.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ac.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetClassOrderFieldAssetClass orders AssetClass by asset_class.
	AssetClassOrderFieldAssetClass = &AssetClassOrderField{
		field: assetclass.FieldAssetClass,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{
				ID:    ac.ID,
				Value: ac.AssetClass,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetClassOrderField) String() string {
	var str string
	switch f.field {
	case assetclass.FieldAssetClass:
		str = "ASSET_CLASS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetClassOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetClassOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetClassOrderField %T must be a string", v)
	}
	switch str {
	case "ASSET_CLASS":
		*f = *AssetClassOrderFieldAssetClass
	default:
		return fmt.Errorf("%s is not a valid AssetClassOrderField", str)
	}
	return nil
}

// AssetClassOrderField defines the ordering field of AssetClass.
type AssetClassOrderField struct {
	field    string
	toCursor func(*AssetClass) Cursor
}

// AssetClassOrder defines the ordering of AssetClass.
type AssetClassOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AssetClassOrderField `json:"field"`
}

// DefaultAssetClassOrder is the default ordering of AssetClass.
var DefaultAssetClassOrder = &AssetClassOrder{
	Direction: OrderDirectionAsc,
	Field: &AssetClassOrderField{
		field: assetclass.FieldID,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{ID: ac.ID}
		},
	},
}

// ToEdge converts AssetClass into AssetClassEdge.
func (ac *AssetClass) ToEdge(order *AssetClassOrder) *AssetClassEdge {
	if order == nil {
		order = DefaultAssetClassOrder
	}
	return &AssetClassEdge{
		Node:   ac,
		Cursor: order.Field.toCursor(ac),
	}
}

// AuthRoleEdge is the edge representation of AuthRole.
type AuthRoleEdge struct {
	Node   *AuthRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuthRoleConnection is the connection containing edges to AuthRole.
type AuthRoleConnection struct {
	Edges      []*AuthRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuthRoleConnection) build(nodes []*AuthRole, pager *authrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuthRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuthRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuthRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuthRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuthRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuthRolePaginateOption enables pagination customization.
type AuthRolePaginateOption func(*authrolePager) error

// WithAuthRoleOrder configures pagination ordering.
func WithAuthRoleOrder(order *AuthRoleOrder) AuthRolePaginateOption {
	if order == nil {
		order = DefaultAuthRoleOrder
	}
	o := *order
	return func(pager *authrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthRoleFilter configures pagination filter.
func WithAuthRoleFilter(filter func(*AuthRoleQuery) (*AuthRoleQuery, error)) AuthRolePaginateOption {
	return func(pager *authrolePager) error {
		if filter == nil {
			return errors.New("AuthRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authrolePager struct {
	order  *AuthRoleOrder
	filter func(*AuthRoleQuery) (*AuthRoleQuery, error)
}

func newAuthRolePager(opts []AuthRolePaginateOption) (*authrolePager, error) {
	pager := &authrolePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthRoleOrder
	}
	return pager, nil
}

func (p *authrolePager) applyFilter(query *AuthRoleQuery) (*AuthRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authrolePager) toCursor(ar *AuthRole) Cursor {
	return p.order.Field.toCursor(ar)
}

func (p *authrolePager) applyCursors(query *AuthRoleQuery, after, before *Cursor) *AuthRoleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAuthRoleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *authrolePager) applyOrder(query *AuthRoleQuery, reverse bool) *AuthRoleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAuthRoleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAuthRoleOrder.Field.field))
	}
	return query
}

func (p *authrolePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuthRoleOrder.Field {
			b.Comma().Ident(DefaultAuthRoleOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuthRole.
func (ar *AuthRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthRolePaginateOption,
) (*AuthRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthRolePager(opts)
	if err != nil {
		return nil, err
	}
	if ar, err = pager.applyFilter(ar); err != nil {
		return nil, err
	}
	conn := &AuthRoleConnection{Edges: []*AuthRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ar.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ar = pager.applyCursors(ar, after, before)
	ar = pager.applyOrder(ar, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ar.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuthRoleOrderFieldAuthRole orders AuthRole by auth_role.
	AuthRoleOrderFieldAuthRole = &AuthRoleOrderField{
		field: authrole.FieldAuthRole,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.AuthRole,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuthRoleOrderField) String() string {
	var str string
	switch f.field {
	case authrole.FieldAuthRole:
		str = "AUTH_ROLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuthRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuthRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuthRoleOrderField %T must be a string", v)
	}
	switch str {
	case "AUTH_ROLE":
		*f = *AuthRoleOrderFieldAuthRole
	default:
		return fmt.Errorf("%s is not a valid AuthRoleOrderField", str)
	}
	return nil
}

// AuthRoleOrderField defines the ordering field of AuthRole.
type AuthRoleOrderField struct {
	field    string
	toCursor func(*AuthRole) Cursor
}

// AuthRoleOrder defines the ordering of AuthRole.
type AuthRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuthRoleOrderField `json:"field"`
}

// DefaultAuthRoleOrder is the default ordering of AuthRole.
var DefaultAuthRoleOrder = &AuthRoleOrder{
	Direction: OrderDirectionAsc,
	Field: &AuthRoleOrderField{
		field: authrole.FieldID,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{ID: ar.ID}
		},
	},
}

// ToEdge converts AuthRole into AuthRoleEdge.
func (ar *AuthRole) ToEdge(order *AuthRoleOrder) *AuthRoleEdge {
	if order == nil {
		order = DefaultAuthRoleOrder
	}
	return &AuthRoleEdge{
		Node:   ar,
		Cursor: order.Field.toCursor(ar),
	}
}

// BlockchainEdge is the edge representation of Blockchain.
type BlockchainEdge struct {
	Node   *Blockchain `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// BlockchainConnection is the connection containing edges to Blockchain.
type BlockchainConnection struct {
	Edges      []*BlockchainEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *BlockchainConnection) build(nodes []*Blockchain, pager *blockchainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Blockchain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Blockchain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Blockchain {
			return nodes[i]
		}
	}
	c.Edges = make([]*BlockchainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BlockchainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BlockchainPaginateOption enables pagination customization.
type BlockchainPaginateOption func(*blockchainPager) error

// WithBlockchainOrder configures pagination ordering.
func WithBlockchainOrder(order *BlockchainOrder) BlockchainPaginateOption {
	if order == nil {
		order = DefaultBlockchainOrder
	}
	o := *order
	return func(pager *blockchainPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBlockchainOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBlockchainFilter configures pagination filter.
func WithBlockchainFilter(filter func(*BlockchainQuery) (*BlockchainQuery, error)) BlockchainPaginateOption {
	return func(pager *blockchainPager) error {
		if filter == nil {
			return errors.New("BlockchainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type blockchainPager struct {
	order  *BlockchainOrder
	filter func(*BlockchainQuery) (*BlockchainQuery, error)
}

func newBlockchainPager(opts []BlockchainPaginateOption) (*blockchainPager, error) {
	pager := &blockchainPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBlockchainOrder
	}
	return pager, nil
}

func (p *blockchainPager) applyFilter(query *BlockchainQuery) (*BlockchainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *blockchainPager) toCursor(b *Blockchain) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *blockchainPager) applyCursors(query *BlockchainQuery, after, before *Cursor) *BlockchainQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBlockchainOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *blockchainPager) applyOrder(query *BlockchainQuery, reverse bool) *BlockchainQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBlockchainOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBlockchainOrder.Field.field))
	}
	return query
}

func (p *blockchainPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBlockchainOrder.Field {
			b.Comma().Ident(DefaultBlockchainOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Blockchain.
func (b *BlockchainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BlockchainPaginateOption,
) (*BlockchainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBlockchainPager(opts)
	if err != nil {
		return nil, err
	}
	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}
	conn := &BlockchainConnection{Edges: []*BlockchainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = b.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	b = pager.applyCursors(b, after, before)
	b = pager.applyOrder(b, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		b.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := b.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := b.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BlockchainOrderField defines the ordering field of Blockchain.
type BlockchainOrderField struct {
	field    string
	toCursor func(*Blockchain) Cursor
}

// BlockchainOrder defines the ordering of Blockchain.
type BlockchainOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *BlockchainOrderField `json:"field"`
}

// DefaultBlockchainOrder is the default ordering of Blockchain.
var DefaultBlockchainOrder = &BlockchainOrder{
	Direction: OrderDirectionAsc,
	Field: &BlockchainOrderField{
		field: blockchain.FieldID,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Blockchain into BlockchainEdge.
func (b *Blockchain) ToEdge(order *BlockchainOrder) *BlockchainEdge {
	if order == nil {
		order = DefaultBlockchainOrder
	}
	return &BlockchainEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// BlockchainCryptocurrencyEdge is the edge representation of BlockchainCryptocurrency.
type BlockchainCryptocurrencyEdge struct {
	Node   *BlockchainCryptocurrency `json:"node"`
	Cursor Cursor                    `json:"cursor"`
}

// BlockchainCryptocurrencyConnection is the connection containing edges to BlockchainCryptocurrency.
type BlockchainCryptocurrencyConnection struct {
	Edges      []*BlockchainCryptocurrencyEdge `json:"edges"`
	PageInfo   PageInfo                        `json:"pageInfo"`
	TotalCount int                             `json:"totalCount"`
}

func (c *BlockchainCryptocurrencyConnection) build(nodes []*BlockchainCryptocurrency, pager *blockchaincryptocurrencyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BlockchainCryptocurrency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BlockchainCryptocurrency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BlockchainCryptocurrency {
			return nodes[i]
		}
	}
	c.Edges = make([]*BlockchainCryptocurrencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BlockchainCryptocurrencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BlockchainCryptocurrencyPaginateOption enables pagination customization.
type BlockchainCryptocurrencyPaginateOption func(*blockchaincryptocurrencyPager) error

// WithBlockchainCryptocurrencyOrder configures pagination ordering.
func WithBlockchainCryptocurrencyOrder(order *BlockchainCryptocurrencyOrder) BlockchainCryptocurrencyPaginateOption {
	if order == nil {
		order = DefaultBlockchainCryptocurrencyOrder
	}
	o := *order
	return func(pager *blockchaincryptocurrencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBlockchainCryptocurrencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBlockchainCryptocurrencyFilter configures pagination filter.
func WithBlockchainCryptocurrencyFilter(filter func(*BlockchainCryptocurrencyQuery) (*BlockchainCryptocurrencyQuery, error)) BlockchainCryptocurrencyPaginateOption {
	return func(pager *blockchaincryptocurrencyPager) error {
		if filter == nil {
			return errors.New("BlockchainCryptocurrencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type blockchaincryptocurrencyPager struct {
	order  *BlockchainCryptocurrencyOrder
	filter func(*BlockchainCryptocurrencyQuery) (*BlockchainCryptocurrencyQuery, error)
}

func newBlockchainCryptocurrencyPager(opts []BlockchainCryptocurrencyPaginateOption) (*blockchaincryptocurrencyPager, error) {
	pager := &blockchaincryptocurrencyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBlockchainCryptocurrencyOrder
	}
	return pager, nil
}

func (p *blockchaincryptocurrencyPager) applyFilter(query *BlockchainCryptocurrencyQuery) (*BlockchainCryptocurrencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *blockchaincryptocurrencyPager) toCursor(bc *BlockchainCryptocurrency) Cursor {
	return p.order.Field.toCursor(bc)
}

func (p *blockchaincryptocurrencyPager) applyCursors(query *BlockchainCryptocurrencyQuery, after, before *Cursor) *BlockchainCryptocurrencyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBlockchainCryptocurrencyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *blockchaincryptocurrencyPager) applyOrder(query *BlockchainCryptocurrencyQuery, reverse bool) *BlockchainCryptocurrencyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBlockchainCryptocurrencyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBlockchainCryptocurrencyOrder.Field.field))
	}
	return query
}

func (p *blockchaincryptocurrencyPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBlockchainCryptocurrencyOrder.Field {
			b.Comma().Ident(DefaultBlockchainCryptocurrencyOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BlockchainCryptocurrency.
func (bc *BlockchainCryptocurrencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BlockchainCryptocurrencyPaginateOption,
) (*BlockchainCryptocurrencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBlockchainCryptocurrencyPager(opts)
	if err != nil {
		return nil, err
	}
	if bc, err = pager.applyFilter(bc); err != nil {
		return nil, err
	}
	conn := &BlockchainCryptocurrencyConnection{Edges: []*BlockchainCryptocurrencyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bc.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	bc = pager.applyCursors(bc, after, before)
	bc = pager.applyOrder(bc, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		bc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := bc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BlockchainCryptocurrencyOrderField defines the ordering field of BlockchainCryptocurrency.
type BlockchainCryptocurrencyOrderField struct {
	field    string
	toCursor func(*BlockchainCryptocurrency) Cursor
}

// BlockchainCryptocurrencyOrder defines the ordering of BlockchainCryptocurrency.
type BlockchainCryptocurrencyOrder struct {
	Direction OrderDirection                      `json:"direction"`
	Field     *BlockchainCryptocurrencyOrderField `json:"field"`
}

// DefaultBlockchainCryptocurrencyOrder is the default ordering of BlockchainCryptocurrency.
var DefaultBlockchainCryptocurrencyOrder = &BlockchainCryptocurrencyOrder{
	Direction: OrderDirectionAsc,
	Field: &BlockchainCryptocurrencyOrderField{
		field: blockchaincryptocurrency.FieldID,
		toCursor: func(bc *BlockchainCryptocurrency) Cursor {
			return Cursor{ID: bc.ID}
		},
	},
}

// ToEdge converts BlockchainCryptocurrency into BlockchainCryptocurrencyEdge.
func (bc *BlockchainCryptocurrency) ToEdge(order *BlockchainCryptocurrencyOrder) *BlockchainCryptocurrencyEdge {
	if order == nil {
		order = DefaultBlockchainCryptocurrencyOrder
	}
	return &BlockchainCryptocurrencyEdge{
		Node:   bc,
		Cursor: order.Field.toCursor(bc),
	}
}

// CryptocurrencyEdge is the edge representation of Cryptocurrency.
type CryptocurrencyEdge struct {
	Node   *Cryptocurrency `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CryptocurrencyConnection is the connection containing edges to Cryptocurrency.
type CryptocurrencyConnection struct {
	Edges      []*CryptocurrencyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CryptocurrencyConnection) build(nodes []*Cryptocurrency, pager *cryptocurrencyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Cryptocurrency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Cryptocurrency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Cryptocurrency {
			return nodes[i]
		}
	}
	c.Edges = make([]*CryptocurrencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CryptocurrencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CryptocurrencyPaginateOption enables pagination customization.
type CryptocurrencyPaginateOption func(*cryptocurrencyPager) error

// WithCryptocurrencyOrder configures pagination ordering.
func WithCryptocurrencyOrder(order *CryptocurrencyOrder) CryptocurrencyPaginateOption {
	if order == nil {
		order = DefaultCryptocurrencyOrder
	}
	o := *order
	return func(pager *cryptocurrencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCryptocurrencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCryptocurrencyFilter configures pagination filter.
func WithCryptocurrencyFilter(filter func(*CryptocurrencyQuery) (*CryptocurrencyQuery, error)) CryptocurrencyPaginateOption {
	return func(pager *cryptocurrencyPager) error {
		if filter == nil {
			return errors.New("CryptocurrencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type cryptocurrencyPager struct {
	order  *CryptocurrencyOrder
	filter func(*CryptocurrencyQuery) (*CryptocurrencyQuery, error)
}

func newCryptocurrencyPager(opts []CryptocurrencyPaginateOption) (*cryptocurrencyPager, error) {
	pager := &cryptocurrencyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCryptocurrencyOrder
	}
	return pager, nil
}

func (p *cryptocurrencyPager) applyFilter(query *CryptocurrencyQuery) (*CryptocurrencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *cryptocurrencyPager) toCursor(c *Cryptocurrency) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *cryptocurrencyPager) applyCursors(query *CryptocurrencyQuery, after, before *Cursor) *CryptocurrencyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCryptocurrencyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *cryptocurrencyPager) applyOrder(query *CryptocurrencyQuery, reverse bool) *CryptocurrencyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCryptocurrencyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCryptocurrencyOrder.Field.field))
	}
	return query
}

func (p *cryptocurrencyPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCryptocurrencyOrder.Field {
			b.Comma().Ident(DefaultCryptocurrencyOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Cryptocurrency.
func (c *CryptocurrencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CryptocurrencyPaginateOption,
) (*CryptocurrencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCryptocurrencyPager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CryptocurrencyConnection{Edges: []*CryptocurrencyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CryptocurrencyOrderField defines the ordering field of Cryptocurrency.
type CryptocurrencyOrderField struct {
	field    string
	toCursor func(*Cryptocurrency) Cursor
}

// CryptocurrencyOrder defines the ordering of Cryptocurrency.
type CryptocurrencyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CryptocurrencyOrderField `json:"field"`
}

// DefaultCryptocurrencyOrder is the default ordering of Cryptocurrency.
var DefaultCryptocurrencyOrder = &CryptocurrencyOrder{
	Direction: OrderDirectionAsc,
	Field: &CryptocurrencyOrderField{
		field: cryptocurrency.FieldID,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Cryptocurrency into CryptocurrencyEdge.
func (c *Cryptocurrency) ToEdge(order *CryptocurrencyOrder) *CryptocurrencyEdge {
	if order == nil {
		order = DefaultCryptocurrencyOrder
	}
	return &CryptocurrencyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DailyAssetPriceEdge is the edge representation of DailyAssetPrice.
type DailyAssetPriceEdge struct {
	Node   *DailyAssetPrice `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// DailyAssetPriceConnection is the connection containing edges to DailyAssetPrice.
type DailyAssetPriceConnection struct {
	Edges      []*DailyAssetPriceEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *DailyAssetPriceConnection) build(nodes []*DailyAssetPrice, pager *dailyassetpricePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DailyAssetPrice
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DailyAssetPrice {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DailyAssetPrice {
			return nodes[i]
		}
	}
	c.Edges = make([]*DailyAssetPriceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DailyAssetPriceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DailyAssetPricePaginateOption enables pagination customization.
type DailyAssetPricePaginateOption func(*dailyassetpricePager) error

// WithDailyAssetPriceOrder configures pagination ordering.
func WithDailyAssetPriceOrder(order *DailyAssetPriceOrder) DailyAssetPricePaginateOption {
	if order == nil {
		order = DefaultDailyAssetPriceOrder
	}
	o := *order
	return func(pager *dailyassetpricePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDailyAssetPriceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDailyAssetPriceFilter configures pagination filter.
func WithDailyAssetPriceFilter(filter func(*DailyAssetPriceQuery) (*DailyAssetPriceQuery, error)) DailyAssetPricePaginateOption {
	return func(pager *dailyassetpricePager) error {
		if filter == nil {
			return errors.New("DailyAssetPriceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dailyassetpricePager struct {
	order  *DailyAssetPriceOrder
	filter func(*DailyAssetPriceQuery) (*DailyAssetPriceQuery, error)
}

func newDailyAssetPricePager(opts []DailyAssetPricePaginateOption) (*dailyassetpricePager, error) {
	pager := &dailyassetpricePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDailyAssetPriceOrder
	}
	return pager, nil
}

func (p *dailyassetpricePager) applyFilter(query *DailyAssetPriceQuery) (*DailyAssetPriceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dailyassetpricePager) toCursor(dap *DailyAssetPrice) Cursor {
	return p.order.Field.toCursor(dap)
}

func (p *dailyassetpricePager) applyCursors(query *DailyAssetPriceQuery, after, before *Cursor) *DailyAssetPriceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDailyAssetPriceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *dailyassetpricePager) applyOrder(query *DailyAssetPriceQuery, reverse bool) *DailyAssetPriceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDailyAssetPriceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDailyAssetPriceOrder.Field.field))
	}
	return query
}

func (p *dailyassetpricePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDailyAssetPriceOrder.Field {
			b.Comma().Ident(DefaultDailyAssetPriceOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DailyAssetPrice.
func (dap *DailyAssetPriceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DailyAssetPricePaginateOption,
) (*DailyAssetPriceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDailyAssetPricePager(opts)
	if err != nil {
		return nil, err
	}
	if dap, err = pager.applyFilter(dap); err != nil {
		return nil, err
	}
	conn := &DailyAssetPriceConnection{Edges: []*DailyAssetPriceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = dap.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	dap = pager.applyCursors(dap, after, before)
	dap = pager.applyOrder(dap, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		dap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := dap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DailyAssetPriceOrderField defines the ordering field of DailyAssetPrice.
type DailyAssetPriceOrderField struct {
	field    string
	toCursor func(*DailyAssetPrice) Cursor
}

// DailyAssetPriceOrder defines the ordering of DailyAssetPrice.
type DailyAssetPriceOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *DailyAssetPriceOrderField `json:"field"`
}

// DefaultDailyAssetPriceOrder is the default ordering of DailyAssetPrice.
var DefaultDailyAssetPriceOrder = &DailyAssetPriceOrder{
	Direction: OrderDirectionAsc,
	Field: &DailyAssetPriceOrderField{
		field: dailyassetprice.FieldID,
		toCursor: func(dap *DailyAssetPrice) Cursor {
			return Cursor{ID: dap.ID}
		},
	},
}

// ToEdge converts DailyAssetPrice into DailyAssetPriceEdge.
func (dap *DailyAssetPrice) ToEdge(order *DailyAssetPriceOrder) *DailyAssetPriceEdge {
	if order == nil {
		order = DefaultDailyAssetPriceOrder
	}
	return &DailyAssetPriceEdge{
		Node:   dap,
		Cursor: order.Field.toCursor(dap),
	}
}

// ExchangeEdge is the edge representation of Exchange.
type ExchangeEdge struct {
	Node   *Exchange `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ExchangeConnection is the connection containing edges to Exchange.
type ExchangeConnection struct {
	Edges      []*ExchangeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ExchangeConnection) build(nodes []*Exchange, pager *exchangePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Exchange
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Exchange {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Exchange {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExchangeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExchangeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExchangePaginateOption enables pagination customization.
type ExchangePaginateOption func(*exchangePager) error

// WithExchangeOrder configures pagination ordering.
func WithExchangeOrder(order *ExchangeOrder) ExchangePaginateOption {
	if order == nil {
		order = DefaultExchangeOrder
	}
	o := *order
	return func(pager *exchangePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExchangeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExchangeFilter configures pagination filter.
func WithExchangeFilter(filter func(*ExchangeQuery) (*ExchangeQuery, error)) ExchangePaginateOption {
	return func(pager *exchangePager) error {
		if filter == nil {
			return errors.New("ExchangeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exchangePager struct {
	order  *ExchangeOrder
	filter func(*ExchangeQuery) (*ExchangeQuery, error)
}

func newExchangePager(opts []ExchangePaginateOption) (*exchangePager, error) {
	pager := &exchangePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExchangeOrder
	}
	return pager, nil
}

func (p *exchangePager) applyFilter(query *ExchangeQuery) (*ExchangeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exchangePager) toCursor(e *Exchange) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *exchangePager) applyCursors(query *ExchangeQuery, after, before *Cursor) *ExchangeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultExchangeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *exchangePager) applyOrder(query *ExchangeQuery, reverse bool) *ExchangeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultExchangeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultExchangeOrder.Field.field))
	}
	return query
}

func (p *exchangePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExchangeOrder.Field {
			b.Comma().Ident(DefaultExchangeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Exchange.
func (e *ExchangeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExchangePaginateOption,
) (*ExchangeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExchangePager(opts)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &ExchangeConnection{Edges: []*ExchangeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ExchangeOrderField defines the ordering field of Exchange.
type ExchangeOrderField struct {
	field    string
	toCursor func(*Exchange) Cursor
}

// ExchangeOrder defines the ordering of Exchange.
type ExchangeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ExchangeOrderField `json:"field"`
}

// DefaultExchangeOrder is the default ordering of Exchange.
var DefaultExchangeOrder = &ExchangeOrder{
	Direction: OrderDirectionAsc,
	Field: &ExchangeOrderField{
		field: exchange.FieldID,
		toCursor: func(e *Exchange) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Exchange into ExchangeEdge.
func (e *Exchange) ToEdge(order *ExchangeOrder) *ExchangeEdge {
	if order == nil {
		order = DefaultExchangeOrder
	}
	return &ExchangeEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// PortfolioEdge is the edge representation of Portfolio.
type PortfolioEdge struct {
	Node   *Portfolio `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PortfolioConnection is the connection containing edges to Portfolio.
type PortfolioConnection struct {
	Edges      []*PortfolioEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PortfolioConnection) build(nodes []*Portfolio, pager *portfolioPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Portfolio
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Portfolio {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Portfolio {
			return nodes[i]
		}
	}
	c.Edges = make([]*PortfolioEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PortfolioEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PortfolioPaginateOption enables pagination customization.
type PortfolioPaginateOption func(*portfolioPager) error

// WithPortfolioOrder configures pagination ordering.
func WithPortfolioOrder(order *PortfolioOrder) PortfolioPaginateOption {
	if order == nil {
		order = DefaultPortfolioOrder
	}
	o := *order
	return func(pager *portfolioPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPortfolioOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPortfolioFilter configures pagination filter.
func WithPortfolioFilter(filter func(*PortfolioQuery) (*PortfolioQuery, error)) PortfolioPaginateOption {
	return func(pager *portfolioPager) error {
		if filter == nil {
			return errors.New("PortfolioQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type portfolioPager struct {
	order  *PortfolioOrder
	filter func(*PortfolioQuery) (*PortfolioQuery, error)
}

func newPortfolioPager(opts []PortfolioPaginateOption) (*portfolioPager, error) {
	pager := &portfolioPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPortfolioOrder
	}
	return pager, nil
}

func (p *portfolioPager) applyFilter(query *PortfolioQuery) (*PortfolioQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *portfolioPager) toCursor(po *Portfolio) Cursor {
	return p.order.Field.toCursor(po)
}

func (p *portfolioPager) applyCursors(query *PortfolioQuery, after, before *Cursor) *PortfolioQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPortfolioOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *portfolioPager) applyOrder(query *PortfolioQuery, reverse bool) *PortfolioQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPortfolioOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPortfolioOrder.Field.field))
	}
	return query
}

func (p *portfolioPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPortfolioOrder.Field {
			b.Comma().Ident(DefaultPortfolioOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Portfolio.
func (po *PortfolioQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PortfolioPaginateOption,
) (*PortfolioConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPortfolioPager(opts)
	if err != nil {
		return nil, err
	}
	if po, err = pager.applyFilter(po); err != nil {
		return nil, err
	}
	conn := &PortfolioConnection{Edges: []*PortfolioEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = po.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	po = pager.applyCursors(po, after, before)
	po = pager.applyOrder(po, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		po.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := po.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := po.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PortfolioOrderField defines the ordering field of Portfolio.
type PortfolioOrderField struct {
	field    string
	toCursor func(*Portfolio) Cursor
}

// PortfolioOrder defines the ordering of Portfolio.
type PortfolioOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PortfolioOrderField `json:"field"`
}

// DefaultPortfolioOrder is the default ordering of Portfolio.
var DefaultPortfolioOrder = &PortfolioOrder{
	Direction: OrderDirectionAsc,
	Field: &PortfolioOrderField{
		field: portfolio.FieldID,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{ID: po.ID}
		},
	},
}

// ToEdge converts Portfolio into PortfolioEdge.
func (po *Portfolio) ToEdge(order *PortfolioOrder) *PortfolioEdge {
	if order == nil {
		order = DefaultPortfolioOrder
	}
	return &PortfolioEdge{
		Node:   po,
		Cursor: order.Field.toCursor(po),
	}
}

// TransactionEdge is the edge representation of Transaction.
type TransactionEdge struct {
	Node   *Transaction `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TransactionConnection is the connection containing edges to Transaction.
type TransactionConnection struct {
	Edges      []*TransactionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TransactionConnection) build(nodes []*Transaction, pager *transactionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Transaction
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Transaction {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Transaction {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionPaginateOption enables pagination customization.
type TransactionPaginateOption func(*transactionPager) error

// WithTransactionOrder configures pagination ordering.
func WithTransactionOrder(order *TransactionOrder) TransactionPaginateOption {
	if order == nil {
		order = DefaultTransactionOrder
	}
	o := *order
	return func(pager *transactionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionFilter configures pagination filter.
func WithTransactionFilter(filter func(*TransactionQuery) (*TransactionQuery, error)) TransactionPaginateOption {
	return func(pager *transactionPager) error {
		if filter == nil {
			return errors.New("TransactionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactionPager struct {
	order  *TransactionOrder
	filter func(*TransactionQuery) (*TransactionQuery, error)
}

func newTransactionPager(opts []TransactionPaginateOption) (*transactionPager, error) {
	pager := &transactionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionOrder
	}
	return pager, nil
}

func (p *transactionPager) applyFilter(query *TransactionQuery) (*TransactionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactionPager) toCursor(t *Transaction) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *transactionPager) applyCursors(query *TransactionQuery, after, before *Cursor) *TransactionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactionPager) applyOrder(query *TransactionQuery, reverse bool) *TransactionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionOrder.Field.field))
	}
	return query
}

func (p *transactionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionOrder.Field {
			b.Comma().Ident(DefaultTransactionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Transaction.
func (t *TransactionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionPaginateOption,
) (*TransactionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionPager(opts)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TransactionConnection{Edges: []*TransactionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TransactionOrderField defines the ordering field of Transaction.
type TransactionOrderField struct {
	field    string
	toCursor func(*Transaction) Cursor
}

// TransactionOrder defines the ordering of Transaction.
type TransactionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TransactionOrderField `json:"field"`
}

// DefaultTransactionOrder is the default ordering of Transaction.
var DefaultTransactionOrder = &TransactionOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionOrderField{
		field: transaction.FieldID,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Transaction into TransactionEdge.
func (t *Transaction) ToEdge(order *TransactionOrder) *TransactionEdge {
	if order == nil {
		order = DefaultTransactionOrder
	}
	return &TransactionEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TransactionTypeEdge is the edge representation of TransactionType.
type TransactionTypeEdge struct {
	Node   *TransactionType `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TransactionTypeConnection is the connection containing edges to TransactionType.
type TransactionTypeConnection struct {
	Edges      []*TransactionTypeEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TransactionTypeConnection) build(nodes []*TransactionType, pager *transactiontypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TransactionType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TransactionType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TransactionType {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionTypePaginateOption enables pagination customization.
type TransactionTypePaginateOption func(*transactiontypePager) error

// WithTransactionTypeOrder configures pagination ordering.
func WithTransactionTypeOrder(order *TransactionTypeOrder) TransactionTypePaginateOption {
	if order == nil {
		order = DefaultTransactionTypeOrder
	}
	o := *order
	return func(pager *transactiontypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionTypeFilter configures pagination filter.
func WithTransactionTypeFilter(filter func(*TransactionTypeQuery) (*TransactionTypeQuery, error)) TransactionTypePaginateOption {
	return func(pager *transactiontypePager) error {
		if filter == nil {
			return errors.New("TransactionTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactiontypePager struct {
	order  *TransactionTypeOrder
	filter func(*TransactionTypeQuery) (*TransactionTypeQuery, error)
}

func newTransactionTypePager(opts []TransactionTypePaginateOption) (*transactiontypePager, error) {
	pager := &transactiontypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionTypeOrder
	}
	return pager, nil
}

func (p *transactiontypePager) applyFilter(query *TransactionTypeQuery) (*TransactionTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactiontypePager) toCursor(tt *TransactionType) Cursor {
	return p.order.Field.toCursor(tt)
}

func (p *transactiontypePager) applyCursors(query *TransactionTypeQuery, after, before *Cursor) *TransactionTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactiontypePager) applyOrder(query *TransactionTypeQuery, reverse bool) *TransactionTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionTypeOrder.Field.field))
	}
	return query
}

func (p *transactiontypePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionTypeOrder.Field {
			b.Comma().Ident(DefaultTransactionTypeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TransactionType.
func (tt *TransactionTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionTypePaginateOption,
) (*TransactionTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionTypePager(opts)
	if err != nil {
		return nil, err
	}
	if tt, err = pager.applyFilter(tt); err != nil {
		return nil, err
	}
	conn := &TransactionTypeConnection{Edges: []*TransactionTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = tt.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	tt = pager.applyCursors(tt, after, before)
	tt = pager.applyOrder(tt, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		tt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := tt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TransactionTypeOrderFieldTransactionType orders TransactionType by transaction_type.
	TransactionTypeOrderFieldTransactionType = &TransactionTypeOrderField{
		field: transactiontype.FieldTransactionType,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.TransactionType,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TransactionTypeOrderField) String() string {
	var str string
	switch f.field {
	case transactiontype.FieldTransactionType:
		str = "TRANSACTION_TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TransactionTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TransactionTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TransactionTypeOrderField %T must be a string", v)
	}
	switch str {
	case "TRANSACTION_TYPE":
		*f = *TransactionTypeOrderFieldTransactionType
	default:
		return fmt.Errorf("%s is not a valid TransactionTypeOrderField", str)
	}
	return nil
}

// TransactionTypeOrderField defines the ordering field of TransactionType.
type TransactionTypeOrderField struct {
	field    string
	toCursor func(*TransactionType) Cursor
}

// TransactionTypeOrder defines the ordering of TransactionType.
type TransactionTypeOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TransactionTypeOrderField `json:"field"`
}

// DefaultTransactionTypeOrder is the default ordering of TransactionType.
var DefaultTransactionTypeOrder = &TransactionTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionTypeOrderField{
		field: transactiontype.FieldID,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{ID: tt.ID}
		},
	},
}

// ToEdge converts TransactionType into TransactionTypeEdge.
func (tt *TransactionType) ToEdge(order *TransactionTypeOrder) *TransactionTypeEdge {
	if order == nil {
		order = DefaultTransactionTypeOrder
	}
	return &TransactionTypeEdge{
		Node:   tt,
		Cursor: order.Field.toCursor(tt),
	}
}
