// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/authtype"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/connection"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/source"
	"github.com/chenningg/hermitboard-api/ent/sourcetype"
	"github.com/chenningg/hermitboard-api/ent/staffaccount"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"
	"github.com/chenningg/hermitboard-api/pulid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    pulid.PULID `msgpack:"i"`
	Value Value       `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccountEdge is the edge representation of Account.
type AccountEdge struct {
	Node   *Account `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AccountConnection is the connection containing edges to Account.
type AccountConnection struct {
	Edges      []*AccountEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *AccountConnection) build(nodes []*Account, pager *accountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Account
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Account {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Account {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountPaginateOption enables pagination customization.
type AccountPaginateOption func(*accountPager) error

// WithAccountOrder configures pagination ordering.
func WithAccountOrder(order *AccountOrder) AccountPaginateOption {
	if order == nil {
		order = DefaultAccountOrder
	}
	o := *order
	return func(pager *accountPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountFilter configures pagination filter.
func WithAccountFilter(filter func(*AccountQuery) (*AccountQuery, error)) AccountPaginateOption {
	return func(pager *accountPager) error {
		if filter == nil {
			return errors.New("AccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountPager struct {
	order  *AccountOrder
	filter func(*AccountQuery) (*AccountQuery, error)
}

func newAccountPager(opts []AccountPaginateOption) (*accountPager, error) {
	pager := &accountPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountOrder
	}
	return pager, nil
}

func (p *accountPager) applyFilter(query *AccountQuery) (*AccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountPager) toCursor(a *Account) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *accountPager) applyCursors(query *AccountQuery, after, before *Cursor) *AccountQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAccountOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *accountPager) applyOrder(query *AccountQuery, reverse bool) *AccountQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAccountOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAccountOrder.Field.field))
	}
	return query
}

func (p *accountPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountOrder.Field {
			b.Comma().Ident(DefaultAccountOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Account.
func (a *AccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountPaginateOption,
) (*AccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AccountConnection{Edges: []*AccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AccountOrderFieldCreatedAt orders Account by created_at.
	AccountOrderFieldCreatedAt = &AccountOrderField{
		field: account.FieldCreatedAt,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// AccountOrderFieldUpdatedAt orders Account by updated_at.
	AccountOrderFieldUpdatedAt = &AccountOrderField{
		field: account.FieldUpdatedAt,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// AccountOrderFieldDeletedAt orders Account by deleted_at.
	AccountOrderFieldDeletedAt = &AccountOrderField{
		field: account.FieldDeletedAt,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DeletedAt,
			}
		},
	}
	// AccountOrderFieldNickname orders Account by nickname.
	AccountOrderFieldNickname = &AccountOrderField{
		field: account.FieldNickname,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Nickname,
			}
		},
	}
	// AccountOrderFieldEmail orders Account by email.
	AccountOrderFieldEmail = &AccountOrderField{
		field: account.FieldEmail,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Email,
			}
		},
	}
	// AccountOrderFieldPasswordUpdatedAt orders Account by password_updated_at.
	AccountOrderFieldPasswordUpdatedAt = &AccountOrderField{
		field: account.FieldPasswordUpdatedAt,
		toCursor: func(a *Account) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.PasswordUpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AccountOrderField) String() string {
	var str string
	switch f.field {
	case account.FieldCreatedAt:
		str = "CREATED_AT"
	case account.FieldUpdatedAt:
		str = "UPDATED_AT"
	case account.FieldDeletedAt:
		str = "DELETED_AT"
	case account.FieldNickname:
		str = "NICKNAME"
	case account.FieldEmail:
		str = "EMAIL"
	case account.FieldPasswordUpdatedAt:
		str = "PASSWORD_UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AccountOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AccountOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AccountOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *AccountOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *AccountOrderFieldDeletedAt
	case "NICKNAME":
		*f = *AccountOrderFieldNickname
	case "EMAIL":
		*f = *AccountOrderFieldEmail
	case "PASSWORD_UPDATED_AT":
		*f = *AccountOrderFieldPasswordUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid AccountOrderField", str)
	}
	return nil
}

// AccountOrderField defines the ordering field of Account.
type AccountOrderField struct {
	field    string
	toCursor func(*Account) Cursor
}

// AccountOrder defines the ordering of Account.
type AccountOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AccountOrderField `json:"field"`
}

// DefaultAccountOrder is the default ordering of Account.
var DefaultAccountOrder = &AccountOrder{
	Direction: OrderDirectionAsc,
	Field: &AccountOrderField{
		field: account.FieldID,
		toCursor: func(a *Account) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Account into AccountEdge.
func (a *Account) ToEdge(order *AccountOrder) *AccountEdge {
	if order == nil {
		order = DefaultAccountOrder
	}
	return &AccountEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AssetEdge is the edge representation of Asset.
type AssetEdge struct {
	Node   *Asset `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AssetConnection is the connection containing edges to Asset.
type AssetConnection struct {
	Edges      []*AssetEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AssetConnection) build(nodes []*Asset, pager *assetPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Asset
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Asset {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Asset {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetPaginateOption enables pagination customization.
type AssetPaginateOption func(*assetPager) error

// WithAssetOrder configures pagination ordering.
func WithAssetOrder(order *AssetOrder) AssetPaginateOption {
	if order == nil {
		order = DefaultAssetOrder
	}
	o := *order
	return func(pager *assetPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetFilter configures pagination filter.
func WithAssetFilter(filter func(*AssetQuery) (*AssetQuery, error)) AssetPaginateOption {
	return func(pager *assetPager) error {
		if filter == nil {
			return errors.New("AssetQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetPager struct {
	order  *AssetOrder
	filter func(*AssetQuery) (*AssetQuery, error)
}

func newAssetPager(opts []AssetPaginateOption) (*assetPager, error) {
	pager := &assetPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetOrder
	}
	return pager, nil
}

func (p *assetPager) applyFilter(query *AssetQuery) (*AssetQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetPager) toCursor(a *Asset) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *assetPager) applyCursors(query *AssetQuery, after, before *Cursor) *AssetQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAssetOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *assetPager) applyOrder(query *AssetQuery, reverse bool) *AssetQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAssetOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAssetOrder.Field.field))
	}
	return query
}

func (p *assetPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetOrder.Field {
			b.Comma().Ident(DefaultAssetOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Asset.
func (a *AssetQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetPaginateOption,
) (*AssetConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AssetConnection{Edges: []*AssetEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetOrderFieldCreatedAt orders Asset by created_at.
	AssetOrderFieldCreatedAt = &AssetOrderField{
		field: asset.FieldCreatedAt,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// AssetOrderFieldUpdatedAt orders Asset by updated_at.
	AssetOrderFieldUpdatedAt = &AssetOrderField{
		field: asset.FieldUpdatedAt,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// AssetOrderFieldDeletedAt orders Asset by deleted_at.
	AssetOrderFieldDeletedAt = &AssetOrderField{
		field: asset.FieldDeletedAt,
		toCursor: func(a *Asset) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetOrderField) String() string {
	var str string
	switch f.field {
	case asset.FieldCreatedAt:
		str = "CREATED_AT"
	case asset.FieldUpdatedAt:
		str = "UPDATED_AT"
	case asset.FieldDeletedAt:
		str = "DELETED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AssetOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *AssetOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *AssetOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid AssetOrderField", str)
	}
	return nil
}

// AssetOrderField defines the ordering field of Asset.
type AssetOrderField struct {
	field    string
	toCursor func(*Asset) Cursor
}

// AssetOrder defines the ordering of Asset.
type AssetOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AssetOrderField `json:"field"`
}

// DefaultAssetOrder is the default ordering of Asset.
var DefaultAssetOrder = &AssetOrder{
	Direction: OrderDirectionAsc,
	Field: &AssetOrderField{
		field: asset.FieldID,
		toCursor: func(a *Asset) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Asset into AssetEdge.
func (a *Asset) ToEdge(order *AssetOrder) *AssetEdge {
	if order == nil {
		order = DefaultAssetOrder
	}
	return &AssetEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AssetClassEdge is the edge representation of AssetClass.
type AssetClassEdge struct {
	Node   *AssetClass `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AssetClassConnection is the connection containing edges to AssetClass.
type AssetClassConnection struct {
	Edges      []*AssetClassEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AssetClassConnection) build(nodes []*AssetClass, pager *assetclassPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AssetClass
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AssetClass {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AssetClass {
			return nodes[i]
		}
	}
	c.Edges = make([]*AssetClassEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AssetClassEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AssetClassPaginateOption enables pagination customization.
type AssetClassPaginateOption func(*assetclassPager) error

// WithAssetClassOrder configures pagination ordering.
func WithAssetClassOrder(order *AssetClassOrder) AssetClassPaginateOption {
	if order == nil {
		order = DefaultAssetClassOrder
	}
	o := *order
	return func(pager *assetclassPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAssetClassOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAssetClassFilter configures pagination filter.
func WithAssetClassFilter(filter func(*AssetClassQuery) (*AssetClassQuery, error)) AssetClassPaginateOption {
	return func(pager *assetclassPager) error {
		if filter == nil {
			return errors.New("AssetClassQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type assetclassPager struct {
	order  *AssetClassOrder
	filter func(*AssetClassQuery) (*AssetClassQuery, error)
}

func newAssetClassPager(opts []AssetClassPaginateOption) (*assetclassPager, error) {
	pager := &assetclassPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAssetClassOrder
	}
	return pager, nil
}

func (p *assetclassPager) applyFilter(query *AssetClassQuery) (*AssetClassQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *assetclassPager) toCursor(ac *AssetClass) Cursor {
	return p.order.Field.toCursor(ac)
}

func (p *assetclassPager) applyCursors(query *AssetClassQuery, after, before *Cursor) *AssetClassQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAssetClassOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *assetclassPager) applyOrder(query *AssetClassQuery, reverse bool) *AssetClassQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAssetClassOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAssetClassOrder.Field.field))
	}
	return query
}

func (p *assetclassPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAssetClassOrder.Field {
			b.Comma().Ident(DefaultAssetClassOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AssetClass.
func (ac *AssetClassQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AssetClassPaginateOption,
) (*AssetClassConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAssetClassPager(opts)
	if err != nil {
		return nil, err
	}
	if ac, err = pager.applyFilter(ac); err != nil {
		return nil, err
	}
	conn := &AssetClassConnection{Edges: []*AssetClassEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ac.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ac = pager.applyCursors(ac, after, before)
	ac = pager.applyOrder(ac, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ac.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ac.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ac.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AssetClassOrderFieldCreatedAt orders AssetClass by created_at.
	AssetClassOrderFieldCreatedAt = &AssetClassOrderField{
		field: assetclass.FieldCreatedAt,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{
				ID:    ac.ID,
				Value: ac.CreatedAt,
			}
		},
	}
	// AssetClassOrderFieldUpdatedAt orders AssetClass by updated_at.
	AssetClassOrderFieldUpdatedAt = &AssetClassOrderField{
		field: assetclass.FieldUpdatedAt,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{
				ID:    ac.ID,
				Value: ac.UpdatedAt,
			}
		},
	}
	// AssetClassOrderFieldDeletedAt orders AssetClass by deleted_at.
	AssetClassOrderFieldDeletedAt = &AssetClassOrderField{
		field: assetclass.FieldDeletedAt,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{
				ID:    ac.ID,
				Value: ac.DeletedAt,
			}
		},
	}
	// AssetClassOrderFieldValue orders AssetClass by value.
	AssetClassOrderFieldValue = &AssetClassOrderField{
		field: assetclass.FieldValue,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{
				ID:    ac.ID,
				Value: ac.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AssetClassOrderField) String() string {
	var str string
	switch f.field {
	case assetclass.FieldCreatedAt:
		str = "CREATED_AT"
	case assetclass.FieldUpdatedAt:
		str = "UPDATED_AT"
	case assetclass.FieldDeletedAt:
		str = "DELETED_AT"
	case assetclass.FieldValue:
		str = "ASSET_CLASS_VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AssetClassOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AssetClassOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AssetClassOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AssetClassOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *AssetClassOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *AssetClassOrderFieldDeletedAt
	case "ASSET_CLASS_VALUE":
		*f = *AssetClassOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid AssetClassOrderField", str)
	}
	return nil
}

// AssetClassOrderField defines the ordering field of AssetClass.
type AssetClassOrderField struct {
	field    string
	toCursor func(*AssetClass) Cursor
}

// AssetClassOrder defines the ordering of AssetClass.
type AssetClassOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AssetClassOrderField `json:"field"`
}

// DefaultAssetClassOrder is the default ordering of AssetClass.
var DefaultAssetClassOrder = &AssetClassOrder{
	Direction: OrderDirectionAsc,
	Field: &AssetClassOrderField{
		field: assetclass.FieldID,
		toCursor: func(ac *AssetClass) Cursor {
			return Cursor{ID: ac.ID}
		},
	},
}

// ToEdge converts AssetClass into AssetClassEdge.
func (ac *AssetClass) ToEdge(order *AssetClassOrder) *AssetClassEdge {
	if order == nil {
		order = DefaultAssetClassOrder
	}
	return &AssetClassEdge{
		Node:   ac,
		Cursor: order.Field.toCursor(ac),
	}
}

// AuthRoleEdge is the edge representation of AuthRole.
type AuthRoleEdge struct {
	Node   *AuthRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuthRoleConnection is the connection containing edges to AuthRole.
type AuthRoleConnection struct {
	Edges      []*AuthRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuthRoleConnection) build(nodes []*AuthRole, pager *authrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuthRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuthRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuthRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuthRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuthRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuthRolePaginateOption enables pagination customization.
type AuthRolePaginateOption func(*authrolePager) error

// WithAuthRoleOrder configures pagination ordering.
func WithAuthRoleOrder(order *AuthRoleOrder) AuthRolePaginateOption {
	if order == nil {
		order = DefaultAuthRoleOrder
	}
	o := *order
	return func(pager *authrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthRoleFilter configures pagination filter.
func WithAuthRoleFilter(filter func(*AuthRoleQuery) (*AuthRoleQuery, error)) AuthRolePaginateOption {
	return func(pager *authrolePager) error {
		if filter == nil {
			return errors.New("AuthRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authrolePager struct {
	order  *AuthRoleOrder
	filter func(*AuthRoleQuery) (*AuthRoleQuery, error)
}

func newAuthRolePager(opts []AuthRolePaginateOption) (*authrolePager, error) {
	pager := &authrolePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthRoleOrder
	}
	return pager, nil
}

func (p *authrolePager) applyFilter(query *AuthRoleQuery) (*AuthRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authrolePager) toCursor(ar *AuthRole) Cursor {
	return p.order.Field.toCursor(ar)
}

func (p *authrolePager) applyCursors(query *AuthRoleQuery, after, before *Cursor) *AuthRoleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAuthRoleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *authrolePager) applyOrder(query *AuthRoleQuery, reverse bool) *AuthRoleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAuthRoleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAuthRoleOrder.Field.field))
	}
	return query
}

func (p *authrolePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuthRoleOrder.Field {
			b.Comma().Ident(DefaultAuthRoleOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuthRole.
func (ar *AuthRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthRolePaginateOption,
) (*AuthRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthRolePager(opts)
	if err != nil {
		return nil, err
	}
	if ar, err = pager.applyFilter(ar); err != nil {
		return nil, err
	}
	conn := &AuthRoleConnection{Edges: []*AuthRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ar.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ar = pager.applyCursors(ar, after, before)
	ar = pager.applyOrder(ar, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ar.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuthRoleOrderFieldCreatedAt orders AuthRole by created_at.
	AuthRoleOrderFieldCreatedAt = &AuthRoleOrderField{
		field: authrole.FieldCreatedAt,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.CreatedAt,
			}
		},
	}
	// AuthRoleOrderFieldUpdatedAt orders AuthRole by updated_at.
	AuthRoleOrderFieldUpdatedAt = &AuthRoleOrderField{
		field: authrole.FieldUpdatedAt,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.UpdatedAt,
			}
		},
	}
	// AuthRoleOrderFieldDeletedAt orders AuthRole by deleted_at.
	AuthRoleOrderFieldDeletedAt = &AuthRoleOrderField{
		field: authrole.FieldDeletedAt,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.DeletedAt,
			}
		},
	}
	// AuthRoleOrderFieldValue orders AuthRole by value.
	AuthRoleOrderFieldValue = &AuthRoleOrderField{
		field: authrole.FieldValue,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{
				ID:    ar.ID,
				Value: ar.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuthRoleOrderField) String() string {
	var str string
	switch f.field {
	case authrole.FieldCreatedAt:
		str = "CREATED_AT"
	case authrole.FieldUpdatedAt:
		str = "UPDATED_AT"
	case authrole.FieldDeletedAt:
		str = "DELETED_AT"
	case authrole.FieldValue:
		str = "AUTH_ROLE_VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuthRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuthRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuthRoleOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AuthRoleOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *AuthRoleOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *AuthRoleOrderFieldDeletedAt
	case "AUTH_ROLE_VALUE":
		*f = *AuthRoleOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid AuthRoleOrderField", str)
	}
	return nil
}

// AuthRoleOrderField defines the ordering field of AuthRole.
type AuthRoleOrderField struct {
	field    string
	toCursor func(*AuthRole) Cursor
}

// AuthRoleOrder defines the ordering of AuthRole.
type AuthRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuthRoleOrderField `json:"field"`
}

// DefaultAuthRoleOrder is the default ordering of AuthRole.
var DefaultAuthRoleOrder = &AuthRoleOrder{
	Direction: OrderDirectionAsc,
	Field: &AuthRoleOrderField{
		field: authrole.FieldID,
		toCursor: func(ar *AuthRole) Cursor {
			return Cursor{ID: ar.ID}
		},
	},
}

// ToEdge converts AuthRole into AuthRoleEdge.
func (ar *AuthRole) ToEdge(order *AuthRoleOrder) *AuthRoleEdge {
	if order == nil {
		order = DefaultAuthRoleOrder
	}
	return &AuthRoleEdge{
		Node:   ar,
		Cursor: order.Field.toCursor(ar),
	}
}

// AuthTypeEdge is the edge representation of AuthType.
type AuthTypeEdge struct {
	Node   *AuthType `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuthTypeConnection is the connection containing edges to AuthType.
type AuthTypeConnection struct {
	Edges      []*AuthTypeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuthTypeConnection) build(nodes []*AuthType, pager *authtypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuthType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuthType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuthType {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuthTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuthTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuthTypePaginateOption enables pagination customization.
type AuthTypePaginateOption func(*authtypePager) error

// WithAuthTypeOrder configures pagination ordering.
func WithAuthTypeOrder(order *AuthTypeOrder) AuthTypePaginateOption {
	if order == nil {
		order = DefaultAuthTypeOrder
	}
	o := *order
	return func(pager *authtypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthTypeFilter configures pagination filter.
func WithAuthTypeFilter(filter func(*AuthTypeQuery) (*AuthTypeQuery, error)) AuthTypePaginateOption {
	return func(pager *authtypePager) error {
		if filter == nil {
			return errors.New("AuthTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authtypePager struct {
	order  *AuthTypeOrder
	filter func(*AuthTypeQuery) (*AuthTypeQuery, error)
}

func newAuthTypePager(opts []AuthTypePaginateOption) (*authtypePager, error) {
	pager := &authtypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthTypeOrder
	}
	return pager, nil
}

func (p *authtypePager) applyFilter(query *AuthTypeQuery) (*AuthTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authtypePager) toCursor(at *AuthType) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *authtypePager) applyCursors(query *AuthTypeQuery, after, before *Cursor) *AuthTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAuthTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *authtypePager) applyOrder(query *AuthTypeQuery, reverse bool) *AuthTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAuthTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAuthTypeOrder.Field.field))
	}
	return query
}

func (p *authtypePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuthTypeOrder.Field {
			b.Comma().Ident(DefaultAuthTypeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuthType.
func (at *AuthTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthTypePaginateOption,
) (*AuthTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthTypePager(opts)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &AuthTypeConnection{Edges: []*AuthTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = at.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	at = pager.applyCursors(at, after, before)
	at = pager.applyOrder(at, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuthTypeOrderFieldCreatedAt orders AuthType by created_at.
	AuthTypeOrderFieldCreatedAt = &AuthTypeOrderField{
		field: authtype.FieldCreatedAt,
		toCursor: func(at *AuthType) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.CreatedAt,
			}
		},
	}
	// AuthTypeOrderFieldUpdatedAt orders AuthType by updated_at.
	AuthTypeOrderFieldUpdatedAt = &AuthTypeOrderField{
		field: authtype.FieldUpdatedAt,
		toCursor: func(at *AuthType) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.UpdatedAt,
			}
		},
	}
	// AuthTypeOrderFieldDeletedAt orders AuthType by deleted_at.
	AuthTypeOrderFieldDeletedAt = &AuthTypeOrderField{
		field: authtype.FieldDeletedAt,
		toCursor: func(at *AuthType) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.DeletedAt,
			}
		},
	}
	// AuthTypeOrderFieldValue orders AuthType by value.
	AuthTypeOrderFieldValue = &AuthTypeOrderField{
		field: authtype.FieldValue,
		toCursor: func(at *AuthType) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuthTypeOrderField) String() string {
	var str string
	switch f.field {
	case authtype.FieldCreatedAt:
		str = "CREATED_AT"
	case authtype.FieldUpdatedAt:
		str = "UPDATED_AT"
	case authtype.FieldDeletedAt:
		str = "DELETED_AT"
	case authtype.FieldValue:
		str = "AUTH_TYPE_VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuthTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuthTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuthTypeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *AuthTypeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *AuthTypeOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *AuthTypeOrderFieldDeletedAt
	case "AUTH_TYPE_VALUE":
		*f = *AuthTypeOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid AuthTypeOrderField", str)
	}
	return nil
}

// AuthTypeOrderField defines the ordering field of AuthType.
type AuthTypeOrderField struct {
	field    string
	toCursor func(*AuthType) Cursor
}

// AuthTypeOrder defines the ordering of AuthType.
type AuthTypeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuthTypeOrderField `json:"field"`
}

// DefaultAuthTypeOrder is the default ordering of AuthType.
var DefaultAuthTypeOrder = &AuthTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &AuthTypeOrderField{
		field: authtype.FieldID,
		toCursor: func(at *AuthType) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts AuthType into AuthTypeEdge.
func (at *AuthType) ToEdge(order *AuthTypeOrder) *AuthTypeEdge {
	if order == nil {
		order = DefaultAuthTypeOrder
	}
	return &AuthTypeEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// BlockchainEdge is the edge representation of Blockchain.
type BlockchainEdge struct {
	Node   *Blockchain `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// BlockchainConnection is the connection containing edges to Blockchain.
type BlockchainConnection struct {
	Edges      []*BlockchainEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *BlockchainConnection) build(nodes []*Blockchain, pager *blockchainPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Blockchain
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Blockchain {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Blockchain {
			return nodes[i]
		}
	}
	c.Edges = make([]*BlockchainEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BlockchainEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BlockchainPaginateOption enables pagination customization.
type BlockchainPaginateOption func(*blockchainPager) error

// WithBlockchainOrder configures pagination ordering.
func WithBlockchainOrder(order *BlockchainOrder) BlockchainPaginateOption {
	if order == nil {
		order = DefaultBlockchainOrder
	}
	o := *order
	return func(pager *blockchainPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBlockchainOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBlockchainFilter configures pagination filter.
func WithBlockchainFilter(filter func(*BlockchainQuery) (*BlockchainQuery, error)) BlockchainPaginateOption {
	return func(pager *blockchainPager) error {
		if filter == nil {
			return errors.New("BlockchainQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type blockchainPager struct {
	order  *BlockchainOrder
	filter func(*BlockchainQuery) (*BlockchainQuery, error)
}

func newBlockchainPager(opts []BlockchainPaginateOption) (*blockchainPager, error) {
	pager := &blockchainPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBlockchainOrder
	}
	return pager, nil
}

func (p *blockchainPager) applyFilter(query *BlockchainQuery) (*BlockchainQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *blockchainPager) toCursor(b *Blockchain) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *blockchainPager) applyCursors(query *BlockchainQuery, after, before *Cursor) *BlockchainQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBlockchainOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *blockchainPager) applyOrder(query *BlockchainQuery, reverse bool) *BlockchainQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBlockchainOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBlockchainOrder.Field.field))
	}
	return query
}

func (p *blockchainPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBlockchainOrder.Field {
			b.Comma().Ident(DefaultBlockchainOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Blockchain.
func (b *BlockchainQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BlockchainPaginateOption,
) (*BlockchainConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBlockchainPager(opts)
	if err != nil {
		return nil, err
	}
	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}
	conn := &BlockchainConnection{Edges: []*BlockchainEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = b.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	b = pager.applyCursors(b, after, before)
	b = pager.applyOrder(b, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		b.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := b.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := b.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BlockchainOrderFieldCreatedAt orders Blockchain by created_at.
	BlockchainOrderFieldCreatedAt = &BlockchainOrderField{
		field: blockchain.FieldCreatedAt,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.CreatedAt,
			}
		},
	}
	// BlockchainOrderFieldUpdatedAt orders Blockchain by updated_at.
	BlockchainOrderFieldUpdatedAt = &BlockchainOrderField{
		field: blockchain.FieldUpdatedAt,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.UpdatedAt,
			}
		},
	}
	// BlockchainOrderFieldDeletedAt orders Blockchain by deleted_at.
	BlockchainOrderFieldDeletedAt = &BlockchainOrderField{
		field: blockchain.FieldDeletedAt,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.DeletedAt,
			}
		},
	}
	// BlockchainOrderFieldName orders Blockchain by name.
	BlockchainOrderFieldName = &BlockchainOrderField{
		field: blockchain.FieldName,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.Name,
			}
		},
	}
	// BlockchainOrderFieldSymbol orders Blockchain by symbol.
	BlockchainOrderFieldSymbol = &BlockchainOrderField{
		field: blockchain.FieldSymbol,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.Symbol,
			}
		},
	}
	// BlockchainOrderFieldChainID orders Blockchain by chain_id.
	BlockchainOrderFieldChainID = &BlockchainOrderField{
		field: blockchain.FieldChainID,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.ChainID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BlockchainOrderField) String() string {
	var str string
	switch f.field {
	case blockchain.FieldCreatedAt:
		str = "CREATED_AT"
	case blockchain.FieldUpdatedAt:
		str = "UPDATED_AT"
	case blockchain.FieldDeletedAt:
		str = "DELETED_AT"
	case blockchain.FieldName:
		str = "NAME"
	case blockchain.FieldSymbol:
		str = "SYMBOL"
	case blockchain.FieldChainID:
		str = "CHAIN_ID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BlockchainOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BlockchainOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BlockchainOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *BlockchainOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *BlockchainOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *BlockchainOrderFieldDeletedAt
	case "NAME":
		*f = *BlockchainOrderFieldName
	case "SYMBOL":
		*f = *BlockchainOrderFieldSymbol
	case "CHAIN_ID":
		*f = *BlockchainOrderFieldChainID
	default:
		return fmt.Errorf("%s is not a valid BlockchainOrderField", str)
	}
	return nil
}

// BlockchainOrderField defines the ordering field of Blockchain.
type BlockchainOrderField struct {
	field    string
	toCursor func(*Blockchain) Cursor
}

// BlockchainOrder defines the ordering of Blockchain.
type BlockchainOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *BlockchainOrderField `json:"field"`
}

// DefaultBlockchainOrder is the default ordering of Blockchain.
var DefaultBlockchainOrder = &BlockchainOrder{
	Direction: OrderDirectionAsc,
	Field: &BlockchainOrderField{
		field: blockchain.FieldID,
		toCursor: func(b *Blockchain) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Blockchain into BlockchainEdge.
func (b *Blockchain) ToEdge(order *BlockchainOrder) *BlockchainEdge {
	if order == nil {
		order = DefaultBlockchainOrder
	}
	return &BlockchainEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// ConnectionEdge is the edge representation of Connection.
type ConnectionEdge struct {
	Node   *Connection `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ConnectionConnection is the connection containing edges to Connection.
type ConnectionConnection struct {
	Edges      []*ConnectionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ConnectionConnection) build(nodes []*Connection, pager *connectionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Connection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Connection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Connection {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectionPaginateOption enables pagination customization.
type ConnectionPaginateOption func(*connectionPager) error

// WithConnectionOrder configures pagination ordering.
func WithConnectionOrder(order *ConnectionOrder) ConnectionPaginateOption {
	if order == nil {
		order = DefaultConnectionOrder
	}
	o := *order
	return func(pager *connectionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectionFilter configures pagination filter.
func WithConnectionFilter(filter func(*ConnectionQuery) (*ConnectionQuery, error)) ConnectionPaginateOption {
	return func(pager *connectionPager) error {
		if filter == nil {
			return errors.New("ConnectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectionPager struct {
	order  *ConnectionOrder
	filter func(*ConnectionQuery) (*ConnectionQuery, error)
}

func newConnectionPager(opts []ConnectionPaginateOption) (*connectionPager, error) {
	pager := &connectionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectionOrder
	}
	return pager, nil
}

func (p *connectionPager) applyFilter(query *ConnectionQuery) (*ConnectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectionPager) toCursor(c *Connection) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *connectionPager) applyCursors(query *ConnectionQuery, after, before *Cursor) *ConnectionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultConnectionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *connectionPager) applyOrder(query *ConnectionQuery, reverse bool) *ConnectionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultConnectionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultConnectionOrder.Field.field))
	}
	return query
}

func (p *connectionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectionOrder.Field {
			b.Comma().Ident(DefaultConnectionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Connection.
func (c *ConnectionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectionPaginateOption,
) (*ConnectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectionPager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ConnectionConnection{Edges: []*ConnectionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ConnectionOrderFieldCreatedAt orders Connection by created_at.
	ConnectionOrderFieldCreatedAt = &ConnectionOrderField{
		field: connection.FieldCreatedAt,
		toCursor: func(c *Connection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// ConnectionOrderFieldUpdatedAt orders Connection by updated_at.
	ConnectionOrderFieldUpdatedAt = &ConnectionOrderField{
		field: connection.FieldUpdatedAt,
		toCursor: func(c *Connection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// ConnectionOrderFieldDeletedAt orders Connection by deleted_at.
	ConnectionOrderFieldDeletedAt = &ConnectionOrderField{
		field: connection.FieldDeletedAt,
		toCursor: func(c *Connection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DeletedAt,
			}
		},
	}
	// ConnectionOrderFieldName orders Connection by name.
	ConnectionOrderFieldName = &ConnectionOrderField{
		field: connection.FieldName,
		toCursor: func(c *Connection) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ConnectionOrderField) String() string {
	var str string
	switch f.field {
	case connection.FieldCreatedAt:
		str = "CREATED_AT"
	case connection.FieldUpdatedAt:
		str = "UPDATED_AT"
	case connection.FieldDeletedAt:
		str = "DELETED_AT"
	case connection.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ConnectionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ConnectionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ConnectionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ConnectionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ConnectionOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *ConnectionOrderFieldDeletedAt
	case "NAME":
		*f = *ConnectionOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ConnectionOrderField", str)
	}
	return nil
}

// ConnectionOrderField defines the ordering field of Connection.
type ConnectionOrderField struct {
	field    string
	toCursor func(*Connection) Cursor
}

// ConnectionOrder defines the ordering of Connection.
type ConnectionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ConnectionOrderField `json:"field"`
}

// DefaultConnectionOrder is the default ordering of Connection.
var DefaultConnectionOrder = &ConnectionOrder{
	Direction: OrderDirectionAsc,
	Field: &ConnectionOrderField{
		field: connection.FieldID,
		toCursor: func(c *Connection) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Connection into ConnectionEdge.
func (c *Connection) ToEdge(order *ConnectionOrder) *ConnectionEdge {
	if order == nil {
		order = DefaultConnectionOrder
	}
	return &ConnectionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CryptocurrencyEdge is the edge representation of Cryptocurrency.
type CryptocurrencyEdge struct {
	Node   *Cryptocurrency `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CryptocurrencyConnection is the connection containing edges to Cryptocurrency.
type CryptocurrencyConnection struct {
	Edges      []*CryptocurrencyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CryptocurrencyConnection) build(nodes []*Cryptocurrency, pager *cryptocurrencyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Cryptocurrency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Cryptocurrency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Cryptocurrency {
			return nodes[i]
		}
	}
	c.Edges = make([]*CryptocurrencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CryptocurrencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CryptocurrencyPaginateOption enables pagination customization.
type CryptocurrencyPaginateOption func(*cryptocurrencyPager) error

// WithCryptocurrencyOrder configures pagination ordering.
func WithCryptocurrencyOrder(order *CryptocurrencyOrder) CryptocurrencyPaginateOption {
	if order == nil {
		order = DefaultCryptocurrencyOrder
	}
	o := *order
	return func(pager *cryptocurrencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCryptocurrencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCryptocurrencyFilter configures pagination filter.
func WithCryptocurrencyFilter(filter func(*CryptocurrencyQuery) (*CryptocurrencyQuery, error)) CryptocurrencyPaginateOption {
	return func(pager *cryptocurrencyPager) error {
		if filter == nil {
			return errors.New("CryptocurrencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type cryptocurrencyPager struct {
	order  *CryptocurrencyOrder
	filter func(*CryptocurrencyQuery) (*CryptocurrencyQuery, error)
}

func newCryptocurrencyPager(opts []CryptocurrencyPaginateOption) (*cryptocurrencyPager, error) {
	pager := &cryptocurrencyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCryptocurrencyOrder
	}
	return pager, nil
}

func (p *cryptocurrencyPager) applyFilter(query *CryptocurrencyQuery) (*CryptocurrencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *cryptocurrencyPager) toCursor(c *Cryptocurrency) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *cryptocurrencyPager) applyCursors(query *CryptocurrencyQuery, after, before *Cursor) *CryptocurrencyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCryptocurrencyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *cryptocurrencyPager) applyOrder(query *CryptocurrencyQuery, reverse bool) *CryptocurrencyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCryptocurrencyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCryptocurrencyOrder.Field.field))
	}
	return query
}

func (p *cryptocurrencyPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCryptocurrencyOrder.Field {
			b.Comma().Ident(DefaultCryptocurrencyOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Cryptocurrency.
func (c *CryptocurrencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CryptocurrencyPaginateOption,
) (*CryptocurrencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCryptocurrencyPager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CryptocurrencyConnection{Edges: []*CryptocurrencyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CryptocurrencyOrderFieldCreatedAt orders Cryptocurrency by created_at.
	CryptocurrencyOrderFieldCreatedAt = &CryptocurrencyOrderField{
		field: cryptocurrency.FieldCreatedAt,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CryptocurrencyOrderFieldUpdatedAt orders Cryptocurrency by updated_at.
	CryptocurrencyOrderFieldUpdatedAt = &CryptocurrencyOrderField{
		field: cryptocurrency.FieldUpdatedAt,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CryptocurrencyOrderFieldDeletedAt orders Cryptocurrency by deleted_at.
	CryptocurrencyOrderFieldDeletedAt = &CryptocurrencyOrderField{
		field: cryptocurrency.FieldDeletedAt,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DeletedAt,
			}
		},
	}
	// CryptocurrencyOrderFieldSymbol orders Cryptocurrency by symbol.
	CryptocurrencyOrderFieldSymbol = &CryptocurrencyOrderField{
		field: cryptocurrency.FieldSymbol,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Symbol,
			}
		},
	}
	// CryptocurrencyOrderFieldName orders Cryptocurrency by name.
	CryptocurrencyOrderFieldName = &CryptocurrencyOrderField{
		field: cryptocurrency.FieldName,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CryptocurrencyOrderField) String() string {
	var str string
	switch f.field {
	case cryptocurrency.FieldCreatedAt:
		str = "CREATED_AT"
	case cryptocurrency.FieldUpdatedAt:
		str = "UPDATED_AT"
	case cryptocurrency.FieldDeletedAt:
		str = "DELETED_AT"
	case cryptocurrency.FieldSymbol:
		str = "SYMBOL"
	case cryptocurrency.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CryptocurrencyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CryptocurrencyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CryptocurrencyOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *CryptocurrencyOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *CryptocurrencyOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *CryptocurrencyOrderFieldDeletedAt
	case "SYMBOL":
		*f = *CryptocurrencyOrderFieldSymbol
	case "NAME":
		*f = *CryptocurrencyOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid CryptocurrencyOrderField", str)
	}
	return nil
}

// CryptocurrencyOrderField defines the ordering field of Cryptocurrency.
type CryptocurrencyOrderField struct {
	field    string
	toCursor func(*Cryptocurrency) Cursor
}

// CryptocurrencyOrder defines the ordering of Cryptocurrency.
type CryptocurrencyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CryptocurrencyOrderField `json:"field"`
}

// DefaultCryptocurrencyOrder is the default ordering of Cryptocurrency.
var DefaultCryptocurrencyOrder = &CryptocurrencyOrder{
	Direction: OrderDirectionAsc,
	Field: &CryptocurrencyOrderField{
		field: cryptocurrency.FieldID,
		toCursor: func(c *Cryptocurrency) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Cryptocurrency into CryptocurrencyEdge.
func (c *Cryptocurrency) ToEdge(order *CryptocurrencyOrder) *CryptocurrencyEdge {
	if order == nil {
		order = DefaultCryptocurrencyOrder
	}
	return &CryptocurrencyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DailyAssetPriceEdge is the edge representation of DailyAssetPrice.
type DailyAssetPriceEdge struct {
	Node   *DailyAssetPrice `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// DailyAssetPriceConnection is the connection containing edges to DailyAssetPrice.
type DailyAssetPriceConnection struct {
	Edges      []*DailyAssetPriceEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *DailyAssetPriceConnection) build(nodes []*DailyAssetPrice, pager *dailyassetpricePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DailyAssetPrice
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DailyAssetPrice {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DailyAssetPrice {
			return nodes[i]
		}
	}
	c.Edges = make([]*DailyAssetPriceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DailyAssetPriceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DailyAssetPricePaginateOption enables pagination customization.
type DailyAssetPricePaginateOption func(*dailyassetpricePager) error

// WithDailyAssetPriceOrder configures pagination ordering.
func WithDailyAssetPriceOrder(order *DailyAssetPriceOrder) DailyAssetPricePaginateOption {
	if order == nil {
		order = DefaultDailyAssetPriceOrder
	}
	o := *order
	return func(pager *dailyassetpricePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDailyAssetPriceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDailyAssetPriceFilter configures pagination filter.
func WithDailyAssetPriceFilter(filter func(*DailyAssetPriceQuery) (*DailyAssetPriceQuery, error)) DailyAssetPricePaginateOption {
	return func(pager *dailyassetpricePager) error {
		if filter == nil {
			return errors.New("DailyAssetPriceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dailyassetpricePager struct {
	order  *DailyAssetPriceOrder
	filter func(*DailyAssetPriceQuery) (*DailyAssetPriceQuery, error)
}

func newDailyAssetPricePager(opts []DailyAssetPricePaginateOption) (*dailyassetpricePager, error) {
	pager := &dailyassetpricePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDailyAssetPriceOrder
	}
	return pager, nil
}

func (p *dailyassetpricePager) applyFilter(query *DailyAssetPriceQuery) (*DailyAssetPriceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dailyassetpricePager) toCursor(dap *DailyAssetPrice) Cursor {
	return p.order.Field.toCursor(dap)
}

func (p *dailyassetpricePager) applyCursors(query *DailyAssetPriceQuery, after, before *Cursor) *DailyAssetPriceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDailyAssetPriceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *dailyassetpricePager) applyOrder(query *DailyAssetPriceQuery, reverse bool) *DailyAssetPriceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDailyAssetPriceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDailyAssetPriceOrder.Field.field))
	}
	return query
}

func (p *dailyassetpricePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDailyAssetPriceOrder.Field {
			b.Comma().Ident(DefaultDailyAssetPriceOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DailyAssetPrice.
func (dap *DailyAssetPriceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DailyAssetPricePaginateOption,
) (*DailyAssetPriceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDailyAssetPricePager(opts)
	if err != nil {
		return nil, err
	}
	if dap, err = pager.applyFilter(dap); err != nil {
		return nil, err
	}
	conn := &DailyAssetPriceConnection{Edges: []*DailyAssetPriceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = dap.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	dap = pager.applyCursors(dap, after, before)
	dap = pager.applyOrder(dap, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		dap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := dap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DailyAssetPriceOrderFieldCreatedAt orders DailyAssetPrice by created_at.
	DailyAssetPriceOrderFieldCreatedAt = &DailyAssetPriceOrderField{
		field: dailyassetprice.FieldCreatedAt,
		toCursor: func(dap *DailyAssetPrice) Cursor {
			return Cursor{
				ID:    dap.ID,
				Value: dap.CreatedAt,
			}
		},
	}
	// DailyAssetPriceOrderFieldUpdatedAt orders DailyAssetPrice by updated_at.
	DailyAssetPriceOrderFieldUpdatedAt = &DailyAssetPriceOrderField{
		field: dailyassetprice.FieldUpdatedAt,
		toCursor: func(dap *DailyAssetPrice) Cursor {
			return Cursor{
				ID:    dap.ID,
				Value: dap.UpdatedAt,
			}
		},
	}
	// DailyAssetPriceOrderFieldDeletedAt orders DailyAssetPrice by deleted_at.
	DailyAssetPriceOrderFieldDeletedAt = &DailyAssetPriceOrderField{
		field: dailyassetprice.FieldDeletedAt,
		toCursor: func(dap *DailyAssetPrice) Cursor {
			return Cursor{
				ID:    dap.ID,
				Value: dap.DeletedAt,
			}
		},
	}
	// DailyAssetPriceOrderFieldTime orders DailyAssetPrice by time.
	DailyAssetPriceOrderFieldTime = &DailyAssetPriceOrderField{
		field: dailyassetprice.FieldTime,
		toCursor: func(dap *DailyAssetPrice) Cursor {
			return Cursor{
				ID:    dap.ID,
				Value: dap.Time,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DailyAssetPriceOrderField) String() string {
	var str string
	switch f.field {
	case dailyassetprice.FieldCreatedAt:
		str = "CREATED_AT"
	case dailyassetprice.FieldUpdatedAt:
		str = "UPDATED_AT"
	case dailyassetprice.FieldDeletedAt:
		str = "DELETED_AT"
	case dailyassetprice.FieldTime:
		str = "TIME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DailyAssetPriceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DailyAssetPriceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DailyAssetPriceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *DailyAssetPriceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *DailyAssetPriceOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *DailyAssetPriceOrderFieldDeletedAt
	case "TIME":
		*f = *DailyAssetPriceOrderFieldTime
	default:
		return fmt.Errorf("%s is not a valid DailyAssetPriceOrderField", str)
	}
	return nil
}

// DailyAssetPriceOrderField defines the ordering field of DailyAssetPrice.
type DailyAssetPriceOrderField struct {
	field    string
	toCursor func(*DailyAssetPrice) Cursor
}

// DailyAssetPriceOrder defines the ordering of DailyAssetPrice.
type DailyAssetPriceOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *DailyAssetPriceOrderField `json:"field"`
}

// DefaultDailyAssetPriceOrder is the default ordering of DailyAssetPrice.
var DefaultDailyAssetPriceOrder = &DailyAssetPriceOrder{
	Direction: OrderDirectionAsc,
	Field: &DailyAssetPriceOrderField{
		field: dailyassetprice.FieldID,
		toCursor: func(dap *DailyAssetPrice) Cursor {
			return Cursor{ID: dap.ID}
		},
	},
}

// ToEdge converts DailyAssetPrice into DailyAssetPriceEdge.
func (dap *DailyAssetPrice) ToEdge(order *DailyAssetPriceOrder) *DailyAssetPriceEdge {
	if order == nil {
		order = DefaultDailyAssetPriceOrder
	}
	return &DailyAssetPriceEdge{
		Node:   dap,
		Cursor: order.Field.toCursor(dap),
	}
}

// ExchangeEdge is the edge representation of Exchange.
type ExchangeEdge struct {
	Node   *Exchange `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ExchangeConnection is the connection containing edges to Exchange.
type ExchangeConnection struct {
	Edges      []*ExchangeEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ExchangeConnection) build(nodes []*Exchange, pager *exchangePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Exchange
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Exchange {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Exchange {
			return nodes[i]
		}
	}
	c.Edges = make([]*ExchangeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ExchangeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ExchangePaginateOption enables pagination customization.
type ExchangePaginateOption func(*exchangePager) error

// WithExchangeOrder configures pagination ordering.
func WithExchangeOrder(order *ExchangeOrder) ExchangePaginateOption {
	if order == nil {
		order = DefaultExchangeOrder
	}
	o := *order
	return func(pager *exchangePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultExchangeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithExchangeFilter configures pagination filter.
func WithExchangeFilter(filter func(*ExchangeQuery) (*ExchangeQuery, error)) ExchangePaginateOption {
	return func(pager *exchangePager) error {
		if filter == nil {
			return errors.New("ExchangeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type exchangePager struct {
	order  *ExchangeOrder
	filter func(*ExchangeQuery) (*ExchangeQuery, error)
}

func newExchangePager(opts []ExchangePaginateOption) (*exchangePager, error) {
	pager := &exchangePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultExchangeOrder
	}
	return pager, nil
}

func (p *exchangePager) applyFilter(query *ExchangeQuery) (*ExchangeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *exchangePager) toCursor(e *Exchange) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *exchangePager) applyCursors(query *ExchangeQuery, after, before *Cursor) *ExchangeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultExchangeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *exchangePager) applyOrder(query *ExchangeQuery, reverse bool) *ExchangeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultExchangeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultExchangeOrder.Field.field))
	}
	return query
}

func (p *exchangePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultExchangeOrder.Field {
			b.Comma().Ident(DefaultExchangeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Exchange.
func (e *ExchangeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ExchangePaginateOption,
) (*ExchangeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newExchangePager(opts)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &ExchangeConnection{Edges: []*ExchangeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ExchangeOrderFieldCreatedAt orders Exchange by created_at.
	ExchangeOrderFieldCreatedAt = &ExchangeOrderField{
		field: exchange.FieldCreatedAt,
		toCursor: func(e *Exchange) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// ExchangeOrderFieldUpdatedAt orders Exchange by updated_at.
	ExchangeOrderFieldUpdatedAt = &ExchangeOrderField{
		field: exchange.FieldUpdatedAt,
		toCursor: func(e *Exchange) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
	// ExchangeOrderFieldDeletedAt orders Exchange by deleted_at.
	ExchangeOrderFieldDeletedAt = &ExchangeOrderField{
		field: exchange.FieldDeletedAt,
		toCursor: func(e *Exchange) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.DeletedAt,
			}
		},
	}
	// ExchangeOrderFieldName orders Exchange by name.
	ExchangeOrderFieldName = &ExchangeOrderField{
		field: exchange.FieldName,
		toCursor: func(e *Exchange) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ExchangeOrderField) String() string {
	var str string
	switch f.field {
	case exchange.FieldCreatedAt:
		str = "CREATED_AT"
	case exchange.FieldUpdatedAt:
		str = "UPDATED_AT"
	case exchange.FieldDeletedAt:
		str = "DELETED_AT"
	case exchange.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ExchangeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ExchangeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ExchangeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ExchangeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *ExchangeOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *ExchangeOrderFieldDeletedAt
	case "NAME":
		*f = *ExchangeOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ExchangeOrderField", str)
	}
	return nil
}

// ExchangeOrderField defines the ordering field of Exchange.
type ExchangeOrderField struct {
	field    string
	toCursor func(*Exchange) Cursor
}

// ExchangeOrder defines the ordering of Exchange.
type ExchangeOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ExchangeOrderField `json:"field"`
}

// DefaultExchangeOrder is the default ordering of Exchange.
var DefaultExchangeOrder = &ExchangeOrder{
	Direction: OrderDirectionAsc,
	Field: &ExchangeOrderField{
		field: exchange.FieldID,
		toCursor: func(e *Exchange) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Exchange into ExchangeEdge.
func (e *Exchange) ToEdge(order *ExchangeOrder) *ExchangeEdge {
	if order == nil {
		order = DefaultExchangeOrder
	}
	return &ExchangeEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// PortfolioEdge is the edge representation of Portfolio.
type PortfolioEdge struct {
	Node   *Portfolio `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PortfolioConnection is the connection containing edges to Portfolio.
type PortfolioConnection struct {
	Edges      []*PortfolioEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PortfolioConnection) build(nodes []*Portfolio, pager *portfolioPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Portfolio
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Portfolio {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Portfolio {
			return nodes[i]
		}
	}
	c.Edges = make([]*PortfolioEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PortfolioEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PortfolioPaginateOption enables pagination customization.
type PortfolioPaginateOption func(*portfolioPager) error

// WithPortfolioOrder configures pagination ordering.
func WithPortfolioOrder(order *PortfolioOrder) PortfolioPaginateOption {
	if order == nil {
		order = DefaultPortfolioOrder
	}
	o := *order
	return func(pager *portfolioPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPortfolioOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPortfolioFilter configures pagination filter.
func WithPortfolioFilter(filter func(*PortfolioQuery) (*PortfolioQuery, error)) PortfolioPaginateOption {
	return func(pager *portfolioPager) error {
		if filter == nil {
			return errors.New("PortfolioQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type portfolioPager struct {
	order  *PortfolioOrder
	filter func(*PortfolioQuery) (*PortfolioQuery, error)
}

func newPortfolioPager(opts []PortfolioPaginateOption) (*portfolioPager, error) {
	pager := &portfolioPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPortfolioOrder
	}
	return pager, nil
}

func (p *portfolioPager) applyFilter(query *PortfolioQuery) (*PortfolioQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *portfolioPager) toCursor(po *Portfolio) Cursor {
	return p.order.Field.toCursor(po)
}

func (p *portfolioPager) applyCursors(query *PortfolioQuery, after, before *Cursor) *PortfolioQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPortfolioOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *portfolioPager) applyOrder(query *PortfolioQuery, reverse bool) *PortfolioQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPortfolioOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPortfolioOrder.Field.field))
	}
	return query
}

func (p *portfolioPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPortfolioOrder.Field {
			b.Comma().Ident(DefaultPortfolioOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Portfolio.
func (po *PortfolioQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PortfolioPaginateOption,
) (*PortfolioConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPortfolioPager(opts)
	if err != nil {
		return nil, err
	}
	if po, err = pager.applyFilter(po); err != nil {
		return nil, err
	}
	conn := &PortfolioConnection{Edges: []*PortfolioEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = po.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	po = pager.applyCursors(po, after, before)
	po = pager.applyOrder(po, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		po.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := po.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := po.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PortfolioOrderFieldCreatedAt orders Portfolio by created_at.
	PortfolioOrderFieldCreatedAt = &PortfolioOrderField{
		field: portfolio.FieldCreatedAt,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.CreatedAt,
			}
		},
	}
	// PortfolioOrderFieldUpdatedAt orders Portfolio by updated_at.
	PortfolioOrderFieldUpdatedAt = &PortfolioOrderField{
		field: portfolio.FieldUpdatedAt,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.UpdatedAt,
			}
		},
	}
	// PortfolioOrderFieldDeletedAt orders Portfolio by deleted_at.
	PortfolioOrderFieldDeletedAt = &PortfolioOrderField{
		field: portfolio.FieldDeletedAt,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.DeletedAt,
			}
		},
	}
	// PortfolioOrderFieldName orders Portfolio by name.
	PortfolioOrderFieldName = &PortfolioOrderField{
		field: portfolio.FieldName,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.Name,
			}
		},
	}
	// PortfolioOrderFieldIsPublic orders Portfolio by is_public.
	PortfolioOrderFieldIsPublic = &PortfolioOrderField{
		field: portfolio.FieldIsPublic,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.IsPublic,
			}
		},
	}
	// PortfolioOrderFieldIsVisible orders Portfolio by is_visible.
	PortfolioOrderFieldIsVisible = &PortfolioOrderField{
		field: portfolio.FieldIsVisible,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{
				ID:    po.ID,
				Value: po.IsVisible,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PortfolioOrderField) String() string {
	var str string
	switch f.field {
	case portfolio.FieldCreatedAt:
		str = "CREATED_AT"
	case portfolio.FieldUpdatedAt:
		str = "UPDATED_AT"
	case portfolio.FieldDeletedAt:
		str = "DELETED_AT"
	case portfolio.FieldName:
		str = "NAME"
	case portfolio.FieldIsPublic:
		str = "IS_PUBLIC"
	case portfolio.FieldIsVisible:
		str = "IS_VISIBLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PortfolioOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PortfolioOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PortfolioOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *PortfolioOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *PortfolioOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *PortfolioOrderFieldDeletedAt
	case "NAME":
		*f = *PortfolioOrderFieldName
	case "IS_PUBLIC":
		*f = *PortfolioOrderFieldIsPublic
	case "IS_VISIBLE":
		*f = *PortfolioOrderFieldIsVisible
	default:
		return fmt.Errorf("%s is not a valid PortfolioOrderField", str)
	}
	return nil
}

// PortfolioOrderField defines the ordering field of Portfolio.
type PortfolioOrderField struct {
	field    string
	toCursor func(*Portfolio) Cursor
}

// PortfolioOrder defines the ordering of Portfolio.
type PortfolioOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PortfolioOrderField `json:"field"`
}

// DefaultPortfolioOrder is the default ordering of Portfolio.
var DefaultPortfolioOrder = &PortfolioOrder{
	Direction: OrderDirectionAsc,
	Field: &PortfolioOrderField{
		field: portfolio.FieldID,
		toCursor: func(po *Portfolio) Cursor {
			return Cursor{ID: po.ID}
		},
	},
}

// ToEdge converts Portfolio into PortfolioEdge.
func (po *Portfolio) ToEdge(order *PortfolioOrder) *PortfolioEdge {
	if order == nil {
		order = DefaultPortfolioOrder
	}
	return &PortfolioEdge{
		Node:   po,
		Cursor: order.Field.toCursor(po),
	}
}

// SourceEdge is the edge representation of Source.
type SourceEdge struct {
	Node   *Source `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SourceConnection is the connection containing edges to Source.
type SourceConnection struct {
	Edges      []*SourceEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *SourceConnection) build(nodes []*Source, pager *sourcePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Source
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Source {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Source {
			return nodes[i]
		}
	}
	c.Edges = make([]*SourceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SourceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SourcePaginateOption enables pagination customization.
type SourcePaginateOption func(*sourcePager) error

// WithSourceOrder configures pagination ordering.
func WithSourceOrder(order *SourceOrder) SourcePaginateOption {
	if order == nil {
		order = DefaultSourceOrder
	}
	o := *order
	return func(pager *sourcePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSourceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSourceFilter configures pagination filter.
func WithSourceFilter(filter func(*SourceQuery) (*SourceQuery, error)) SourcePaginateOption {
	return func(pager *sourcePager) error {
		if filter == nil {
			return errors.New("SourceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sourcePager struct {
	order  *SourceOrder
	filter func(*SourceQuery) (*SourceQuery, error)
}

func newSourcePager(opts []SourcePaginateOption) (*sourcePager, error) {
	pager := &sourcePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSourceOrder
	}
	return pager, nil
}

func (p *sourcePager) applyFilter(query *SourceQuery) (*SourceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sourcePager) toCursor(s *Source) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *sourcePager) applyCursors(query *SourceQuery, after, before *Cursor) *SourceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSourceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sourcePager) applyOrder(query *SourceQuery, reverse bool) *SourceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSourceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSourceOrder.Field.field))
	}
	return query
}

func (p *sourcePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSourceOrder.Field {
			b.Comma().Ident(DefaultSourceOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Source.
func (s *SourceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SourcePaginateOption,
) (*SourceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSourcePager(opts)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SourceConnection{Edges: []*SourceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SourceOrderFieldCreatedAt orders Source by created_at.
	SourceOrderFieldCreatedAt = &SourceOrderField{
		field: source.FieldCreatedAt,
		toCursor: func(s *Source) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SourceOrderFieldUpdatedAt orders Source by updated_at.
	SourceOrderFieldUpdatedAt = &SourceOrderField{
		field: source.FieldUpdatedAt,
		toCursor: func(s *Source) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SourceOrderFieldDeletedAt orders Source by deleted_at.
	SourceOrderFieldDeletedAt = &SourceOrderField{
		field: source.FieldDeletedAt,
		toCursor: func(s *Source) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DeletedAt,
			}
		},
	}
	// SourceOrderFieldName orders Source by name.
	SourceOrderFieldName = &SourceOrderField{
		field: source.FieldName,
		toCursor: func(s *Source) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SourceOrderField) String() string {
	var str string
	switch f.field {
	case source.FieldCreatedAt:
		str = "CREATED_AT"
	case source.FieldUpdatedAt:
		str = "UPDATED_AT"
	case source.FieldDeletedAt:
		str = "DELETED_AT"
	case source.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SourceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SourceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SourceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SourceOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SourceOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *SourceOrderFieldDeletedAt
	case "NAME":
		*f = *SourceOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid SourceOrderField", str)
	}
	return nil
}

// SourceOrderField defines the ordering field of Source.
type SourceOrderField struct {
	field    string
	toCursor func(*Source) Cursor
}

// SourceOrder defines the ordering of Source.
type SourceOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SourceOrderField `json:"field"`
}

// DefaultSourceOrder is the default ordering of Source.
var DefaultSourceOrder = &SourceOrder{
	Direction: OrderDirectionAsc,
	Field: &SourceOrderField{
		field: source.FieldID,
		toCursor: func(s *Source) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Source into SourceEdge.
func (s *Source) ToEdge(order *SourceOrder) *SourceEdge {
	if order == nil {
		order = DefaultSourceOrder
	}
	return &SourceEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SourceTypeEdge is the edge representation of SourceType.
type SourceTypeEdge struct {
	Node   *SourceType `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// SourceTypeConnection is the connection containing edges to SourceType.
type SourceTypeConnection struct {
	Edges      []*SourceTypeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *SourceTypeConnection) build(nodes []*SourceType, pager *sourcetypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SourceType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SourceType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SourceType {
			return nodes[i]
		}
	}
	c.Edges = make([]*SourceTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SourceTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SourceTypePaginateOption enables pagination customization.
type SourceTypePaginateOption func(*sourcetypePager) error

// WithSourceTypeOrder configures pagination ordering.
func WithSourceTypeOrder(order *SourceTypeOrder) SourceTypePaginateOption {
	if order == nil {
		order = DefaultSourceTypeOrder
	}
	o := *order
	return func(pager *sourcetypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSourceTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSourceTypeFilter configures pagination filter.
func WithSourceTypeFilter(filter func(*SourceTypeQuery) (*SourceTypeQuery, error)) SourceTypePaginateOption {
	return func(pager *sourcetypePager) error {
		if filter == nil {
			return errors.New("SourceTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sourcetypePager struct {
	order  *SourceTypeOrder
	filter func(*SourceTypeQuery) (*SourceTypeQuery, error)
}

func newSourceTypePager(opts []SourceTypePaginateOption) (*sourcetypePager, error) {
	pager := &sourcetypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSourceTypeOrder
	}
	return pager, nil
}

func (p *sourcetypePager) applyFilter(query *SourceTypeQuery) (*SourceTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sourcetypePager) toCursor(st *SourceType) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *sourcetypePager) applyCursors(query *SourceTypeQuery, after, before *Cursor) *SourceTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSourceTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sourcetypePager) applyOrder(query *SourceTypeQuery, reverse bool) *SourceTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSourceTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSourceTypeOrder.Field.field))
	}
	return query
}

func (p *sourcetypePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSourceTypeOrder.Field {
			b.Comma().Ident(DefaultSourceTypeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SourceType.
func (st *SourceTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SourceTypePaginateOption,
) (*SourceTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSourceTypePager(opts)
	if err != nil {
		return nil, err
	}
	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}
	conn := &SourceTypeConnection{Edges: []*SourceTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = st.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	st = pager.applyCursors(st, after, before)
	st = pager.applyOrder(st, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		st.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := st.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := st.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SourceTypeOrderFieldCreatedAt orders SourceType by created_at.
	SourceTypeOrderFieldCreatedAt = &SourceTypeOrderField{
		field: sourcetype.FieldCreatedAt,
		toCursor: func(st *SourceType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.CreatedAt,
			}
		},
	}
	// SourceTypeOrderFieldUpdatedAt orders SourceType by updated_at.
	SourceTypeOrderFieldUpdatedAt = &SourceTypeOrderField{
		field: sourcetype.FieldUpdatedAt,
		toCursor: func(st *SourceType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.UpdatedAt,
			}
		},
	}
	// SourceTypeOrderFieldDeletedAt orders SourceType by deleted_at.
	SourceTypeOrderFieldDeletedAt = &SourceTypeOrderField{
		field: sourcetype.FieldDeletedAt,
		toCursor: func(st *SourceType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.DeletedAt,
			}
		},
	}
	// SourceTypeOrderFieldValue orders SourceType by value.
	SourceTypeOrderFieldValue = &SourceTypeOrderField{
		field: sourcetype.FieldValue,
		toCursor: func(st *SourceType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SourceTypeOrderField) String() string {
	var str string
	switch f.field {
	case sourcetype.FieldCreatedAt:
		str = "CREATED_AT"
	case sourcetype.FieldUpdatedAt:
		str = "UPDATED_AT"
	case sourcetype.FieldDeletedAt:
		str = "DELETED_AT"
	case sourcetype.FieldValue:
		str = "SOURCE_TYPE_VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SourceTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SourceTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SourceTypeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *SourceTypeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *SourceTypeOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *SourceTypeOrderFieldDeletedAt
	case "SOURCE_TYPE_VALUE":
		*f = *SourceTypeOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid SourceTypeOrderField", str)
	}
	return nil
}

// SourceTypeOrderField defines the ordering field of SourceType.
type SourceTypeOrderField struct {
	field    string
	toCursor func(*SourceType) Cursor
}

// SourceTypeOrder defines the ordering of SourceType.
type SourceTypeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *SourceTypeOrderField `json:"field"`
}

// DefaultSourceTypeOrder is the default ordering of SourceType.
var DefaultSourceTypeOrder = &SourceTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &SourceTypeOrderField{
		field: sourcetype.FieldID,
		toCursor: func(st *SourceType) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// ToEdge converts SourceType into SourceTypeEdge.
func (st *SourceType) ToEdge(order *SourceTypeOrder) *SourceTypeEdge {
	if order == nil {
		order = DefaultSourceTypeOrder
	}
	return &SourceTypeEdge{
		Node:   st,
		Cursor: order.Field.toCursor(st),
	}
}

// StaffAccountEdge is the edge representation of StaffAccount.
type StaffAccountEdge struct {
	Node   *StaffAccount `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// StaffAccountConnection is the connection containing edges to StaffAccount.
type StaffAccountConnection struct {
	Edges      []*StaffAccountEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *StaffAccountConnection) build(nodes []*StaffAccount, pager *staffaccountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *StaffAccount
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *StaffAccount {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *StaffAccount {
			return nodes[i]
		}
	}
	c.Edges = make([]*StaffAccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StaffAccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StaffAccountPaginateOption enables pagination customization.
type StaffAccountPaginateOption func(*staffaccountPager) error

// WithStaffAccountOrder configures pagination ordering.
func WithStaffAccountOrder(order *StaffAccountOrder) StaffAccountPaginateOption {
	if order == nil {
		order = DefaultStaffAccountOrder
	}
	o := *order
	return func(pager *staffaccountPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStaffAccountOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStaffAccountFilter configures pagination filter.
func WithStaffAccountFilter(filter func(*StaffAccountQuery) (*StaffAccountQuery, error)) StaffAccountPaginateOption {
	return func(pager *staffaccountPager) error {
		if filter == nil {
			return errors.New("StaffAccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type staffaccountPager struct {
	order  *StaffAccountOrder
	filter func(*StaffAccountQuery) (*StaffAccountQuery, error)
}

func newStaffAccountPager(opts []StaffAccountPaginateOption) (*staffaccountPager, error) {
	pager := &staffaccountPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStaffAccountOrder
	}
	return pager, nil
}

func (p *staffaccountPager) applyFilter(query *StaffAccountQuery) (*StaffAccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *staffaccountPager) toCursor(sa *StaffAccount) Cursor {
	return p.order.Field.toCursor(sa)
}

func (p *staffaccountPager) applyCursors(query *StaffAccountQuery, after, before *Cursor) *StaffAccountQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultStaffAccountOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *staffaccountPager) applyOrder(query *StaffAccountQuery, reverse bool) *StaffAccountQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultStaffAccountOrder.Field {
		query = query.Order(direction.orderFunc(DefaultStaffAccountOrder.Field.field))
	}
	return query
}

func (p *staffaccountPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStaffAccountOrder.Field {
			b.Comma().Ident(DefaultStaffAccountOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to StaffAccount.
func (sa *StaffAccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StaffAccountPaginateOption,
) (*StaffAccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStaffAccountPager(opts)
	if err != nil {
		return nil, err
	}
	if sa, err = pager.applyFilter(sa); err != nil {
		return nil, err
	}
	conn := &StaffAccountConnection{Edges: []*StaffAccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = sa.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	sa = pager.applyCursors(sa, after, before)
	sa = pager.applyOrder(sa, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		sa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := sa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// StaffAccountOrderFieldCreatedAt orders StaffAccount by created_at.
	StaffAccountOrderFieldCreatedAt = &StaffAccountOrderField{
		field: staffaccount.FieldCreatedAt,
		toCursor: func(sa *StaffAccount) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.CreatedAt,
			}
		},
	}
	// StaffAccountOrderFieldUpdatedAt orders StaffAccount by updated_at.
	StaffAccountOrderFieldUpdatedAt = &StaffAccountOrderField{
		field: staffaccount.FieldUpdatedAt,
		toCursor: func(sa *StaffAccount) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.UpdatedAt,
			}
		},
	}
	// StaffAccountOrderFieldDeletedAt orders StaffAccount by deleted_at.
	StaffAccountOrderFieldDeletedAt = &StaffAccountOrderField{
		field: staffaccount.FieldDeletedAt,
		toCursor: func(sa *StaffAccount) Cursor {
			return Cursor{
				ID:    sa.ID,
				Value: sa.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f StaffAccountOrderField) String() string {
	var str string
	switch f.field {
	case staffaccount.FieldCreatedAt:
		str = "CREATED_AT"
	case staffaccount.FieldUpdatedAt:
		str = "UPDATED_AT"
	case staffaccount.FieldDeletedAt:
		str = "DELETED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f StaffAccountOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *StaffAccountOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("StaffAccountOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *StaffAccountOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *StaffAccountOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *StaffAccountOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid StaffAccountOrderField", str)
	}
	return nil
}

// StaffAccountOrderField defines the ordering field of StaffAccount.
type StaffAccountOrderField struct {
	field    string
	toCursor func(*StaffAccount) Cursor
}

// StaffAccountOrder defines the ordering of StaffAccount.
type StaffAccountOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *StaffAccountOrderField `json:"field"`
}

// DefaultStaffAccountOrder is the default ordering of StaffAccount.
var DefaultStaffAccountOrder = &StaffAccountOrder{
	Direction: OrderDirectionAsc,
	Field: &StaffAccountOrderField{
		field: staffaccount.FieldID,
		toCursor: func(sa *StaffAccount) Cursor {
			return Cursor{ID: sa.ID}
		},
	},
}

// ToEdge converts StaffAccount into StaffAccountEdge.
func (sa *StaffAccount) ToEdge(order *StaffAccountOrder) *StaffAccountEdge {
	if order == nil {
		order = DefaultStaffAccountOrder
	}
	return &StaffAccountEdge{
		Node:   sa,
		Cursor: order.Field.toCursor(sa),
	}
}

// TransactionEdge is the edge representation of Transaction.
type TransactionEdge struct {
	Node   *Transaction `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// TransactionConnection is the connection containing edges to Transaction.
type TransactionConnection struct {
	Edges      []*TransactionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *TransactionConnection) build(nodes []*Transaction, pager *transactionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Transaction
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Transaction {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Transaction {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionPaginateOption enables pagination customization.
type TransactionPaginateOption func(*transactionPager) error

// WithTransactionOrder configures pagination ordering.
func WithTransactionOrder(order *TransactionOrder) TransactionPaginateOption {
	if order == nil {
		order = DefaultTransactionOrder
	}
	o := *order
	return func(pager *transactionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionFilter configures pagination filter.
func WithTransactionFilter(filter func(*TransactionQuery) (*TransactionQuery, error)) TransactionPaginateOption {
	return func(pager *transactionPager) error {
		if filter == nil {
			return errors.New("TransactionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactionPager struct {
	order  *TransactionOrder
	filter func(*TransactionQuery) (*TransactionQuery, error)
}

func newTransactionPager(opts []TransactionPaginateOption) (*transactionPager, error) {
	pager := &transactionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionOrder
	}
	return pager, nil
}

func (p *transactionPager) applyFilter(query *TransactionQuery) (*TransactionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactionPager) toCursor(t *Transaction) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *transactionPager) applyCursors(query *TransactionQuery, after, before *Cursor) *TransactionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactionPager) applyOrder(query *TransactionQuery, reverse bool) *TransactionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionOrder.Field.field))
	}
	return query
}

func (p *transactionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionOrder.Field {
			b.Comma().Ident(DefaultTransactionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Transaction.
func (t *TransactionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionPaginateOption,
) (*TransactionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionPager(opts)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TransactionConnection{Edges: []*TransactionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TransactionOrderFieldCreatedAt orders Transaction by created_at.
	TransactionOrderFieldCreatedAt = &TransactionOrderField{
		field: transaction.FieldCreatedAt,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
	// TransactionOrderFieldUpdatedAt orders Transaction by updated_at.
	TransactionOrderFieldUpdatedAt = &TransactionOrderField{
		field: transaction.FieldUpdatedAt,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.UpdatedAt,
			}
		},
	}
	// TransactionOrderFieldDeletedAt orders Transaction by deleted_at.
	TransactionOrderFieldDeletedAt = &TransactionOrderField{
		field: transaction.FieldDeletedAt,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TransactionOrderField) String() string {
	var str string
	switch f.field {
	case transaction.FieldCreatedAt:
		str = "CREATED_AT"
	case transaction.FieldUpdatedAt:
		str = "UPDATED_AT"
	case transaction.FieldDeletedAt:
		str = "DELETED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TransactionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TransactionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TransactionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TransactionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TransactionOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *TransactionOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid TransactionOrderField", str)
	}
	return nil
}

// TransactionOrderField defines the ordering field of Transaction.
type TransactionOrderField struct {
	field    string
	toCursor func(*Transaction) Cursor
}

// TransactionOrder defines the ordering of Transaction.
type TransactionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *TransactionOrderField `json:"field"`
}

// DefaultTransactionOrder is the default ordering of Transaction.
var DefaultTransactionOrder = &TransactionOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionOrderField{
		field: transaction.FieldID,
		toCursor: func(t *Transaction) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Transaction into TransactionEdge.
func (t *Transaction) ToEdge(order *TransactionOrder) *TransactionEdge {
	if order == nil {
		order = DefaultTransactionOrder
	}
	return &TransactionEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TransactionTypeEdge is the edge representation of TransactionType.
type TransactionTypeEdge struct {
	Node   *TransactionType `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// TransactionTypeConnection is the connection containing edges to TransactionType.
type TransactionTypeConnection struct {
	Edges      []*TransactionTypeEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *TransactionTypeConnection) build(nodes []*TransactionType, pager *transactiontypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TransactionType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TransactionType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TransactionType {
			return nodes[i]
		}
	}
	c.Edges = make([]*TransactionTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TransactionTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TransactionTypePaginateOption enables pagination customization.
type TransactionTypePaginateOption func(*transactiontypePager) error

// WithTransactionTypeOrder configures pagination ordering.
func WithTransactionTypeOrder(order *TransactionTypeOrder) TransactionTypePaginateOption {
	if order == nil {
		order = DefaultTransactionTypeOrder
	}
	o := *order
	return func(pager *transactiontypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTransactionTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTransactionTypeFilter configures pagination filter.
func WithTransactionTypeFilter(filter func(*TransactionTypeQuery) (*TransactionTypeQuery, error)) TransactionTypePaginateOption {
	return func(pager *transactiontypePager) error {
		if filter == nil {
			return errors.New("TransactionTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type transactiontypePager struct {
	order  *TransactionTypeOrder
	filter func(*TransactionTypeQuery) (*TransactionTypeQuery, error)
}

func newTransactionTypePager(opts []TransactionTypePaginateOption) (*transactiontypePager, error) {
	pager := &transactiontypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTransactionTypeOrder
	}
	return pager, nil
}

func (p *transactiontypePager) applyFilter(query *TransactionTypeQuery) (*TransactionTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *transactiontypePager) toCursor(tt *TransactionType) Cursor {
	return p.order.Field.toCursor(tt)
}

func (p *transactiontypePager) applyCursors(query *TransactionTypeQuery, after, before *Cursor) *TransactionTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTransactionTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *transactiontypePager) applyOrder(query *TransactionTypeQuery, reverse bool) *TransactionTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTransactionTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTransactionTypeOrder.Field.field))
	}
	return query
}

func (p *transactiontypePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTransactionTypeOrder.Field {
			b.Comma().Ident(DefaultTransactionTypeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TransactionType.
func (tt *TransactionTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TransactionTypePaginateOption,
) (*TransactionTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTransactionTypePager(opts)
	if err != nil {
		return nil, err
	}
	if tt, err = pager.applyFilter(tt); err != nil {
		return nil, err
	}
	conn := &TransactionTypeConnection{Edges: []*TransactionTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = tt.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	tt = pager.applyCursors(tt, after, before)
	tt = pager.applyOrder(tt, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		tt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := tt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TransactionTypeOrderFieldCreatedAt orders TransactionType by created_at.
	TransactionTypeOrderFieldCreatedAt = &TransactionTypeOrderField{
		field: transactiontype.FieldCreatedAt,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.CreatedAt,
			}
		},
	}
	// TransactionTypeOrderFieldUpdatedAt orders TransactionType by updated_at.
	TransactionTypeOrderFieldUpdatedAt = &TransactionTypeOrderField{
		field: transactiontype.FieldUpdatedAt,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.UpdatedAt,
			}
		},
	}
	// TransactionTypeOrderFieldDeletedAt orders TransactionType by deleted_at.
	TransactionTypeOrderFieldDeletedAt = &TransactionTypeOrderField{
		field: transactiontype.FieldDeletedAt,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.DeletedAt,
			}
		},
	}
	// TransactionTypeOrderFieldValue orders TransactionType by value.
	TransactionTypeOrderFieldValue = &TransactionTypeOrderField{
		field: transactiontype.FieldValue,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{
				ID:    tt.ID,
				Value: tt.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TransactionTypeOrderField) String() string {
	var str string
	switch f.field {
	case transactiontype.FieldCreatedAt:
		str = "CREATED_AT"
	case transactiontype.FieldUpdatedAt:
		str = "UPDATED_AT"
	case transactiontype.FieldDeletedAt:
		str = "DELETED_AT"
	case transactiontype.FieldValue:
		str = "TRANSACTION_TYPE_VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TransactionTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TransactionTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TransactionTypeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *TransactionTypeOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *TransactionTypeOrderFieldUpdatedAt
	case "DELETED_AT":
		*f = *TransactionTypeOrderFieldDeletedAt
	case "TRANSACTION_TYPE_VALUE":
		*f = *TransactionTypeOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid TransactionTypeOrderField", str)
	}
	return nil
}

// TransactionTypeOrderField defines the ordering field of TransactionType.
type TransactionTypeOrderField struct {
	field    string
	toCursor func(*TransactionType) Cursor
}

// TransactionTypeOrder defines the ordering of TransactionType.
type TransactionTypeOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *TransactionTypeOrderField `json:"field"`
}

// DefaultTransactionTypeOrder is the default ordering of TransactionType.
var DefaultTransactionTypeOrder = &TransactionTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &TransactionTypeOrderField{
		field: transactiontype.FieldID,
		toCursor: func(tt *TransactionType) Cursor {
			return Cursor{ID: tt.ID}
		},
	},
}

// ToEdge converts TransactionType into TransactionTypeEdge.
func (tt *TransactionType) ToEdge(order *TransactionTypeOrder) *TransactionTypeEdge {
	if order == nil {
		order = DefaultTransactionTypeOrder
	}
	return &TransactionTypeEdge{
		Node:   tt,
		Cursor: order.Field.toCursor(tt),
	}
}
