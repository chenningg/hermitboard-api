// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/authtype"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/connection"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/predicate"
	"github.com/chenningg/hermitboard-api/ent/source"
	"github.com/chenningg/hermitboard-api/ent/sourcetype"
	"github.com/chenningg/hermitboard-api/ent/staffaccount"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"
	"github.com/chenningg/hermitboard-api/pulid"
)

// AccountWhereInput represents a where input for filtering Account queries.
type AccountWhereInput struct {
	Predicates []predicate.Account  `json:"-"`
	Not        *AccountWhereInput   `json:"not,omitempty"`
	Or         []*AccountWhereInput `json:"or,omitempty"`
	And        []*AccountWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "nickname" field predicates.
	Nickname             *string  `json:"nickname,omitempty"`
	NicknameNEQ          *string  `json:"nicknameNEQ,omitempty"`
	NicknameIn           []string `json:"nicknameIn,omitempty"`
	NicknameNotIn        []string `json:"nicknameNotIn,omitempty"`
	NicknameGT           *string  `json:"nicknameGT,omitempty"`
	NicknameGTE          *string  `json:"nicknameGTE,omitempty"`
	NicknameLT           *string  `json:"nicknameLT,omitempty"`
	NicknameLTE          *string  `json:"nicknameLTE,omitempty"`
	NicknameContains     *string  `json:"nicknameContains,omitempty"`
	NicknameHasPrefix    *string  `json:"nicknameHasPrefix,omitempty"`
	NicknameHasSuffix    *string  `json:"nicknameHasSuffix,omitempty"`
	NicknameEqualFold    *string  `json:"nicknameEqualFold,omitempty"`
	NicknameContainsFold *string  `json:"nicknameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "password_updated_at" field predicates.
	PasswordUpdatedAt      *time.Time  `json:"passwordUpdatedAt,omitempty"`
	PasswordUpdatedAtNEQ   *time.Time  `json:"passwordUpdatedAtNEQ,omitempty"`
	PasswordUpdatedAtIn    []time.Time `json:"passwordUpdatedAtIn,omitempty"`
	PasswordUpdatedAtNotIn []time.Time `json:"passwordUpdatedAtNotIn,omitempty"`
	PasswordUpdatedAtGT    *time.Time  `json:"passwordUpdatedAtGT,omitempty"`
	PasswordUpdatedAtGTE   *time.Time  `json:"passwordUpdatedAtGTE,omitempty"`
	PasswordUpdatedAtLT    *time.Time  `json:"passwordUpdatedAtLT,omitempty"`
	PasswordUpdatedAtLTE   *time.Time  `json:"passwordUpdatedAtLTE,omitempty"`

	// "auth_type_id" field predicates.
	AuthTypeID             *pulid.PULID  `json:"authTypeID,omitempty"`
	AuthTypeIDNEQ          *pulid.PULID  `json:"authTypeIDNEQ,omitempty"`
	AuthTypeIDIn           []pulid.PULID `json:"authTypeIDIn,omitempty"`
	AuthTypeIDNotIn        []pulid.PULID `json:"authTypeIDNotIn,omitempty"`
	AuthTypeIDGT           *pulid.PULID  `json:"authTypeIDGT,omitempty"`
	AuthTypeIDGTE          *pulid.PULID  `json:"authTypeIDGTE,omitempty"`
	AuthTypeIDLT           *pulid.PULID  `json:"authTypeIDLT,omitempty"`
	AuthTypeIDLTE          *pulid.PULID  `json:"authTypeIDLTE,omitempty"`
	AuthTypeIDContains     *pulid.PULID  `json:"authTypeIDContains,omitempty"`
	AuthTypeIDHasPrefix    *pulid.PULID  `json:"authTypeIDHasPrefix,omitempty"`
	AuthTypeIDHasSuffix    *pulid.PULID  `json:"authTypeIDHasSuffix,omitempty"`
	AuthTypeIDEqualFold    *pulid.PULID  `json:"authTypeIDEqualFold,omitempty"`
	AuthTypeIDContainsFold *pulid.PULID  `json:"authTypeIDContainsFold,omitempty"`

	// "auth_roles" edge predicates.
	HasAuthRoles     *bool                 `json:"hasAuthRoles,omitempty"`
	HasAuthRolesWith []*AuthRoleWhereInput `json:"hasAuthRolesWith,omitempty"`

	// "portfolios" edge predicates.
	HasPortfolios     *bool                  `json:"hasPortfolios,omitempty"`
	HasPortfoliosWith []*PortfolioWhereInput `json:"hasPortfoliosWith,omitempty"`

	// "auth_type" edge predicates.
	HasAuthType     *bool                 `json:"hasAuthType,omitempty"`
	HasAuthTypeWith []*AuthTypeWhereInput `json:"hasAuthTypeWith,omitempty"`

	// "connections" edge predicates.
	HasConnections     *bool                   `json:"hasConnections,omitempty"`
	HasConnectionsWith []*ConnectionWhereInput `json:"hasConnectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AccountWhereInput) AddPredicates(predicates ...predicate.Account) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AccountWhereInput filter on the AccountQuery builder.
func (i *AccountWhereInput) Filter(q *AccountQuery) (*AccountQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAccountWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAccountWhereInput is returned in case the AccountWhereInput is empty.
var ErrEmptyAccountWhereInput = errors.New("ent: empty predicate AccountWhereInput")

// P returns a predicate for filtering accounts.
// An error is returned if the input is empty or invalid.
func (i *AccountWhereInput) P() (predicate.Account, error) {
	var predicates []predicate.Account
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, account.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Account, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, account.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Account, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, account.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, account.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, account.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, account.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, account.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, account.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, account.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, account.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, account.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, account.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, account.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, account.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, account.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, account.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, account.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, account.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, account.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, account.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, account.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, account.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, account.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, account.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, account.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, account.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, account.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, account.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, account.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, account.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, account.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, account.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, account.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, account.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, account.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, account.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, account.DeletedAtNotNil())
	}
	if i.Nickname != nil {
		predicates = append(predicates, account.NicknameEQ(*i.Nickname))
	}
	if i.NicknameNEQ != nil {
		predicates = append(predicates, account.NicknameNEQ(*i.NicknameNEQ))
	}
	if len(i.NicknameIn) > 0 {
		predicates = append(predicates, account.NicknameIn(i.NicknameIn...))
	}
	if len(i.NicknameNotIn) > 0 {
		predicates = append(predicates, account.NicknameNotIn(i.NicknameNotIn...))
	}
	if i.NicknameGT != nil {
		predicates = append(predicates, account.NicknameGT(*i.NicknameGT))
	}
	if i.NicknameGTE != nil {
		predicates = append(predicates, account.NicknameGTE(*i.NicknameGTE))
	}
	if i.NicknameLT != nil {
		predicates = append(predicates, account.NicknameLT(*i.NicknameLT))
	}
	if i.NicknameLTE != nil {
		predicates = append(predicates, account.NicknameLTE(*i.NicknameLTE))
	}
	if i.NicknameContains != nil {
		predicates = append(predicates, account.NicknameContains(*i.NicknameContains))
	}
	if i.NicknameHasPrefix != nil {
		predicates = append(predicates, account.NicknameHasPrefix(*i.NicknameHasPrefix))
	}
	if i.NicknameHasSuffix != nil {
		predicates = append(predicates, account.NicknameHasSuffix(*i.NicknameHasSuffix))
	}
	if i.NicknameEqualFold != nil {
		predicates = append(predicates, account.NicknameEqualFold(*i.NicknameEqualFold))
	}
	if i.NicknameContainsFold != nil {
		predicates = append(predicates, account.NicknameContainsFold(*i.NicknameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, account.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, account.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, account.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, account.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, account.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, account.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, account.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, account.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, account.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, account.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, account.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, account.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, account.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, account.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, account.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, account.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, account.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, account.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, account.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, account.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, account.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, account.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, account.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, account.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, account.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, account.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, account.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, account.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.PasswordUpdatedAt != nil {
		predicates = append(predicates, account.PasswordUpdatedAtEQ(*i.PasswordUpdatedAt))
	}
	if i.PasswordUpdatedAtNEQ != nil {
		predicates = append(predicates, account.PasswordUpdatedAtNEQ(*i.PasswordUpdatedAtNEQ))
	}
	if len(i.PasswordUpdatedAtIn) > 0 {
		predicates = append(predicates, account.PasswordUpdatedAtIn(i.PasswordUpdatedAtIn...))
	}
	if len(i.PasswordUpdatedAtNotIn) > 0 {
		predicates = append(predicates, account.PasswordUpdatedAtNotIn(i.PasswordUpdatedAtNotIn...))
	}
	if i.PasswordUpdatedAtGT != nil {
		predicates = append(predicates, account.PasswordUpdatedAtGT(*i.PasswordUpdatedAtGT))
	}
	if i.PasswordUpdatedAtGTE != nil {
		predicates = append(predicates, account.PasswordUpdatedAtGTE(*i.PasswordUpdatedAtGTE))
	}
	if i.PasswordUpdatedAtLT != nil {
		predicates = append(predicates, account.PasswordUpdatedAtLT(*i.PasswordUpdatedAtLT))
	}
	if i.PasswordUpdatedAtLTE != nil {
		predicates = append(predicates, account.PasswordUpdatedAtLTE(*i.PasswordUpdatedAtLTE))
	}
	if i.AuthTypeID != nil {
		predicates = append(predicates, account.AuthTypeIDEQ(*i.AuthTypeID))
	}
	if i.AuthTypeIDNEQ != nil {
		predicates = append(predicates, account.AuthTypeIDNEQ(*i.AuthTypeIDNEQ))
	}
	if len(i.AuthTypeIDIn) > 0 {
		predicates = append(predicates, account.AuthTypeIDIn(i.AuthTypeIDIn...))
	}
	if len(i.AuthTypeIDNotIn) > 0 {
		predicates = append(predicates, account.AuthTypeIDNotIn(i.AuthTypeIDNotIn...))
	}
	if i.AuthTypeIDGT != nil {
		predicates = append(predicates, account.AuthTypeIDGT(*i.AuthTypeIDGT))
	}
	if i.AuthTypeIDGTE != nil {
		predicates = append(predicates, account.AuthTypeIDGTE(*i.AuthTypeIDGTE))
	}
	if i.AuthTypeIDLT != nil {
		predicates = append(predicates, account.AuthTypeIDLT(*i.AuthTypeIDLT))
	}
	if i.AuthTypeIDLTE != nil {
		predicates = append(predicates, account.AuthTypeIDLTE(*i.AuthTypeIDLTE))
	}
	if i.AuthTypeIDContains != nil {
		predicates = append(predicates, account.AuthTypeIDContains(*i.AuthTypeIDContains))
	}
	if i.AuthTypeIDHasPrefix != nil {
		predicates = append(predicates, account.AuthTypeIDHasPrefix(*i.AuthTypeIDHasPrefix))
	}
	if i.AuthTypeIDHasSuffix != nil {
		predicates = append(predicates, account.AuthTypeIDHasSuffix(*i.AuthTypeIDHasSuffix))
	}
	if i.AuthTypeIDEqualFold != nil {
		predicates = append(predicates, account.AuthTypeIDEqualFold(*i.AuthTypeIDEqualFold))
	}
	if i.AuthTypeIDContainsFold != nil {
		predicates = append(predicates, account.AuthTypeIDContainsFold(*i.AuthTypeIDContainsFold))
	}

	if i.HasAuthRoles != nil {
		p := account.HasAuthRoles()
		if !*i.HasAuthRoles {
			p = account.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthRolesWith) > 0 {
		with := make([]predicate.AuthRole, 0, len(i.HasAuthRolesWith))
		for _, w := range i.HasAuthRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, account.HasAuthRolesWith(with...))
	}
	if i.HasPortfolios != nil {
		p := account.HasPortfolios()
		if !*i.HasPortfolios {
			p = account.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPortfoliosWith) > 0 {
		with := make([]predicate.Portfolio, 0, len(i.HasPortfoliosWith))
		for _, w := range i.HasPortfoliosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPortfoliosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, account.HasPortfoliosWith(with...))
	}
	if i.HasAuthType != nil {
		p := account.HasAuthType()
		if !*i.HasAuthType {
			p = account.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthTypeWith) > 0 {
		with := make([]predicate.AuthType, 0, len(i.HasAuthTypeWith))
		for _, w := range i.HasAuthTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, account.HasAuthTypeWith(with...))
	}
	if i.HasConnections != nil {
		p := account.HasConnections()
		if !*i.HasConnections {
			p = account.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionsWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionsWith))
		for _, w := range i.HasConnectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, account.HasConnectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAccountWhereInput
	case 1:
		return predicates[0], nil
	default:
		return account.And(predicates...), nil
	}
}

// AssetWhereInput represents a where input for filtering Asset queries.
type AssetWhereInput struct {
	Predicates []predicate.Asset  `json:"-"`
	Not        *AssetWhereInput   `json:"not,omitempty"`
	Or         []*AssetWhereInput `json:"or,omitempty"`
	And        []*AssetWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "asset_class_id" field predicates.
	AssetClassID             *pulid.PULID  `json:"assetClassID,omitempty"`
	AssetClassIDNEQ          *pulid.PULID  `json:"assetClassIDNEQ,omitempty"`
	AssetClassIDIn           []pulid.PULID `json:"assetClassIDIn,omitempty"`
	AssetClassIDNotIn        []pulid.PULID `json:"assetClassIDNotIn,omitempty"`
	AssetClassIDGT           *pulid.PULID  `json:"assetClassIDGT,omitempty"`
	AssetClassIDGTE          *pulid.PULID  `json:"assetClassIDGTE,omitempty"`
	AssetClassIDLT           *pulid.PULID  `json:"assetClassIDLT,omitempty"`
	AssetClassIDLTE          *pulid.PULID  `json:"assetClassIDLTE,omitempty"`
	AssetClassIDContains     *pulid.PULID  `json:"assetClassIDContains,omitempty"`
	AssetClassIDHasPrefix    *pulid.PULID  `json:"assetClassIDHasPrefix,omitempty"`
	AssetClassIDHasSuffix    *pulid.PULID  `json:"assetClassIDHasSuffix,omitempty"`
	AssetClassIDEqualFold    *pulid.PULID  `json:"assetClassIDEqualFold,omitempty"`
	AssetClassIDContainsFold *pulid.PULID  `json:"assetClassIDContainsFold,omitempty"`

	// "asset_class" edge predicates.
	HasAssetClass     *bool                   `json:"hasAssetClass,omitempty"`
	HasAssetClassWith []*AssetClassWhereInput `json:"hasAssetClassWith,omitempty"`

	// "cryptocurrency" edge predicates.
	HasCryptocurrency     *bool                       `json:"hasCryptocurrency,omitempty"`
	HasCryptocurrencyWith []*CryptocurrencyWhereInput `json:"hasCryptocurrencyWith,omitempty"`

	// "transaction_bases" edge predicates.
	HasTransactionBases     *bool                    `json:"hasTransactionBases,omitempty"`
	HasTransactionBasesWith []*TransactionWhereInput `json:"hasTransactionBasesWith,omitempty"`

	// "transaction_quotes" edge predicates.
	HasTransactionQuotes     *bool                    `json:"hasTransactionQuotes,omitempty"`
	HasTransactionQuotesWith []*TransactionWhereInput `json:"hasTransactionQuotesWith,omitempty"`

	// "daily_asset_prices" edge predicates.
	HasDailyAssetPrices     *bool                        `json:"hasDailyAssetPrices,omitempty"`
	HasDailyAssetPricesWith []*DailyAssetPriceWhereInput `json:"hasDailyAssetPricesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AssetWhereInput) AddPredicates(predicates ...predicate.Asset) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AssetWhereInput filter on the AssetQuery builder.
func (i *AssetWhereInput) Filter(q *AssetQuery) (*AssetQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAssetWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAssetWhereInput is returned in case the AssetWhereInput is empty.
var ErrEmptyAssetWhereInput = errors.New("ent: empty predicate AssetWhereInput")

// P returns a predicate for filtering assets.
// An error is returned if the input is empty or invalid.
func (i *AssetWhereInput) P() (predicate.Asset, error) {
	var predicates []predicate.Asset
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, asset.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Asset, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, asset.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Asset, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, asset.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, asset.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, asset.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, asset.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, asset.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, asset.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, asset.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, asset.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, asset.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, asset.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, asset.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, asset.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, asset.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, asset.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, asset.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, asset.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, asset.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, asset.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, asset.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, asset.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, asset.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, asset.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, asset.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, asset.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, asset.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, asset.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, asset.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, asset.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, asset.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, asset.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, asset.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, asset.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, asset.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, asset.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, asset.DeletedAtNotNil())
	}
	if i.AssetClassID != nil {
		predicates = append(predicates, asset.AssetClassIDEQ(*i.AssetClassID))
	}
	if i.AssetClassIDNEQ != nil {
		predicates = append(predicates, asset.AssetClassIDNEQ(*i.AssetClassIDNEQ))
	}
	if len(i.AssetClassIDIn) > 0 {
		predicates = append(predicates, asset.AssetClassIDIn(i.AssetClassIDIn...))
	}
	if len(i.AssetClassIDNotIn) > 0 {
		predicates = append(predicates, asset.AssetClassIDNotIn(i.AssetClassIDNotIn...))
	}
	if i.AssetClassIDGT != nil {
		predicates = append(predicates, asset.AssetClassIDGT(*i.AssetClassIDGT))
	}
	if i.AssetClassIDGTE != nil {
		predicates = append(predicates, asset.AssetClassIDGTE(*i.AssetClassIDGTE))
	}
	if i.AssetClassIDLT != nil {
		predicates = append(predicates, asset.AssetClassIDLT(*i.AssetClassIDLT))
	}
	if i.AssetClassIDLTE != nil {
		predicates = append(predicates, asset.AssetClassIDLTE(*i.AssetClassIDLTE))
	}
	if i.AssetClassIDContains != nil {
		predicates = append(predicates, asset.AssetClassIDContains(*i.AssetClassIDContains))
	}
	if i.AssetClassIDHasPrefix != nil {
		predicates = append(predicates, asset.AssetClassIDHasPrefix(*i.AssetClassIDHasPrefix))
	}
	if i.AssetClassIDHasSuffix != nil {
		predicates = append(predicates, asset.AssetClassIDHasSuffix(*i.AssetClassIDHasSuffix))
	}
	if i.AssetClassIDEqualFold != nil {
		predicates = append(predicates, asset.AssetClassIDEqualFold(*i.AssetClassIDEqualFold))
	}
	if i.AssetClassIDContainsFold != nil {
		predicates = append(predicates, asset.AssetClassIDContainsFold(*i.AssetClassIDContainsFold))
	}

	if i.HasAssetClass != nil {
		p := asset.HasAssetClass()
		if !*i.HasAssetClass {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetClassWith) > 0 {
		with := make([]predicate.AssetClass, 0, len(i.HasAssetClassWith))
		for _, w := range i.HasAssetClassWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetClassWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasAssetClassWith(with...))
	}
	if i.HasCryptocurrency != nil {
		p := asset.HasCryptocurrency()
		if !*i.HasCryptocurrency {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCryptocurrencyWith) > 0 {
		with := make([]predicate.Cryptocurrency, 0, len(i.HasCryptocurrencyWith))
		for _, w := range i.HasCryptocurrencyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCryptocurrencyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasCryptocurrencyWith(with...))
	}
	if i.HasTransactionBases != nil {
		p := asset.HasTransactionBases()
		if !*i.HasTransactionBases {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionBasesWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionBasesWith))
		for _, w := range i.HasTransactionBasesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionBasesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasTransactionBasesWith(with...))
	}
	if i.HasTransactionQuotes != nil {
		p := asset.HasTransactionQuotes()
		if !*i.HasTransactionQuotes {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionQuotesWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionQuotesWith))
		for _, w := range i.HasTransactionQuotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionQuotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasTransactionQuotesWith(with...))
	}
	if i.HasDailyAssetPrices != nil {
		p := asset.HasDailyAssetPrices()
		if !*i.HasDailyAssetPrices {
			p = asset.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDailyAssetPricesWith) > 0 {
		with := make([]predicate.DailyAssetPrice, 0, len(i.HasDailyAssetPricesWith))
		for _, w := range i.HasDailyAssetPricesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDailyAssetPricesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, asset.HasDailyAssetPricesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAssetWhereInput
	case 1:
		return predicates[0], nil
	default:
		return asset.And(predicates...), nil
	}
}

// AssetClassWhereInput represents a where input for filtering AssetClass queries.
type AssetClassWhereInput struct {
	Predicates []predicate.AssetClass  `json:"-"`
	Not        *AssetClassWhereInput   `json:"not,omitempty"`
	Or         []*AssetClassWhereInput `json:"or,omitempty"`
	And        []*AssetClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "value" field predicates.
	Value      *assetclass.Value  `json:"value,omitempty"`
	ValueNEQ   *assetclass.Value  `json:"valueNEQ,omitempty"`
	ValueIn    []assetclass.Value `json:"valueIn,omitempty"`
	ValueNotIn []assetclass.Value `json:"valueNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "assets" edge predicates.
	HasAssets     *bool              `json:"hasAssets,omitempty"`
	HasAssetsWith []*AssetWhereInput `json:"hasAssetsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AssetClassWhereInput) AddPredicates(predicates ...predicate.AssetClass) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AssetClassWhereInput filter on the AssetClassQuery builder.
func (i *AssetClassWhereInput) Filter(q *AssetClassQuery) (*AssetClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAssetClassWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAssetClassWhereInput is returned in case the AssetClassWhereInput is empty.
var ErrEmptyAssetClassWhereInput = errors.New("ent: empty predicate AssetClassWhereInput")

// P returns a predicate for filtering assetclasses.
// An error is returned if the input is empty or invalid.
func (i *AssetClassWhereInput) P() (predicate.AssetClass, error) {
	var predicates []predicate.AssetClass
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, assetclass.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AssetClass, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, assetclass.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AssetClass, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, assetclass.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, assetclass.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, assetclass.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, assetclass.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, assetclass.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, assetclass.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, assetclass.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, assetclass.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, assetclass.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, assetclass.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, assetclass.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, assetclass.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, assetclass.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, assetclass.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, assetclass.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, assetclass.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, assetclass.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, assetclass.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, assetclass.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, assetclass.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, assetclass.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, assetclass.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, assetclass.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, assetclass.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, assetclass.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, assetclass.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, assetclass.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, assetclass.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, assetclass.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, assetclass.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, assetclass.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, assetclass.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, assetclass.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, assetclass.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, assetclass.DeletedAtNotNil())
	}
	if i.Value != nil {
		predicates = append(predicates, assetclass.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, assetclass.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, assetclass.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, assetclass.ValueNotIn(i.ValueNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, assetclass.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, assetclass.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, assetclass.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, assetclass.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, assetclass.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, assetclass.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, assetclass.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, assetclass.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, assetclass.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, assetclass.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, assetclass.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, assetclass.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, assetclass.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, assetclass.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, assetclass.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasAssets != nil {
		p := assetclass.HasAssets()
		if !*i.HasAssets {
			p = assetclass.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetsWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasAssetsWith))
		for _, w := range i.HasAssetsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, assetclass.HasAssetsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAssetClassWhereInput
	case 1:
		return predicates[0], nil
	default:
		return assetclass.And(predicates...), nil
	}
}

// AuthRoleWhereInput represents a where input for filtering AuthRole queries.
type AuthRoleWhereInput struct {
	Predicates []predicate.AuthRole  `json:"-"`
	Not        *AuthRoleWhereInput   `json:"not,omitempty"`
	Or         []*AuthRoleWhereInput `json:"or,omitempty"`
	And        []*AuthRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "value" field predicates.
	Value      *authrole.Value  `json:"value,omitempty"`
	ValueNEQ   *authrole.Value  `json:"valueNEQ,omitempty"`
	ValueIn    []authrole.Value `json:"valueIn,omitempty"`
	ValueNotIn []authrole.Value `json:"valueNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "accounts" edge predicates.
	HasAccounts     *bool                `json:"hasAccounts,omitempty"`
	HasAccountsWith []*AccountWhereInput `json:"hasAccountsWith,omitempty"`

	// "staff_accounts" edge predicates.
	HasStaffAccounts     *bool                     `json:"hasStaffAccounts,omitempty"`
	HasStaffAccountsWith []*StaffAccountWhereInput `json:"hasStaffAccountsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuthRoleWhereInput) AddPredicates(predicates ...predicate.AuthRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuthRoleWhereInput filter on the AuthRoleQuery builder.
func (i *AuthRoleWhereInput) Filter(q *AuthRoleQuery) (*AuthRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuthRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuthRoleWhereInput is returned in case the AuthRoleWhereInput is empty.
var ErrEmptyAuthRoleWhereInput = errors.New("ent: empty predicate AuthRoleWhereInput")

// P returns a predicate for filtering authroles.
// An error is returned if the input is empty or invalid.
func (i *AuthRoleWhereInput) P() (predicate.AuthRole, error) {
	var predicates []predicate.AuthRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, authrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuthRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, authrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuthRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, authrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, authrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, authrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, authrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, authrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, authrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, authrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, authrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, authrole.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, authrole.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, authrole.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, authrole.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, authrole.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, authrole.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, authrole.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, authrole.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, authrole.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, authrole.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, authrole.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, authrole.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, authrole.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, authrole.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, authrole.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, authrole.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, authrole.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, authrole.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, authrole.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, authrole.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, authrole.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, authrole.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, authrole.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, authrole.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, authrole.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, authrole.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, authrole.DeletedAtNotNil())
	}
	if i.Value != nil {
		predicates = append(predicates, authrole.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, authrole.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, authrole.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, authrole.ValueNotIn(i.ValueNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, authrole.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, authrole.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, authrole.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, authrole.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, authrole.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, authrole.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, authrole.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, authrole.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, authrole.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, authrole.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, authrole.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, authrole.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, authrole.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, authrole.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, authrole.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasAccounts != nil {
		p := authrole.HasAccounts()
		if !*i.HasAccounts {
			p = authrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountsWith) > 0 {
		with := make([]predicate.Account, 0, len(i.HasAccountsWith))
		for _, w := range i.HasAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authrole.HasAccountsWith(with...))
	}
	if i.HasStaffAccounts != nil {
		p := authrole.HasStaffAccounts()
		if !*i.HasStaffAccounts {
			p = authrole.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStaffAccountsWith) > 0 {
		with := make([]predicate.StaffAccount, 0, len(i.HasStaffAccountsWith))
		for _, w := range i.HasStaffAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStaffAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authrole.HasStaffAccountsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuthRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return authrole.And(predicates...), nil
	}
}

// AuthTypeWhereInput represents a where input for filtering AuthType queries.
type AuthTypeWhereInput struct {
	Predicates []predicate.AuthType  `json:"-"`
	Not        *AuthTypeWhereInput   `json:"not,omitempty"`
	Or         []*AuthTypeWhereInput `json:"or,omitempty"`
	And        []*AuthTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "value" field predicates.
	Value      *authtype.Value  `json:"value,omitempty"`
	ValueNEQ   *authtype.Value  `json:"valueNEQ,omitempty"`
	ValueIn    []authtype.Value `json:"valueIn,omitempty"`
	ValueNotIn []authtype.Value `json:"valueNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "accounts" edge predicates.
	HasAccounts     *bool                `json:"hasAccounts,omitempty"`
	HasAccountsWith []*AccountWhereInput `json:"hasAccountsWith,omitempty"`

	// "staff_accounts" edge predicates.
	HasStaffAccounts     *bool                     `json:"hasStaffAccounts,omitempty"`
	HasStaffAccountsWith []*StaffAccountWhereInput `json:"hasStaffAccountsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuthTypeWhereInput) AddPredicates(predicates ...predicate.AuthType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuthTypeWhereInput filter on the AuthTypeQuery builder.
func (i *AuthTypeWhereInput) Filter(q *AuthTypeQuery) (*AuthTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuthTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuthTypeWhereInput is returned in case the AuthTypeWhereInput is empty.
var ErrEmptyAuthTypeWhereInput = errors.New("ent: empty predicate AuthTypeWhereInput")

// P returns a predicate for filtering authtypes.
// An error is returned if the input is empty or invalid.
func (i *AuthTypeWhereInput) P() (predicate.AuthType, error) {
	var predicates []predicate.AuthType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, authtype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuthType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, authtype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuthType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, authtype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, authtype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, authtype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, authtype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, authtype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, authtype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, authtype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, authtype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, authtype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, authtype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, authtype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, authtype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, authtype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, authtype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, authtype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, authtype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, authtype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, authtype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, authtype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, authtype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, authtype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, authtype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, authtype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, authtype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, authtype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, authtype.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, authtype.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, authtype.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, authtype.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, authtype.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, authtype.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, authtype.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, authtype.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, authtype.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, authtype.DeletedAtNotNil())
	}
	if i.Value != nil {
		predicates = append(predicates, authtype.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, authtype.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, authtype.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, authtype.ValueNotIn(i.ValueNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, authtype.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, authtype.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, authtype.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, authtype.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, authtype.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, authtype.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, authtype.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, authtype.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, authtype.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, authtype.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, authtype.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, authtype.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, authtype.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, authtype.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, authtype.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasAccounts != nil {
		p := authtype.HasAccounts()
		if !*i.HasAccounts {
			p = authtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountsWith) > 0 {
		with := make([]predicate.Account, 0, len(i.HasAccountsWith))
		for _, w := range i.HasAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authtype.HasAccountsWith(with...))
	}
	if i.HasStaffAccounts != nil {
		p := authtype.HasStaffAccounts()
		if !*i.HasStaffAccounts {
			p = authtype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStaffAccountsWith) > 0 {
		with := make([]predicate.StaffAccount, 0, len(i.HasStaffAccountsWith))
		for _, w := range i.HasStaffAccountsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStaffAccountsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, authtype.HasStaffAccountsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuthTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return authtype.And(predicates...), nil
	}
}

// BlockchainWhereInput represents a where input for filtering Blockchain queries.
type BlockchainWhereInput struct {
	Predicates []predicate.Blockchain  `json:"-"`
	Not        *BlockchainWhereInput   `json:"not,omitempty"`
	Or         []*BlockchainWhereInput `json:"or,omitempty"`
	And        []*BlockchainWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "symbol" field predicates.
	Symbol             *string  `json:"symbol,omitempty"`
	SymbolNEQ          *string  `json:"symbolNEQ,omitempty"`
	SymbolIn           []string `json:"symbolIn,omitempty"`
	SymbolNotIn        []string `json:"symbolNotIn,omitempty"`
	SymbolGT           *string  `json:"symbolGT,omitempty"`
	SymbolGTE          *string  `json:"symbolGTE,omitempty"`
	SymbolLT           *string  `json:"symbolLT,omitempty"`
	SymbolLTE          *string  `json:"symbolLTE,omitempty"`
	SymbolContains     *string  `json:"symbolContains,omitempty"`
	SymbolHasPrefix    *string  `json:"symbolHasPrefix,omitempty"`
	SymbolHasSuffix    *string  `json:"symbolHasSuffix,omitempty"`
	SymbolEqualFold    *string  `json:"symbolEqualFold,omitempty"`
	SymbolContainsFold *string  `json:"symbolContainsFold,omitempty"`

	// "icon" field predicates.
	Icon             *string  `json:"icon,omitempty"`
	IconNEQ          *string  `json:"iconNEQ,omitempty"`
	IconIn           []string `json:"iconIn,omitempty"`
	IconNotIn        []string `json:"iconNotIn,omitempty"`
	IconGT           *string  `json:"iconGT,omitempty"`
	IconGTE          *string  `json:"iconGTE,omitempty"`
	IconLT           *string  `json:"iconLT,omitempty"`
	IconLTE          *string  `json:"iconLTE,omitempty"`
	IconContains     *string  `json:"iconContains,omitempty"`
	IconHasPrefix    *string  `json:"iconHasPrefix,omitempty"`
	IconHasSuffix    *string  `json:"iconHasSuffix,omitempty"`
	IconIsNil        bool     `json:"iconIsNil,omitempty"`
	IconNotNil       bool     `json:"iconNotNil,omitempty"`
	IconEqualFold    *string  `json:"iconEqualFold,omitempty"`
	IconContainsFold *string  `json:"iconContainsFold,omitempty"`

	// "chain_id" field predicates.
	ChainID       *int64  `json:"chainID,omitempty"`
	ChainIDNEQ    *int64  `json:"chainIDNEQ,omitempty"`
	ChainIDIn     []int64 `json:"chainIDIn,omitempty"`
	ChainIDNotIn  []int64 `json:"chainIDNotIn,omitempty"`
	ChainIDGT     *int64  `json:"chainIDGT,omitempty"`
	ChainIDGTE    *int64  `json:"chainIDGTE,omitempty"`
	ChainIDLT     *int64  `json:"chainIDLT,omitempty"`
	ChainIDLTE    *int64  `json:"chainIDLTE,omitempty"`
	ChainIDIsNil  bool    `json:"chainIDIsNil,omitempty"`
	ChainIDNotNil bool    `json:"chainIDNotNil,omitempty"`

	// "cryptocurrencies" edge predicates.
	HasCryptocurrencies     *bool                       `json:"hasCryptocurrencies,omitempty"`
	HasCryptocurrenciesWith []*CryptocurrencyWhereInput `json:"hasCryptocurrenciesWith,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BlockchainWhereInput) AddPredicates(predicates ...predicate.Blockchain) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BlockchainWhereInput filter on the BlockchainQuery builder.
func (i *BlockchainWhereInput) Filter(q *BlockchainQuery) (*BlockchainQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBlockchainWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBlockchainWhereInput is returned in case the BlockchainWhereInput is empty.
var ErrEmptyBlockchainWhereInput = errors.New("ent: empty predicate BlockchainWhereInput")

// P returns a predicate for filtering blockchains.
// An error is returned if the input is empty or invalid.
func (i *BlockchainWhereInput) P() (predicate.Blockchain, error) {
	var predicates []predicate.Blockchain
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, blockchain.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Blockchain, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, blockchain.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Blockchain, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, blockchain.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, blockchain.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, blockchain.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, blockchain.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, blockchain.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, blockchain.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, blockchain.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, blockchain.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, blockchain.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, blockchain.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, blockchain.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, blockchain.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, blockchain.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, blockchain.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, blockchain.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, blockchain.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, blockchain.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, blockchain.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, blockchain.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, blockchain.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, blockchain.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, blockchain.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, blockchain.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, blockchain.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, blockchain.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, blockchain.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, blockchain.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, blockchain.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, blockchain.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, blockchain.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, blockchain.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, blockchain.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, blockchain.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, blockchain.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, blockchain.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, blockchain.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, blockchain.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, blockchain.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, blockchain.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, blockchain.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, blockchain.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, blockchain.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, blockchain.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, blockchain.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, blockchain.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, blockchain.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, blockchain.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, blockchain.NameContainsFold(*i.NameContainsFold))
	}
	if i.Symbol != nil {
		predicates = append(predicates, blockchain.SymbolEQ(*i.Symbol))
	}
	if i.SymbolNEQ != nil {
		predicates = append(predicates, blockchain.SymbolNEQ(*i.SymbolNEQ))
	}
	if len(i.SymbolIn) > 0 {
		predicates = append(predicates, blockchain.SymbolIn(i.SymbolIn...))
	}
	if len(i.SymbolNotIn) > 0 {
		predicates = append(predicates, blockchain.SymbolNotIn(i.SymbolNotIn...))
	}
	if i.SymbolGT != nil {
		predicates = append(predicates, blockchain.SymbolGT(*i.SymbolGT))
	}
	if i.SymbolGTE != nil {
		predicates = append(predicates, blockchain.SymbolGTE(*i.SymbolGTE))
	}
	if i.SymbolLT != nil {
		predicates = append(predicates, blockchain.SymbolLT(*i.SymbolLT))
	}
	if i.SymbolLTE != nil {
		predicates = append(predicates, blockchain.SymbolLTE(*i.SymbolLTE))
	}
	if i.SymbolContains != nil {
		predicates = append(predicates, blockchain.SymbolContains(*i.SymbolContains))
	}
	if i.SymbolHasPrefix != nil {
		predicates = append(predicates, blockchain.SymbolHasPrefix(*i.SymbolHasPrefix))
	}
	if i.SymbolHasSuffix != nil {
		predicates = append(predicates, blockchain.SymbolHasSuffix(*i.SymbolHasSuffix))
	}
	if i.SymbolEqualFold != nil {
		predicates = append(predicates, blockchain.SymbolEqualFold(*i.SymbolEqualFold))
	}
	if i.SymbolContainsFold != nil {
		predicates = append(predicates, blockchain.SymbolContainsFold(*i.SymbolContainsFold))
	}
	if i.Icon != nil {
		predicates = append(predicates, blockchain.IconEQ(*i.Icon))
	}
	if i.IconNEQ != nil {
		predicates = append(predicates, blockchain.IconNEQ(*i.IconNEQ))
	}
	if len(i.IconIn) > 0 {
		predicates = append(predicates, blockchain.IconIn(i.IconIn...))
	}
	if len(i.IconNotIn) > 0 {
		predicates = append(predicates, blockchain.IconNotIn(i.IconNotIn...))
	}
	if i.IconGT != nil {
		predicates = append(predicates, blockchain.IconGT(*i.IconGT))
	}
	if i.IconGTE != nil {
		predicates = append(predicates, blockchain.IconGTE(*i.IconGTE))
	}
	if i.IconLT != nil {
		predicates = append(predicates, blockchain.IconLT(*i.IconLT))
	}
	if i.IconLTE != nil {
		predicates = append(predicates, blockchain.IconLTE(*i.IconLTE))
	}
	if i.IconContains != nil {
		predicates = append(predicates, blockchain.IconContains(*i.IconContains))
	}
	if i.IconHasPrefix != nil {
		predicates = append(predicates, blockchain.IconHasPrefix(*i.IconHasPrefix))
	}
	if i.IconHasSuffix != nil {
		predicates = append(predicates, blockchain.IconHasSuffix(*i.IconHasSuffix))
	}
	if i.IconIsNil {
		predicates = append(predicates, blockchain.IconIsNil())
	}
	if i.IconNotNil {
		predicates = append(predicates, blockchain.IconNotNil())
	}
	if i.IconEqualFold != nil {
		predicates = append(predicates, blockchain.IconEqualFold(*i.IconEqualFold))
	}
	if i.IconContainsFold != nil {
		predicates = append(predicates, blockchain.IconContainsFold(*i.IconContainsFold))
	}
	if i.ChainID != nil {
		predicates = append(predicates, blockchain.ChainIDEQ(*i.ChainID))
	}
	if i.ChainIDNEQ != nil {
		predicates = append(predicates, blockchain.ChainIDNEQ(*i.ChainIDNEQ))
	}
	if len(i.ChainIDIn) > 0 {
		predicates = append(predicates, blockchain.ChainIDIn(i.ChainIDIn...))
	}
	if len(i.ChainIDNotIn) > 0 {
		predicates = append(predicates, blockchain.ChainIDNotIn(i.ChainIDNotIn...))
	}
	if i.ChainIDGT != nil {
		predicates = append(predicates, blockchain.ChainIDGT(*i.ChainIDGT))
	}
	if i.ChainIDGTE != nil {
		predicates = append(predicates, blockchain.ChainIDGTE(*i.ChainIDGTE))
	}
	if i.ChainIDLT != nil {
		predicates = append(predicates, blockchain.ChainIDLT(*i.ChainIDLT))
	}
	if i.ChainIDLTE != nil {
		predicates = append(predicates, blockchain.ChainIDLTE(*i.ChainIDLTE))
	}
	if i.ChainIDIsNil {
		predicates = append(predicates, blockchain.ChainIDIsNil())
	}
	if i.ChainIDNotNil {
		predicates = append(predicates, blockchain.ChainIDNotNil())
	}

	if i.HasCryptocurrencies != nil {
		p := blockchain.HasCryptocurrencies()
		if !*i.HasCryptocurrencies {
			p = blockchain.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCryptocurrenciesWith) > 0 {
		with := make([]predicate.Cryptocurrency, 0, len(i.HasCryptocurrenciesWith))
		for _, w := range i.HasCryptocurrenciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCryptocurrenciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, blockchain.HasCryptocurrenciesWith(with...))
	}
	if i.HasTransactions != nil {
		p := blockchain.HasTransactions()
		if !*i.HasTransactions {
			p = blockchain.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, blockchain.HasTransactionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBlockchainWhereInput
	case 1:
		return predicates[0], nil
	default:
		return blockchain.And(predicates...), nil
	}
}

// ConnectionWhereInput represents a where input for filtering Connection queries.
type ConnectionWhereInput struct {
	Predicates []predicate.Connection  `json:"-"`
	Not        *ConnectionWhereInput   `json:"not,omitempty"`
	Or         []*ConnectionWhereInput `json:"or,omitempty"`
	And        []*ConnectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "access_token" field predicates.
	AccessToken             *string  `json:"accessToken,omitempty"`
	AccessTokenNEQ          *string  `json:"accessTokenNEQ,omitempty"`
	AccessTokenIn           []string `json:"accessTokenIn,omitempty"`
	AccessTokenNotIn        []string `json:"accessTokenNotIn,omitempty"`
	AccessTokenGT           *string  `json:"accessTokenGT,omitempty"`
	AccessTokenGTE          *string  `json:"accessTokenGTE,omitempty"`
	AccessTokenLT           *string  `json:"accessTokenLT,omitempty"`
	AccessTokenLTE          *string  `json:"accessTokenLTE,omitempty"`
	AccessTokenContains     *string  `json:"accessTokenContains,omitempty"`
	AccessTokenHasPrefix    *string  `json:"accessTokenHasPrefix,omitempty"`
	AccessTokenHasSuffix    *string  `json:"accessTokenHasSuffix,omitempty"`
	AccessTokenEqualFold    *string  `json:"accessTokenEqualFold,omitempty"`
	AccessTokenContainsFold *string  `json:"accessTokenContainsFold,omitempty"`

	// "account_id" field predicates.
	AccountID             *pulid.PULID  `json:"accountID,omitempty"`
	AccountIDNEQ          *pulid.PULID  `json:"accountIDNEQ,omitempty"`
	AccountIDIn           []pulid.PULID `json:"accountIDIn,omitempty"`
	AccountIDNotIn        []pulid.PULID `json:"accountIDNotIn,omitempty"`
	AccountIDGT           *pulid.PULID  `json:"accountIDGT,omitempty"`
	AccountIDGTE          *pulid.PULID  `json:"accountIDGTE,omitempty"`
	AccountIDLT           *pulid.PULID  `json:"accountIDLT,omitempty"`
	AccountIDLTE          *pulid.PULID  `json:"accountIDLTE,omitempty"`
	AccountIDContains     *pulid.PULID  `json:"accountIDContains,omitempty"`
	AccountIDHasPrefix    *pulid.PULID  `json:"accountIDHasPrefix,omitempty"`
	AccountIDHasSuffix    *pulid.PULID  `json:"accountIDHasSuffix,omitempty"`
	AccountIDEqualFold    *pulid.PULID  `json:"accountIDEqualFold,omitempty"`
	AccountIDContainsFold *pulid.PULID  `json:"accountIDContainsFold,omitempty"`

	// "account" edge predicates.
	HasAccount     *bool                `json:"hasAccount,omitempty"`
	HasAccountWith []*AccountWhereInput `json:"hasAccountWith,omitempty"`

	// "portfolios" edge predicates.
	HasPortfolios     *bool                  `json:"hasPortfolios,omitempty"`
	HasPortfoliosWith []*PortfolioWhereInput `json:"hasPortfoliosWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectionWhereInput) AddPredicates(predicates ...predicate.Connection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectionWhereInput filter on the ConnectionQuery builder.
func (i *ConnectionWhereInput) Filter(q *ConnectionQuery) (*ConnectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectionWhereInput is returned in case the ConnectionWhereInput is empty.
var ErrEmptyConnectionWhereInput = errors.New("ent: empty predicate ConnectionWhereInput")

// P returns a predicate for filtering connections.
// An error is returned if the input is empty or invalid.
func (i *ConnectionWhereInput) P() (predicate.Connection, error) {
	var predicates []predicate.Connection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Connection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Connection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connection.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, connection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, connection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, connection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, connection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, connection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, connection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, connection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, connection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, connection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, connection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, connection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, connection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, connection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, connection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, connection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, connection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, connection.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, connection.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, connection.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, connection.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, connection.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, connection.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, connection.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, connection.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, connection.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, connection.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, connection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, connection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, connection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, connection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, connection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, connection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, connection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, connection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, connection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, connection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, connection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, connection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, connection.NameContainsFold(*i.NameContainsFold))
	}
	if i.AccessToken != nil {
		predicates = append(predicates, connection.AccessTokenEQ(*i.AccessToken))
	}
	if i.AccessTokenNEQ != nil {
		predicates = append(predicates, connection.AccessTokenNEQ(*i.AccessTokenNEQ))
	}
	if len(i.AccessTokenIn) > 0 {
		predicates = append(predicates, connection.AccessTokenIn(i.AccessTokenIn...))
	}
	if len(i.AccessTokenNotIn) > 0 {
		predicates = append(predicates, connection.AccessTokenNotIn(i.AccessTokenNotIn...))
	}
	if i.AccessTokenGT != nil {
		predicates = append(predicates, connection.AccessTokenGT(*i.AccessTokenGT))
	}
	if i.AccessTokenGTE != nil {
		predicates = append(predicates, connection.AccessTokenGTE(*i.AccessTokenGTE))
	}
	if i.AccessTokenLT != nil {
		predicates = append(predicates, connection.AccessTokenLT(*i.AccessTokenLT))
	}
	if i.AccessTokenLTE != nil {
		predicates = append(predicates, connection.AccessTokenLTE(*i.AccessTokenLTE))
	}
	if i.AccessTokenContains != nil {
		predicates = append(predicates, connection.AccessTokenContains(*i.AccessTokenContains))
	}
	if i.AccessTokenHasPrefix != nil {
		predicates = append(predicates, connection.AccessTokenHasPrefix(*i.AccessTokenHasPrefix))
	}
	if i.AccessTokenHasSuffix != nil {
		predicates = append(predicates, connection.AccessTokenHasSuffix(*i.AccessTokenHasSuffix))
	}
	if i.AccessTokenEqualFold != nil {
		predicates = append(predicates, connection.AccessTokenEqualFold(*i.AccessTokenEqualFold))
	}
	if i.AccessTokenContainsFold != nil {
		predicates = append(predicates, connection.AccessTokenContainsFold(*i.AccessTokenContainsFold))
	}
	if i.AccountID != nil {
		predicates = append(predicates, connection.AccountIDEQ(*i.AccountID))
	}
	if i.AccountIDNEQ != nil {
		predicates = append(predicates, connection.AccountIDNEQ(*i.AccountIDNEQ))
	}
	if len(i.AccountIDIn) > 0 {
		predicates = append(predicates, connection.AccountIDIn(i.AccountIDIn...))
	}
	if len(i.AccountIDNotIn) > 0 {
		predicates = append(predicates, connection.AccountIDNotIn(i.AccountIDNotIn...))
	}
	if i.AccountIDGT != nil {
		predicates = append(predicates, connection.AccountIDGT(*i.AccountIDGT))
	}
	if i.AccountIDGTE != nil {
		predicates = append(predicates, connection.AccountIDGTE(*i.AccountIDGTE))
	}
	if i.AccountIDLT != nil {
		predicates = append(predicates, connection.AccountIDLT(*i.AccountIDLT))
	}
	if i.AccountIDLTE != nil {
		predicates = append(predicates, connection.AccountIDLTE(*i.AccountIDLTE))
	}
	if i.AccountIDContains != nil {
		predicates = append(predicates, connection.AccountIDContains(*i.AccountIDContains))
	}
	if i.AccountIDHasPrefix != nil {
		predicates = append(predicates, connection.AccountIDHasPrefix(*i.AccountIDHasPrefix))
	}
	if i.AccountIDHasSuffix != nil {
		predicates = append(predicates, connection.AccountIDHasSuffix(*i.AccountIDHasSuffix))
	}
	if i.AccountIDEqualFold != nil {
		predicates = append(predicates, connection.AccountIDEqualFold(*i.AccountIDEqualFold))
	}
	if i.AccountIDContainsFold != nil {
		predicates = append(predicates, connection.AccountIDContainsFold(*i.AccountIDContainsFold))
	}

	if i.HasAccount != nil {
		p := connection.HasAccount()
		if !*i.HasAccount {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountWith) > 0 {
		with := make([]predicate.Account, 0, len(i.HasAccountWith))
		for _, w := range i.HasAccountWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasAccountWith(with...))
	}
	if i.HasPortfolios != nil {
		p := connection.HasPortfolios()
		if !*i.HasPortfolios {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPortfoliosWith) > 0 {
		with := make([]predicate.Portfolio, 0, len(i.HasPortfoliosWith))
		for _, w := range i.HasPortfoliosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPortfoliosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasPortfoliosWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connection.And(predicates...), nil
	}
}

// CryptocurrencyWhereInput represents a where input for filtering Cryptocurrency queries.
type CryptocurrencyWhereInput struct {
	Predicates []predicate.Cryptocurrency  `json:"-"`
	Not        *CryptocurrencyWhereInput   `json:"not,omitempty"`
	Or         []*CryptocurrencyWhereInput `json:"or,omitempty"`
	And        []*CryptocurrencyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "symbol" field predicates.
	Symbol             *string  `json:"symbol,omitempty"`
	SymbolNEQ          *string  `json:"symbolNEQ,omitempty"`
	SymbolIn           []string `json:"symbolIn,omitempty"`
	SymbolNotIn        []string `json:"symbolNotIn,omitempty"`
	SymbolGT           *string  `json:"symbolGT,omitempty"`
	SymbolGTE          *string  `json:"symbolGTE,omitempty"`
	SymbolLT           *string  `json:"symbolLT,omitempty"`
	SymbolLTE          *string  `json:"symbolLTE,omitempty"`
	SymbolContains     *string  `json:"symbolContains,omitempty"`
	SymbolHasPrefix    *string  `json:"symbolHasPrefix,omitempty"`
	SymbolHasSuffix    *string  `json:"symbolHasSuffix,omitempty"`
	SymbolEqualFold    *string  `json:"symbolEqualFold,omitempty"`
	SymbolContainsFold *string  `json:"symbolContainsFold,omitempty"`

	// "icon" field predicates.
	Icon             *string  `json:"icon,omitempty"`
	IconNEQ          *string  `json:"iconNEQ,omitempty"`
	IconIn           []string `json:"iconIn,omitempty"`
	IconNotIn        []string `json:"iconNotIn,omitempty"`
	IconGT           *string  `json:"iconGT,omitempty"`
	IconGTE          *string  `json:"iconGTE,omitempty"`
	IconLT           *string  `json:"iconLT,omitempty"`
	IconLTE          *string  `json:"iconLTE,omitempty"`
	IconContains     *string  `json:"iconContains,omitempty"`
	IconHasPrefix    *string  `json:"iconHasPrefix,omitempty"`
	IconHasSuffix    *string  `json:"iconHasSuffix,omitempty"`
	IconIsNil        bool     `json:"iconIsNil,omitempty"`
	IconNotNil       bool     `json:"iconNotNil,omitempty"`
	IconEqualFold    *string  `json:"iconEqualFold,omitempty"`
	IconContainsFold *string  `json:"iconContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "asset_id" field predicates.
	AssetID             *pulid.PULID  `json:"assetID,omitempty"`
	AssetIDNEQ          *pulid.PULID  `json:"assetIDNEQ,omitempty"`
	AssetIDIn           []pulid.PULID `json:"assetIDIn,omitempty"`
	AssetIDNotIn        []pulid.PULID `json:"assetIDNotIn,omitempty"`
	AssetIDGT           *pulid.PULID  `json:"assetIDGT,omitempty"`
	AssetIDGTE          *pulid.PULID  `json:"assetIDGTE,omitempty"`
	AssetIDLT           *pulid.PULID  `json:"assetIDLT,omitempty"`
	AssetIDLTE          *pulid.PULID  `json:"assetIDLTE,omitempty"`
	AssetIDContains     *pulid.PULID  `json:"assetIDContains,omitempty"`
	AssetIDHasPrefix    *pulid.PULID  `json:"assetIDHasPrefix,omitempty"`
	AssetIDHasSuffix    *pulid.PULID  `json:"assetIDHasSuffix,omitempty"`
	AssetIDEqualFold    *pulid.PULID  `json:"assetIDEqualFold,omitempty"`
	AssetIDContainsFold *pulid.PULID  `json:"assetIDContainsFold,omitempty"`

	// "asset" edge predicates.
	HasAsset     *bool              `json:"hasAsset,omitempty"`
	HasAssetWith []*AssetWhereInput `json:"hasAssetWith,omitempty"`

	// "blockchains" edge predicates.
	HasBlockchains     *bool                   `json:"hasBlockchains,omitempty"`
	HasBlockchainsWith []*BlockchainWhereInput `json:"hasBlockchainsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CryptocurrencyWhereInput) AddPredicates(predicates ...predicate.Cryptocurrency) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CryptocurrencyWhereInput filter on the CryptocurrencyQuery builder.
func (i *CryptocurrencyWhereInput) Filter(q *CryptocurrencyQuery) (*CryptocurrencyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCryptocurrencyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCryptocurrencyWhereInput is returned in case the CryptocurrencyWhereInput is empty.
var ErrEmptyCryptocurrencyWhereInput = errors.New("ent: empty predicate CryptocurrencyWhereInput")

// P returns a predicate for filtering cryptocurrencies.
// An error is returned if the input is empty or invalid.
func (i *CryptocurrencyWhereInput) P() (predicate.Cryptocurrency, error) {
	var predicates []predicate.Cryptocurrency
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, cryptocurrency.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Cryptocurrency, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, cryptocurrency.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Cryptocurrency, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, cryptocurrency.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, cryptocurrency.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, cryptocurrency.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, cryptocurrency.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, cryptocurrency.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, cryptocurrency.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, cryptocurrency.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, cryptocurrency.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, cryptocurrency.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, cryptocurrency.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, cryptocurrency.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, cryptocurrency.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, cryptocurrency.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, cryptocurrency.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, cryptocurrency.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, cryptocurrency.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, cryptocurrency.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, cryptocurrency.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, cryptocurrency.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, cryptocurrency.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, cryptocurrency.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, cryptocurrency.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, cryptocurrency.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, cryptocurrency.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, cryptocurrency.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, cryptocurrency.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, cryptocurrency.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, cryptocurrency.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, cryptocurrency.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, cryptocurrency.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, cryptocurrency.DeletedAtNotNil())
	}
	if i.Symbol != nil {
		predicates = append(predicates, cryptocurrency.SymbolEQ(*i.Symbol))
	}
	if i.SymbolNEQ != nil {
		predicates = append(predicates, cryptocurrency.SymbolNEQ(*i.SymbolNEQ))
	}
	if len(i.SymbolIn) > 0 {
		predicates = append(predicates, cryptocurrency.SymbolIn(i.SymbolIn...))
	}
	if len(i.SymbolNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.SymbolNotIn(i.SymbolNotIn...))
	}
	if i.SymbolGT != nil {
		predicates = append(predicates, cryptocurrency.SymbolGT(*i.SymbolGT))
	}
	if i.SymbolGTE != nil {
		predicates = append(predicates, cryptocurrency.SymbolGTE(*i.SymbolGTE))
	}
	if i.SymbolLT != nil {
		predicates = append(predicates, cryptocurrency.SymbolLT(*i.SymbolLT))
	}
	if i.SymbolLTE != nil {
		predicates = append(predicates, cryptocurrency.SymbolLTE(*i.SymbolLTE))
	}
	if i.SymbolContains != nil {
		predicates = append(predicates, cryptocurrency.SymbolContains(*i.SymbolContains))
	}
	if i.SymbolHasPrefix != nil {
		predicates = append(predicates, cryptocurrency.SymbolHasPrefix(*i.SymbolHasPrefix))
	}
	if i.SymbolHasSuffix != nil {
		predicates = append(predicates, cryptocurrency.SymbolHasSuffix(*i.SymbolHasSuffix))
	}
	if i.SymbolEqualFold != nil {
		predicates = append(predicates, cryptocurrency.SymbolEqualFold(*i.SymbolEqualFold))
	}
	if i.SymbolContainsFold != nil {
		predicates = append(predicates, cryptocurrency.SymbolContainsFold(*i.SymbolContainsFold))
	}
	if i.Icon != nil {
		predicates = append(predicates, cryptocurrency.IconEQ(*i.Icon))
	}
	if i.IconNEQ != nil {
		predicates = append(predicates, cryptocurrency.IconNEQ(*i.IconNEQ))
	}
	if len(i.IconIn) > 0 {
		predicates = append(predicates, cryptocurrency.IconIn(i.IconIn...))
	}
	if len(i.IconNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.IconNotIn(i.IconNotIn...))
	}
	if i.IconGT != nil {
		predicates = append(predicates, cryptocurrency.IconGT(*i.IconGT))
	}
	if i.IconGTE != nil {
		predicates = append(predicates, cryptocurrency.IconGTE(*i.IconGTE))
	}
	if i.IconLT != nil {
		predicates = append(predicates, cryptocurrency.IconLT(*i.IconLT))
	}
	if i.IconLTE != nil {
		predicates = append(predicates, cryptocurrency.IconLTE(*i.IconLTE))
	}
	if i.IconContains != nil {
		predicates = append(predicates, cryptocurrency.IconContains(*i.IconContains))
	}
	if i.IconHasPrefix != nil {
		predicates = append(predicates, cryptocurrency.IconHasPrefix(*i.IconHasPrefix))
	}
	if i.IconHasSuffix != nil {
		predicates = append(predicates, cryptocurrency.IconHasSuffix(*i.IconHasSuffix))
	}
	if i.IconIsNil {
		predicates = append(predicates, cryptocurrency.IconIsNil())
	}
	if i.IconNotNil {
		predicates = append(predicates, cryptocurrency.IconNotNil())
	}
	if i.IconEqualFold != nil {
		predicates = append(predicates, cryptocurrency.IconEqualFold(*i.IconEqualFold))
	}
	if i.IconContainsFold != nil {
		predicates = append(predicates, cryptocurrency.IconContainsFold(*i.IconContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, cryptocurrency.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, cryptocurrency.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, cryptocurrency.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, cryptocurrency.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, cryptocurrency.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, cryptocurrency.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, cryptocurrency.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, cryptocurrency.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, cryptocurrency.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, cryptocurrency.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, cryptocurrency.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, cryptocurrency.NameContainsFold(*i.NameContainsFold))
	}
	if i.AssetID != nil {
		predicates = append(predicates, cryptocurrency.AssetIDEQ(*i.AssetID))
	}
	if i.AssetIDNEQ != nil {
		predicates = append(predicates, cryptocurrency.AssetIDNEQ(*i.AssetIDNEQ))
	}
	if len(i.AssetIDIn) > 0 {
		predicates = append(predicates, cryptocurrency.AssetIDIn(i.AssetIDIn...))
	}
	if len(i.AssetIDNotIn) > 0 {
		predicates = append(predicates, cryptocurrency.AssetIDNotIn(i.AssetIDNotIn...))
	}
	if i.AssetIDGT != nil {
		predicates = append(predicates, cryptocurrency.AssetIDGT(*i.AssetIDGT))
	}
	if i.AssetIDGTE != nil {
		predicates = append(predicates, cryptocurrency.AssetIDGTE(*i.AssetIDGTE))
	}
	if i.AssetIDLT != nil {
		predicates = append(predicates, cryptocurrency.AssetIDLT(*i.AssetIDLT))
	}
	if i.AssetIDLTE != nil {
		predicates = append(predicates, cryptocurrency.AssetIDLTE(*i.AssetIDLTE))
	}
	if i.AssetIDContains != nil {
		predicates = append(predicates, cryptocurrency.AssetIDContains(*i.AssetIDContains))
	}
	if i.AssetIDHasPrefix != nil {
		predicates = append(predicates, cryptocurrency.AssetIDHasPrefix(*i.AssetIDHasPrefix))
	}
	if i.AssetIDHasSuffix != nil {
		predicates = append(predicates, cryptocurrency.AssetIDHasSuffix(*i.AssetIDHasSuffix))
	}
	if i.AssetIDEqualFold != nil {
		predicates = append(predicates, cryptocurrency.AssetIDEqualFold(*i.AssetIDEqualFold))
	}
	if i.AssetIDContainsFold != nil {
		predicates = append(predicates, cryptocurrency.AssetIDContainsFold(*i.AssetIDContainsFold))
	}

	if i.HasAsset != nil {
		p := cryptocurrency.HasAsset()
		if !*i.HasAsset {
			p = cryptocurrency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasAssetWith))
		for _, w := range i.HasAssetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cryptocurrency.HasAssetWith(with...))
	}
	if i.HasBlockchains != nil {
		p := cryptocurrency.HasBlockchains()
		if !*i.HasBlockchains {
			p = cryptocurrency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockchainsWith) > 0 {
		with := make([]predicate.Blockchain, 0, len(i.HasBlockchainsWith))
		for _, w := range i.HasBlockchainsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockchainsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, cryptocurrency.HasBlockchainsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCryptocurrencyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return cryptocurrency.And(predicates...), nil
	}
}

// DailyAssetPriceWhereInput represents a where input for filtering DailyAssetPrice queries.
type DailyAssetPriceWhereInput struct {
	Predicates []predicate.DailyAssetPrice  `json:"-"`
	Not        *DailyAssetPriceWhereInput   `json:"not,omitempty"`
	Or         []*DailyAssetPriceWhereInput `json:"or,omitempty"`
	And        []*DailyAssetPriceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "open" field predicates.
	Open       *float64  `json:"open,omitempty"`
	OpenNEQ    *float64  `json:"openNEQ,omitempty"`
	OpenIn     []float64 `json:"openIn,omitempty"`
	OpenNotIn  []float64 `json:"openNotIn,omitempty"`
	OpenGT     *float64  `json:"openGT,omitempty"`
	OpenGTE    *float64  `json:"openGTE,omitempty"`
	OpenLT     *float64  `json:"openLT,omitempty"`
	OpenLTE    *float64  `json:"openLTE,omitempty"`
	OpenIsNil  bool      `json:"openIsNil,omitempty"`
	OpenNotNil bool      `json:"openNotNil,omitempty"`

	// "high" field predicates.
	High       *float64  `json:"high,omitempty"`
	HighNEQ    *float64  `json:"highNEQ,omitempty"`
	HighIn     []float64 `json:"highIn,omitempty"`
	HighNotIn  []float64 `json:"highNotIn,omitempty"`
	HighGT     *float64  `json:"highGT,omitempty"`
	HighGTE    *float64  `json:"highGTE,omitempty"`
	HighLT     *float64  `json:"highLT,omitempty"`
	HighLTE    *float64  `json:"highLTE,omitempty"`
	HighIsNil  bool      `json:"highIsNil,omitempty"`
	HighNotNil bool      `json:"highNotNil,omitempty"`

	// "low" field predicates.
	Low       *float64  `json:"low,omitempty"`
	LowNEQ    *float64  `json:"lowNEQ,omitempty"`
	LowIn     []float64 `json:"lowIn,omitempty"`
	LowNotIn  []float64 `json:"lowNotIn,omitempty"`
	LowGT     *float64  `json:"lowGT,omitempty"`
	LowGTE    *float64  `json:"lowGTE,omitempty"`
	LowLT     *float64  `json:"lowLT,omitempty"`
	LowLTE    *float64  `json:"lowLTE,omitempty"`
	LowIsNil  bool      `json:"lowIsNil,omitempty"`
	LowNotNil bool      `json:"lowNotNil,omitempty"`

	// "close" field predicates.
	Close       *float64  `json:"close,omitempty"`
	CloseNEQ    *float64  `json:"closeNEQ,omitempty"`
	CloseIn     []float64 `json:"closeIn,omitempty"`
	CloseNotIn  []float64 `json:"closeNotIn,omitempty"`
	CloseGT     *float64  `json:"closeGT,omitempty"`
	CloseGTE    *float64  `json:"closeGTE,omitempty"`
	CloseLT     *float64  `json:"closeLT,omitempty"`
	CloseLTE    *float64  `json:"closeLTE,omitempty"`
	CloseIsNil  bool      `json:"closeIsNil,omitempty"`
	CloseNotNil bool      `json:"closeNotNil,omitempty"`

	// "adjusted_close" field predicates.
	AdjustedClose      *float64  `json:"adjustedClose,omitempty"`
	AdjustedCloseNEQ   *float64  `json:"adjustedCloseNEQ,omitempty"`
	AdjustedCloseIn    []float64 `json:"adjustedCloseIn,omitempty"`
	AdjustedCloseNotIn []float64 `json:"adjustedCloseNotIn,omitempty"`
	AdjustedCloseGT    *float64  `json:"adjustedCloseGT,omitempty"`
	AdjustedCloseGTE   *float64  `json:"adjustedCloseGTE,omitempty"`
	AdjustedCloseLT    *float64  `json:"adjustedCloseLT,omitempty"`
	AdjustedCloseLTE   *float64  `json:"adjustedCloseLTE,omitempty"`

	// "asset_id" field predicates.
	AssetID             *pulid.PULID  `json:"assetID,omitempty"`
	AssetIDNEQ          *pulid.PULID  `json:"assetIDNEQ,omitempty"`
	AssetIDIn           []pulid.PULID `json:"assetIDIn,omitempty"`
	AssetIDNotIn        []pulid.PULID `json:"assetIDNotIn,omitempty"`
	AssetIDGT           *pulid.PULID  `json:"assetIDGT,omitempty"`
	AssetIDGTE          *pulid.PULID  `json:"assetIDGTE,omitempty"`
	AssetIDLT           *pulid.PULID  `json:"assetIDLT,omitempty"`
	AssetIDLTE          *pulid.PULID  `json:"assetIDLTE,omitempty"`
	AssetIDContains     *pulid.PULID  `json:"assetIDContains,omitempty"`
	AssetIDHasPrefix    *pulid.PULID  `json:"assetIDHasPrefix,omitempty"`
	AssetIDHasSuffix    *pulid.PULID  `json:"assetIDHasSuffix,omitempty"`
	AssetIDEqualFold    *pulid.PULID  `json:"assetIDEqualFold,omitempty"`
	AssetIDContainsFold *pulid.PULID  `json:"assetIDContainsFold,omitempty"`

	// "asset" edge predicates.
	HasAsset     *bool              `json:"hasAsset,omitempty"`
	HasAssetWith []*AssetWhereInput `json:"hasAssetWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DailyAssetPriceWhereInput) AddPredicates(predicates ...predicate.DailyAssetPrice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DailyAssetPriceWhereInput filter on the DailyAssetPriceQuery builder.
func (i *DailyAssetPriceWhereInput) Filter(q *DailyAssetPriceQuery) (*DailyAssetPriceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDailyAssetPriceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDailyAssetPriceWhereInput is returned in case the DailyAssetPriceWhereInput is empty.
var ErrEmptyDailyAssetPriceWhereInput = errors.New("ent: empty predicate DailyAssetPriceWhereInput")

// P returns a predicate for filtering dailyassetprices.
// An error is returned if the input is empty or invalid.
func (i *DailyAssetPriceWhereInput) P() (predicate.DailyAssetPrice, error) {
	var predicates []predicate.DailyAssetPrice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dailyassetprice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DailyAssetPrice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dailyassetprice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DailyAssetPrice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dailyassetprice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dailyassetprice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dailyassetprice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dailyassetprice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dailyassetprice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dailyassetprice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dailyassetprice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dailyassetprice.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, dailyassetprice.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, dailyassetprice.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, dailyassetprice.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, dailyassetprice.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, dailyassetprice.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, dailyassetprice.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, dailyassetprice.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, dailyassetprice.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, dailyassetprice.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, dailyassetprice.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, dailyassetprice.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, dailyassetprice.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, dailyassetprice.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, dailyassetprice.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, dailyassetprice.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, dailyassetprice.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, dailyassetprice.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, dailyassetprice.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, dailyassetprice.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, dailyassetprice.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, dailyassetprice.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, dailyassetprice.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, dailyassetprice.DeletedAtNotNil())
	}
	if i.Time != nil {
		predicates = append(predicates, dailyassetprice.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, dailyassetprice.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, dailyassetprice.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, dailyassetprice.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, dailyassetprice.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, dailyassetprice.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, dailyassetprice.TimeLTE(*i.TimeLTE))
	}
	if i.Open != nil {
		predicates = append(predicates, dailyassetprice.OpenEQ(*i.Open))
	}
	if i.OpenNEQ != nil {
		predicates = append(predicates, dailyassetprice.OpenNEQ(*i.OpenNEQ))
	}
	if len(i.OpenIn) > 0 {
		predicates = append(predicates, dailyassetprice.OpenIn(i.OpenIn...))
	}
	if len(i.OpenNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.OpenNotIn(i.OpenNotIn...))
	}
	if i.OpenGT != nil {
		predicates = append(predicates, dailyassetprice.OpenGT(*i.OpenGT))
	}
	if i.OpenGTE != nil {
		predicates = append(predicates, dailyassetprice.OpenGTE(*i.OpenGTE))
	}
	if i.OpenLT != nil {
		predicates = append(predicates, dailyassetprice.OpenLT(*i.OpenLT))
	}
	if i.OpenLTE != nil {
		predicates = append(predicates, dailyassetprice.OpenLTE(*i.OpenLTE))
	}
	if i.OpenIsNil {
		predicates = append(predicates, dailyassetprice.OpenIsNil())
	}
	if i.OpenNotNil {
		predicates = append(predicates, dailyassetprice.OpenNotNil())
	}
	if i.High != nil {
		predicates = append(predicates, dailyassetprice.HighEQ(*i.High))
	}
	if i.HighNEQ != nil {
		predicates = append(predicates, dailyassetprice.HighNEQ(*i.HighNEQ))
	}
	if len(i.HighIn) > 0 {
		predicates = append(predicates, dailyassetprice.HighIn(i.HighIn...))
	}
	if len(i.HighNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.HighNotIn(i.HighNotIn...))
	}
	if i.HighGT != nil {
		predicates = append(predicates, dailyassetprice.HighGT(*i.HighGT))
	}
	if i.HighGTE != nil {
		predicates = append(predicates, dailyassetprice.HighGTE(*i.HighGTE))
	}
	if i.HighLT != nil {
		predicates = append(predicates, dailyassetprice.HighLT(*i.HighLT))
	}
	if i.HighLTE != nil {
		predicates = append(predicates, dailyassetprice.HighLTE(*i.HighLTE))
	}
	if i.HighIsNil {
		predicates = append(predicates, dailyassetprice.HighIsNil())
	}
	if i.HighNotNil {
		predicates = append(predicates, dailyassetprice.HighNotNil())
	}
	if i.Low != nil {
		predicates = append(predicates, dailyassetprice.LowEQ(*i.Low))
	}
	if i.LowNEQ != nil {
		predicates = append(predicates, dailyassetprice.LowNEQ(*i.LowNEQ))
	}
	if len(i.LowIn) > 0 {
		predicates = append(predicates, dailyassetprice.LowIn(i.LowIn...))
	}
	if len(i.LowNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.LowNotIn(i.LowNotIn...))
	}
	if i.LowGT != nil {
		predicates = append(predicates, dailyassetprice.LowGT(*i.LowGT))
	}
	if i.LowGTE != nil {
		predicates = append(predicates, dailyassetprice.LowGTE(*i.LowGTE))
	}
	if i.LowLT != nil {
		predicates = append(predicates, dailyassetprice.LowLT(*i.LowLT))
	}
	if i.LowLTE != nil {
		predicates = append(predicates, dailyassetprice.LowLTE(*i.LowLTE))
	}
	if i.LowIsNil {
		predicates = append(predicates, dailyassetprice.LowIsNil())
	}
	if i.LowNotNil {
		predicates = append(predicates, dailyassetprice.LowNotNil())
	}
	if i.Close != nil {
		predicates = append(predicates, dailyassetprice.CloseEQ(*i.Close))
	}
	if i.CloseNEQ != nil {
		predicates = append(predicates, dailyassetprice.CloseNEQ(*i.CloseNEQ))
	}
	if len(i.CloseIn) > 0 {
		predicates = append(predicates, dailyassetprice.CloseIn(i.CloseIn...))
	}
	if len(i.CloseNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.CloseNotIn(i.CloseNotIn...))
	}
	if i.CloseGT != nil {
		predicates = append(predicates, dailyassetprice.CloseGT(*i.CloseGT))
	}
	if i.CloseGTE != nil {
		predicates = append(predicates, dailyassetprice.CloseGTE(*i.CloseGTE))
	}
	if i.CloseLT != nil {
		predicates = append(predicates, dailyassetprice.CloseLT(*i.CloseLT))
	}
	if i.CloseLTE != nil {
		predicates = append(predicates, dailyassetprice.CloseLTE(*i.CloseLTE))
	}
	if i.CloseIsNil {
		predicates = append(predicates, dailyassetprice.CloseIsNil())
	}
	if i.CloseNotNil {
		predicates = append(predicates, dailyassetprice.CloseNotNil())
	}
	if i.AdjustedClose != nil {
		predicates = append(predicates, dailyassetprice.AdjustedCloseEQ(*i.AdjustedClose))
	}
	if i.AdjustedCloseNEQ != nil {
		predicates = append(predicates, dailyassetprice.AdjustedCloseNEQ(*i.AdjustedCloseNEQ))
	}
	if len(i.AdjustedCloseIn) > 0 {
		predicates = append(predicates, dailyassetprice.AdjustedCloseIn(i.AdjustedCloseIn...))
	}
	if len(i.AdjustedCloseNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.AdjustedCloseNotIn(i.AdjustedCloseNotIn...))
	}
	if i.AdjustedCloseGT != nil {
		predicates = append(predicates, dailyassetprice.AdjustedCloseGT(*i.AdjustedCloseGT))
	}
	if i.AdjustedCloseGTE != nil {
		predicates = append(predicates, dailyassetprice.AdjustedCloseGTE(*i.AdjustedCloseGTE))
	}
	if i.AdjustedCloseLT != nil {
		predicates = append(predicates, dailyassetprice.AdjustedCloseLT(*i.AdjustedCloseLT))
	}
	if i.AdjustedCloseLTE != nil {
		predicates = append(predicates, dailyassetprice.AdjustedCloseLTE(*i.AdjustedCloseLTE))
	}
	if i.AssetID != nil {
		predicates = append(predicates, dailyassetprice.AssetIDEQ(*i.AssetID))
	}
	if i.AssetIDNEQ != nil {
		predicates = append(predicates, dailyassetprice.AssetIDNEQ(*i.AssetIDNEQ))
	}
	if len(i.AssetIDIn) > 0 {
		predicates = append(predicates, dailyassetprice.AssetIDIn(i.AssetIDIn...))
	}
	if len(i.AssetIDNotIn) > 0 {
		predicates = append(predicates, dailyassetprice.AssetIDNotIn(i.AssetIDNotIn...))
	}
	if i.AssetIDGT != nil {
		predicates = append(predicates, dailyassetprice.AssetIDGT(*i.AssetIDGT))
	}
	if i.AssetIDGTE != nil {
		predicates = append(predicates, dailyassetprice.AssetIDGTE(*i.AssetIDGTE))
	}
	if i.AssetIDLT != nil {
		predicates = append(predicates, dailyassetprice.AssetIDLT(*i.AssetIDLT))
	}
	if i.AssetIDLTE != nil {
		predicates = append(predicates, dailyassetprice.AssetIDLTE(*i.AssetIDLTE))
	}
	if i.AssetIDContains != nil {
		predicates = append(predicates, dailyassetprice.AssetIDContains(*i.AssetIDContains))
	}
	if i.AssetIDHasPrefix != nil {
		predicates = append(predicates, dailyassetprice.AssetIDHasPrefix(*i.AssetIDHasPrefix))
	}
	if i.AssetIDHasSuffix != nil {
		predicates = append(predicates, dailyassetprice.AssetIDHasSuffix(*i.AssetIDHasSuffix))
	}
	if i.AssetIDEqualFold != nil {
		predicates = append(predicates, dailyassetprice.AssetIDEqualFold(*i.AssetIDEqualFold))
	}
	if i.AssetIDContainsFold != nil {
		predicates = append(predicates, dailyassetprice.AssetIDContainsFold(*i.AssetIDContainsFold))
	}

	if i.HasAsset != nil {
		p := dailyassetprice.HasAsset()
		if !*i.HasAsset {
			p = dailyassetprice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssetWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasAssetWith))
		for _, w := range i.HasAssetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dailyassetprice.HasAssetWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDailyAssetPriceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dailyassetprice.And(predicates...), nil
	}
}

// ExchangeWhereInput represents a where input for filtering Exchange queries.
type ExchangeWhereInput struct {
	Predicates []predicate.Exchange  `json:"-"`
	Not        *ExchangeWhereInput   `json:"not,omitempty"`
	Or         []*ExchangeWhereInput `json:"or,omitempty"`
	And        []*ExchangeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "icon" field predicates.
	Icon             *string  `json:"icon,omitempty"`
	IconNEQ          *string  `json:"iconNEQ,omitempty"`
	IconIn           []string `json:"iconIn,omitempty"`
	IconNotIn        []string `json:"iconNotIn,omitempty"`
	IconGT           *string  `json:"iconGT,omitempty"`
	IconGTE          *string  `json:"iconGTE,omitempty"`
	IconLT           *string  `json:"iconLT,omitempty"`
	IconLTE          *string  `json:"iconLTE,omitempty"`
	IconContains     *string  `json:"iconContains,omitempty"`
	IconHasPrefix    *string  `json:"iconHasPrefix,omitempty"`
	IconHasSuffix    *string  `json:"iconHasSuffix,omitempty"`
	IconIsNil        bool     `json:"iconIsNil,omitempty"`
	IconNotNil       bool     `json:"iconNotNil,omitempty"`
	IconEqualFold    *string  `json:"iconEqualFold,omitempty"`
	IconContainsFold *string  `json:"iconContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLIsNil        bool     `json:"urlIsNil,omitempty"`
	URLNotNil       bool     `json:"urlNotNil,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ExchangeWhereInput) AddPredicates(predicates ...predicate.Exchange) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ExchangeWhereInput filter on the ExchangeQuery builder.
func (i *ExchangeWhereInput) Filter(q *ExchangeQuery) (*ExchangeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyExchangeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyExchangeWhereInput is returned in case the ExchangeWhereInput is empty.
var ErrEmptyExchangeWhereInput = errors.New("ent: empty predicate ExchangeWhereInput")

// P returns a predicate for filtering exchanges.
// An error is returned if the input is empty or invalid.
func (i *ExchangeWhereInput) P() (predicate.Exchange, error) {
	var predicates []predicate.Exchange
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, exchange.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Exchange, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, exchange.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Exchange, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, exchange.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, exchange.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, exchange.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, exchange.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, exchange.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, exchange.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, exchange.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, exchange.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, exchange.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, exchange.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, exchange.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, exchange.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, exchange.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, exchange.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, exchange.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, exchange.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, exchange.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, exchange.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, exchange.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, exchange.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, exchange.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, exchange.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, exchange.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, exchange.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, exchange.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, exchange.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, exchange.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, exchange.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, exchange.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, exchange.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, exchange.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, exchange.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, exchange.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, exchange.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, exchange.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, exchange.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, exchange.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, exchange.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, exchange.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, exchange.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, exchange.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, exchange.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, exchange.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, exchange.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, exchange.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, exchange.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, exchange.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, exchange.NameContainsFold(*i.NameContainsFold))
	}
	if i.Icon != nil {
		predicates = append(predicates, exchange.IconEQ(*i.Icon))
	}
	if i.IconNEQ != nil {
		predicates = append(predicates, exchange.IconNEQ(*i.IconNEQ))
	}
	if len(i.IconIn) > 0 {
		predicates = append(predicates, exchange.IconIn(i.IconIn...))
	}
	if len(i.IconNotIn) > 0 {
		predicates = append(predicates, exchange.IconNotIn(i.IconNotIn...))
	}
	if i.IconGT != nil {
		predicates = append(predicates, exchange.IconGT(*i.IconGT))
	}
	if i.IconGTE != nil {
		predicates = append(predicates, exchange.IconGTE(*i.IconGTE))
	}
	if i.IconLT != nil {
		predicates = append(predicates, exchange.IconLT(*i.IconLT))
	}
	if i.IconLTE != nil {
		predicates = append(predicates, exchange.IconLTE(*i.IconLTE))
	}
	if i.IconContains != nil {
		predicates = append(predicates, exchange.IconContains(*i.IconContains))
	}
	if i.IconHasPrefix != nil {
		predicates = append(predicates, exchange.IconHasPrefix(*i.IconHasPrefix))
	}
	if i.IconHasSuffix != nil {
		predicates = append(predicates, exchange.IconHasSuffix(*i.IconHasSuffix))
	}
	if i.IconIsNil {
		predicates = append(predicates, exchange.IconIsNil())
	}
	if i.IconNotNil {
		predicates = append(predicates, exchange.IconNotNil())
	}
	if i.IconEqualFold != nil {
		predicates = append(predicates, exchange.IconEqualFold(*i.IconEqualFold))
	}
	if i.IconContainsFold != nil {
		predicates = append(predicates, exchange.IconContainsFold(*i.IconContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, exchange.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, exchange.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, exchange.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, exchange.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, exchange.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, exchange.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, exchange.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, exchange.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, exchange.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, exchange.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, exchange.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLIsNil {
		predicates = append(predicates, exchange.URLIsNil())
	}
	if i.URLNotNil {
		predicates = append(predicates, exchange.URLNotNil())
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, exchange.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, exchange.URLContainsFold(*i.URLContainsFold))
	}

	if i.HasTransactions != nil {
		p := exchange.HasTransactions()
		if !*i.HasTransactions {
			p = exchange.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, exchange.HasTransactionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyExchangeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return exchange.And(predicates...), nil
	}
}

// PortfolioWhereInput represents a where input for filtering Portfolio queries.
type PortfolioWhereInput struct {
	Predicates []predicate.Portfolio  `json:"-"`
	Not        *PortfolioWhereInput   `json:"not,omitempty"`
	Or         []*PortfolioWhereInput `json:"or,omitempty"`
	And        []*PortfolioWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "is_public" field predicates.
	IsPublic    *bool `json:"isPublic,omitempty"`
	IsPublicNEQ *bool `json:"isPublicNEQ,omitempty"`

	// "is_visible" field predicates.
	IsVisible    *bool `json:"isVisible,omitempty"`
	IsVisibleNEQ *bool `json:"isVisibleNEQ,omitempty"`

	// "account_id" field predicates.
	AccountID             *pulid.PULID  `json:"accountID,omitempty"`
	AccountIDNEQ          *pulid.PULID  `json:"accountIDNEQ,omitempty"`
	AccountIDIn           []pulid.PULID `json:"accountIDIn,omitempty"`
	AccountIDNotIn        []pulid.PULID `json:"accountIDNotIn,omitempty"`
	AccountIDGT           *pulid.PULID  `json:"accountIDGT,omitempty"`
	AccountIDGTE          *pulid.PULID  `json:"accountIDGTE,omitempty"`
	AccountIDLT           *pulid.PULID  `json:"accountIDLT,omitempty"`
	AccountIDLTE          *pulid.PULID  `json:"accountIDLTE,omitempty"`
	AccountIDContains     *pulid.PULID  `json:"accountIDContains,omitempty"`
	AccountIDHasPrefix    *pulid.PULID  `json:"accountIDHasPrefix,omitempty"`
	AccountIDHasSuffix    *pulid.PULID  `json:"accountIDHasSuffix,omitempty"`
	AccountIDEqualFold    *pulid.PULID  `json:"accountIDEqualFold,omitempty"`
	AccountIDContainsFold *pulid.PULID  `json:"accountIDContainsFold,omitempty"`

	// "account" edge predicates.
	HasAccount     *bool                `json:"hasAccount,omitempty"`
	HasAccountWith []*AccountWhereInput `json:"hasAccountWith,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`

	// "connections" edge predicates.
	HasConnections     *bool                   `json:"hasConnections,omitempty"`
	HasConnectionsWith []*ConnectionWhereInput `json:"hasConnectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PortfolioWhereInput) AddPredicates(predicates ...predicate.Portfolio) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PortfolioWhereInput filter on the PortfolioQuery builder.
func (i *PortfolioWhereInput) Filter(q *PortfolioQuery) (*PortfolioQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPortfolioWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPortfolioWhereInput is returned in case the PortfolioWhereInput is empty.
var ErrEmptyPortfolioWhereInput = errors.New("ent: empty predicate PortfolioWhereInput")

// P returns a predicate for filtering portfolios.
// An error is returned if the input is empty or invalid.
func (i *PortfolioWhereInput) P() (predicate.Portfolio, error) {
	var predicates []predicate.Portfolio
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, portfolio.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Portfolio, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, portfolio.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Portfolio, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, portfolio.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, portfolio.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, portfolio.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, portfolio.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, portfolio.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, portfolio.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, portfolio.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, portfolio.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, portfolio.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, portfolio.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, portfolio.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, portfolio.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, portfolio.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, portfolio.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, portfolio.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, portfolio.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, portfolio.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, portfolio.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, portfolio.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, portfolio.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, portfolio.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, portfolio.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, portfolio.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, portfolio.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, portfolio.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, portfolio.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, portfolio.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, portfolio.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, portfolio.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, portfolio.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, portfolio.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, portfolio.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, portfolio.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, portfolio.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, portfolio.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, portfolio.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, portfolio.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, portfolio.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, portfolio.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, portfolio.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, portfolio.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, portfolio.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, portfolio.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, portfolio.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, portfolio.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, portfolio.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, portfolio.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, portfolio.NameContainsFold(*i.NameContainsFold))
	}
	if i.IsPublic != nil {
		predicates = append(predicates, portfolio.IsPublicEQ(*i.IsPublic))
	}
	if i.IsPublicNEQ != nil {
		predicates = append(predicates, portfolio.IsPublicNEQ(*i.IsPublicNEQ))
	}
	if i.IsVisible != nil {
		predicates = append(predicates, portfolio.IsVisibleEQ(*i.IsVisible))
	}
	if i.IsVisibleNEQ != nil {
		predicates = append(predicates, portfolio.IsVisibleNEQ(*i.IsVisibleNEQ))
	}
	if i.AccountID != nil {
		predicates = append(predicates, portfolio.AccountIDEQ(*i.AccountID))
	}
	if i.AccountIDNEQ != nil {
		predicates = append(predicates, portfolio.AccountIDNEQ(*i.AccountIDNEQ))
	}
	if len(i.AccountIDIn) > 0 {
		predicates = append(predicates, portfolio.AccountIDIn(i.AccountIDIn...))
	}
	if len(i.AccountIDNotIn) > 0 {
		predicates = append(predicates, portfolio.AccountIDNotIn(i.AccountIDNotIn...))
	}
	if i.AccountIDGT != nil {
		predicates = append(predicates, portfolio.AccountIDGT(*i.AccountIDGT))
	}
	if i.AccountIDGTE != nil {
		predicates = append(predicates, portfolio.AccountIDGTE(*i.AccountIDGTE))
	}
	if i.AccountIDLT != nil {
		predicates = append(predicates, portfolio.AccountIDLT(*i.AccountIDLT))
	}
	if i.AccountIDLTE != nil {
		predicates = append(predicates, portfolio.AccountIDLTE(*i.AccountIDLTE))
	}
	if i.AccountIDContains != nil {
		predicates = append(predicates, portfolio.AccountIDContains(*i.AccountIDContains))
	}
	if i.AccountIDHasPrefix != nil {
		predicates = append(predicates, portfolio.AccountIDHasPrefix(*i.AccountIDHasPrefix))
	}
	if i.AccountIDHasSuffix != nil {
		predicates = append(predicates, portfolio.AccountIDHasSuffix(*i.AccountIDHasSuffix))
	}
	if i.AccountIDEqualFold != nil {
		predicates = append(predicates, portfolio.AccountIDEqualFold(*i.AccountIDEqualFold))
	}
	if i.AccountIDContainsFold != nil {
		predicates = append(predicates, portfolio.AccountIDContainsFold(*i.AccountIDContainsFold))
	}

	if i.HasAccount != nil {
		p := portfolio.HasAccount()
		if !*i.HasAccount {
			p = portfolio.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccountWith) > 0 {
		with := make([]predicate.Account, 0, len(i.HasAccountWith))
		for _, w := range i.HasAccountWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccountWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portfolio.HasAccountWith(with...))
	}
	if i.HasTransactions != nil {
		p := portfolio.HasTransactions()
		if !*i.HasTransactions {
			p = portfolio.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portfolio.HasTransactionsWith(with...))
	}
	if i.HasConnections != nil {
		p := portfolio.HasConnections()
		if !*i.HasConnections {
			p = portfolio.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionsWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionsWith))
		for _, w := range i.HasConnectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, portfolio.HasConnectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPortfolioWhereInput
	case 1:
		return predicates[0], nil
	default:
		return portfolio.And(predicates...), nil
	}
}

// SourceWhereInput represents a where input for filtering Source queries.
type SourceWhereInput struct {
	Predicates []predicate.Source  `json:"-"`
	Not        *SourceWhereInput   `json:"not,omitempty"`
	Or         []*SourceWhereInput `json:"or,omitempty"`
	And        []*SourceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "icon" field predicates.
	Icon             *string  `json:"icon,omitempty"`
	IconNEQ          *string  `json:"iconNEQ,omitempty"`
	IconIn           []string `json:"iconIn,omitempty"`
	IconNotIn        []string `json:"iconNotIn,omitempty"`
	IconGT           *string  `json:"iconGT,omitempty"`
	IconGTE          *string  `json:"iconGTE,omitempty"`
	IconLT           *string  `json:"iconLT,omitempty"`
	IconLTE          *string  `json:"iconLTE,omitempty"`
	IconContains     *string  `json:"iconContains,omitempty"`
	IconHasPrefix    *string  `json:"iconHasPrefix,omitempty"`
	IconHasSuffix    *string  `json:"iconHasSuffix,omitempty"`
	IconIsNil        bool     `json:"iconIsNil,omitempty"`
	IconNotNil       bool     `json:"iconNotNil,omitempty"`
	IconEqualFold    *string  `json:"iconEqualFold,omitempty"`
	IconContainsFold *string  `json:"iconContainsFold,omitempty"`

	// "source_type_id" field predicates.
	SourceTypeID             *pulid.PULID  `json:"sourceTypeID,omitempty"`
	SourceTypeIDNEQ          *pulid.PULID  `json:"sourceTypeIDNEQ,omitempty"`
	SourceTypeIDIn           []pulid.PULID `json:"sourceTypeIDIn,omitempty"`
	SourceTypeIDNotIn        []pulid.PULID `json:"sourceTypeIDNotIn,omitempty"`
	SourceTypeIDGT           *pulid.PULID  `json:"sourceTypeIDGT,omitempty"`
	SourceTypeIDGTE          *pulid.PULID  `json:"sourceTypeIDGTE,omitempty"`
	SourceTypeIDLT           *pulid.PULID  `json:"sourceTypeIDLT,omitempty"`
	SourceTypeIDLTE          *pulid.PULID  `json:"sourceTypeIDLTE,omitempty"`
	SourceTypeIDContains     *pulid.PULID  `json:"sourceTypeIDContains,omitempty"`
	SourceTypeIDHasPrefix    *pulid.PULID  `json:"sourceTypeIDHasPrefix,omitempty"`
	SourceTypeIDHasSuffix    *pulid.PULID  `json:"sourceTypeIDHasSuffix,omitempty"`
	SourceTypeIDEqualFold    *pulid.PULID  `json:"sourceTypeIDEqualFold,omitempty"`
	SourceTypeIDContainsFold *pulid.PULID  `json:"sourceTypeIDContainsFold,omitempty"`

	// "source_type" edge predicates.
	HasSourceType     *bool                   `json:"hasSourceType,omitempty"`
	HasSourceTypeWith []*SourceTypeWhereInput `json:"hasSourceTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SourceWhereInput) AddPredicates(predicates ...predicate.Source) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SourceWhereInput filter on the SourceQuery builder.
func (i *SourceWhereInput) Filter(q *SourceQuery) (*SourceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySourceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySourceWhereInput is returned in case the SourceWhereInput is empty.
var ErrEmptySourceWhereInput = errors.New("ent: empty predicate SourceWhereInput")

// P returns a predicate for filtering sources.
// An error is returned if the input is empty or invalid.
func (i *SourceWhereInput) P() (predicate.Source, error) {
	var predicates []predicate.Source
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, source.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Source, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, source.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Source, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, source.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, source.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, source.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, source.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, source.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, source.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, source.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, source.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, source.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, source.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, source.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, source.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, source.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, source.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, source.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, source.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, source.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, source.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, source.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, source.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, source.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, source.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, source.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, source.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, source.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, source.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, source.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, source.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, source.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, source.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, source.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, source.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, source.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, source.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, source.DeletedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, source.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, source.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, source.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, source.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, source.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, source.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, source.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, source.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, source.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, source.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, source.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, source.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, source.NameContainsFold(*i.NameContainsFold))
	}
	if i.Icon != nil {
		predicates = append(predicates, source.IconEQ(*i.Icon))
	}
	if i.IconNEQ != nil {
		predicates = append(predicates, source.IconNEQ(*i.IconNEQ))
	}
	if len(i.IconIn) > 0 {
		predicates = append(predicates, source.IconIn(i.IconIn...))
	}
	if len(i.IconNotIn) > 0 {
		predicates = append(predicates, source.IconNotIn(i.IconNotIn...))
	}
	if i.IconGT != nil {
		predicates = append(predicates, source.IconGT(*i.IconGT))
	}
	if i.IconGTE != nil {
		predicates = append(predicates, source.IconGTE(*i.IconGTE))
	}
	if i.IconLT != nil {
		predicates = append(predicates, source.IconLT(*i.IconLT))
	}
	if i.IconLTE != nil {
		predicates = append(predicates, source.IconLTE(*i.IconLTE))
	}
	if i.IconContains != nil {
		predicates = append(predicates, source.IconContains(*i.IconContains))
	}
	if i.IconHasPrefix != nil {
		predicates = append(predicates, source.IconHasPrefix(*i.IconHasPrefix))
	}
	if i.IconHasSuffix != nil {
		predicates = append(predicates, source.IconHasSuffix(*i.IconHasSuffix))
	}
	if i.IconIsNil {
		predicates = append(predicates, source.IconIsNil())
	}
	if i.IconNotNil {
		predicates = append(predicates, source.IconNotNil())
	}
	if i.IconEqualFold != nil {
		predicates = append(predicates, source.IconEqualFold(*i.IconEqualFold))
	}
	if i.IconContainsFold != nil {
		predicates = append(predicates, source.IconContainsFold(*i.IconContainsFold))
	}
	if i.SourceTypeID != nil {
		predicates = append(predicates, source.SourceTypeIDEQ(*i.SourceTypeID))
	}
	if i.SourceTypeIDNEQ != nil {
		predicates = append(predicates, source.SourceTypeIDNEQ(*i.SourceTypeIDNEQ))
	}
	if len(i.SourceTypeIDIn) > 0 {
		predicates = append(predicates, source.SourceTypeIDIn(i.SourceTypeIDIn...))
	}
	if len(i.SourceTypeIDNotIn) > 0 {
		predicates = append(predicates, source.SourceTypeIDNotIn(i.SourceTypeIDNotIn...))
	}
	if i.SourceTypeIDGT != nil {
		predicates = append(predicates, source.SourceTypeIDGT(*i.SourceTypeIDGT))
	}
	if i.SourceTypeIDGTE != nil {
		predicates = append(predicates, source.SourceTypeIDGTE(*i.SourceTypeIDGTE))
	}
	if i.SourceTypeIDLT != nil {
		predicates = append(predicates, source.SourceTypeIDLT(*i.SourceTypeIDLT))
	}
	if i.SourceTypeIDLTE != nil {
		predicates = append(predicates, source.SourceTypeIDLTE(*i.SourceTypeIDLTE))
	}
	if i.SourceTypeIDContains != nil {
		predicates = append(predicates, source.SourceTypeIDContains(*i.SourceTypeIDContains))
	}
	if i.SourceTypeIDHasPrefix != nil {
		predicates = append(predicates, source.SourceTypeIDHasPrefix(*i.SourceTypeIDHasPrefix))
	}
	if i.SourceTypeIDHasSuffix != nil {
		predicates = append(predicates, source.SourceTypeIDHasSuffix(*i.SourceTypeIDHasSuffix))
	}
	if i.SourceTypeIDEqualFold != nil {
		predicates = append(predicates, source.SourceTypeIDEqualFold(*i.SourceTypeIDEqualFold))
	}
	if i.SourceTypeIDContainsFold != nil {
		predicates = append(predicates, source.SourceTypeIDContainsFold(*i.SourceTypeIDContainsFold))
	}

	if i.HasSourceType != nil {
		p := source.HasSourceType()
		if !*i.HasSourceType {
			p = source.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSourceTypeWith) > 0 {
		with := make([]predicate.SourceType, 0, len(i.HasSourceTypeWith))
		for _, w := range i.HasSourceTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSourceTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, source.HasSourceTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySourceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return source.And(predicates...), nil
	}
}

// SourceTypeWhereInput represents a where input for filtering SourceType queries.
type SourceTypeWhereInput struct {
	Predicates []predicate.SourceType  `json:"-"`
	Not        *SourceTypeWhereInput   `json:"not,omitempty"`
	Or         []*SourceTypeWhereInput `json:"or,omitempty"`
	And        []*SourceTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "value" field predicates.
	Value      *sourcetype.Value  `json:"value,omitempty"`
	ValueNEQ   *sourcetype.Value  `json:"valueNEQ,omitempty"`
	ValueIn    []sourcetype.Value `json:"valueIn,omitempty"`
	ValueNotIn []sourcetype.Value `json:"valueNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "sources" edge predicates.
	HasSources     *bool               `json:"hasSources,omitempty"`
	HasSourcesWith []*SourceWhereInput `json:"hasSourcesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SourceTypeWhereInput) AddPredicates(predicates ...predicate.SourceType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SourceTypeWhereInput filter on the SourceTypeQuery builder.
func (i *SourceTypeWhereInput) Filter(q *SourceTypeQuery) (*SourceTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySourceTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySourceTypeWhereInput is returned in case the SourceTypeWhereInput is empty.
var ErrEmptySourceTypeWhereInput = errors.New("ent: empty predicate SourceTypeWhereInput")

// P returns a predicate for filtering sourcetypes.
// An error is returned if the input is empty or invalid.
func (i *SourceTypeWhereInput) P() (predicate.SourceType, error) {
	var predicates []predicate.SourceType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, sourcetype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SourceType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, sourcetype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SourceType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, sourcetype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, sourcetype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, sourcetype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, sourcetype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, sourcetype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, sourcetype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, sourcetype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, sourcetype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, sourcetype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, sourcetype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, sourcetype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, sourcetype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, sourcetype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, sourcetype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, sourcetype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, sourcetype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, sourcetype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, sourcetype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, sourcetype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, sourcetype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, sourcetype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, sourcetype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, sourcetype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, sourcetype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, sourcetype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, sourcetype.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, sourcetype.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, sourcetype.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, sourcetype.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, sourcetype.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, sourcetype.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, sourcetype.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, sourcetype.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, sourcetype.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, sourcetype.DeletedAtNotNil())
	}
	if i.Value != nil {
		predicates = append(predicates, sourcetype.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, sourcetype.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, sourcetype.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, sourcetype.ValueNotIn(i.ValueNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, sourcetype.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, sourcetype.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, sourcetype.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, sourcetype.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, sourcetype.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, sourcetype.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, sourcetype.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, sourcetype.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, sourcetype.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, sourcetype.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, sourcetype.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, sourcetype.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, sourcetype.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, sourcetype.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, sourcetype.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasSources != nil {
		p := sourcetype.HasSources()
		if !*i.HasSources {
			p = sourcetype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSourcesWith) > 0 {
		with := make([]predicate.Source, 0, len(i.HasSourcesWith))
		for _, w := range i.HasSourcesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSourcesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, sourcetype.HasSourcesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySourceTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return sourcetype.And(predicates...), nil
	}
}

// StaffAccountWhereInput represents a where input for filtering StaffAccount queries.
type StaffAccountWhereInput struct {
	Predicates []predicate.StaffAccount  `json:"-"`
	Not        *StaffAccountWhereInput   `json:"not,omitempty"`
	Or         []*StaffAccountWhereInput `json:"or,omitempty"`
	And        []*StaffAccountWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "nickname" field predicates.
	Nickname             *string  `json:"nickname,omitempty"`
	NicknameNEQ          *string  `json:"nicknameNEQ,omitempty"`
	NicknameIn           []string `json:"nicknameIn,omitempty"`
	NicknameNotIn        []string `json:"nicknameNotIn,omitempty"`
	NicknameGT           *string  `json:"nicknameGT,omitempty"`
	NicknameGTE          *string  `json:"nicknameGTE,omitempty"`
	NicknameLT           *string  `json:"nicknameLT,omitempty"`
	NicknameLTE          *string  `json:"nicknameLTE,omitempty"`
	NicknameContains     *string  `json:"nicknameContains,omitempty"`
	NicknameHasPrefix    *string  `json:"nicknameHasPrefix,omitempty"`
	NicknameHasSuffix    *string  `json:"nicknameHasSuffix,omitempty"`
	NicknameEqualFold    *string  `json:"nicknameEqualFold,omitempty"`
	NicknameContainsFold *string  `json:"nicknameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "password_updated_at" field predicates.
	PasswordUpdatedAt      *time.Time  `json:"passwordUpdatedAt,omitempty"`
	PasswordUpdatedAtNEQ   *time.Time  `json:"passwordUpdatedAtNEQ,omitempty"`
	PasswordUpdatedAtIn    []time.Time `json:"passwordUpdatedAtIn,omitempty"`
	PasswordUpdatedAtNotIn []time.Time `json:"passwordUpdatedAtNotIn,omitempty"`
	PasswordUpdatedAtGT    *time.Time  `json:"passwordUpdatedAtGT,omitempty"`
	PasswordUpdatedAtGTE   *time.Time  `json:"passwordUpdatedAtGTE,omitempty"`
	PasswordUpdatedAtLT    *time.Time  `json:"passwordUpdatedAtLT,omitempty"`
	PasswordUpdatedAtLTE   *time.Time  `json:"passwordUpdatedAtLTE,omitempty"`

	// "auth_type_id" field predicates.
	AuthTypeID             *pulid.PULID  `json:"authTypeID,omitempty"`
	AuthTypeIDNEQ          *pulid.PULID  `json:"authTypeIDNEQ,omitempty"`
	AuthTypeIDIn           []pulid.PULID `json:"authTypeIDIn,omitempty"`
	AuthTypeIDNotIn        []pulid.PULID `json:"authTypeIDNotIn,omitempty"`
	AuthTypeIDGT           *pulid.PULID  `json:"authTypeIDGT,omitempty"`
	AuthTypeIDGTE          *pulid.PULID  `json:"authTypeIDGTE,omitempty"`
	AuthTypeIDLT           *pulid.PULID  `json:"authTypeIDLT,omitempty"`
	AuthTypeIDLTE          *pulid.PULID  `json:"authTypeIDLTE,omitempty"`
	AuthTypeIDContains     *pulid.PULID  `json:"authTypeIDContains,omitempty"`
	AuthTypeIDHasPrefix    *pulid.PULID  `json:"authTypeIDHasPrefix,omitempty"`
	AuthTypeIDHasSuffix    *pulid.PULID  `json:"authTypeIDHasSuffix,omitempty"`
	AuthTypeIDEqualFold    *pulid.PULID  `json:"authTypeIDEqualFold,omitempty"`
	AuthTypeIDContainsFold *pulid.PULID  `json:"authTypeIDContainsFold,omitempty"`

	// "auth_roles" edge predicates.
	HasAuthRoles     *bool                 `json:"hasAuthRoles,omitempty"`
	HasAuthRolesWith []*AuthRoleWhereInput `json:"hasAuthRolesWith,omitempty"`

	// "auth_type" edge predicates.
	HasAuthType     *bool                 `json:"hasAuthType,omitempty"`
	HasAuthTypeWith []*AuthTypeWhereInput `json:"hasAuthTypeWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StaffAccountWhereInput) AddPredicates(predicates ...predicate.StaffAccount) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StaffAccountWhereInput filter on the StaffAccountQuery builder.
func (i *StaffAccountWhereInput) Filter(q *StaffAccountQuery) (*StaffAccountQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStaffAccountWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStaffAccountWhereInput is returned in case the StaffAccountWhereInput is empty.
var ErrEmptyStaffAccountWhereInput = errors.New("ent: empty predicate StaffAccountWhereInput")

// P returns a predicate for filtering staffaccounts.
// An error is returned if the input is empty or invalid.
func (i *StaffAccountWhereInput) P() (predicate.StaffAccount, error) {
	var predicates []predicate.StaffAccount
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, staffaccount.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.StaffAccount, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, staffaccount.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.StaffAccount, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, staffaccount.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, staffaccount.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, staffaccount.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, staffaccount.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, staffaccount.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, staffaccount.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, staffaccount.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, staffaccount.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, staffaccount.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, staffaccount.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, staffaccount.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, staffaccount.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, staffaccount.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, staffaccount.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, staffaccount.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, staffaccount.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, staffaccount.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, staffaccount.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, staffaccount.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, staffaccount.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, staffaccount.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, staffaccount.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, staffaccount.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, staffaccount.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, staffaccount.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, staffaccount.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, staffaccount.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, staffaccount.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, staffaccount.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, staffaccount.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, staffaccount.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, staffaccount.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, staffaccount.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, staffaccount.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, staffaccount.DeletedAtNotNil())
	}
	if i.Nickname != nil {
		predicates = append(predicates, staffaccount.NicknameEQ(*i.Nickname))
	}
	if i.NicknameNEQ != nil {
		predicates = append(predicates, staffaccount.NicknameNEQ(*i.NicknameNEQ))
	}
	if len(i.NicknameIn) > 0 {
		predicates = append(predicates, staffaccount.NicknameIn(i.NicknameIn...))
	}
	if len(i.NicknameNotIn) > 0 {
		predicates = append(predicates, staffaccount.NicknameNotIn(i.NicknameNotIn...))
	}
	if i.NicknameGT != nil {
		predicates = append(predicates, staffaccount.NicknameGT(*i.NicknameGT))
	}
	if i.NicknameGTE != nil {
		predicates = append(predicates, staffaccount.NicknameGTE(*i.NicknameGTE))
	}
	if i.NicknameLT != nil {
		predicates = append(predicates, staffaccount.NicknameLT(*i.NicknameLT))
	}
	if i.NicknameLTE != nil {
		predicates = append(predicates, staffaccount.NicknameLTE(*i.NicknameLTE))
	}
	if i.NicknameContains != nil {
		predicates = append(predicates, staffaccount.NicknameContains(*i.NicknameContains))
	}
	if i.NicknameHasPrefix != nil {
		predicates = append(predicates, staffaccount.NicknameHasPrefix(*i.NicknameHasPrefix))
	}
	if i.NicknameHasSuffix != nil {
		predicates = append(predicates, staffaccount.NicknameHasSuffix(*i.NicknameHasSuffix))
	}
	if i.NicknameEqualFold != nil {
		predicates = append(predicates, staffaccount.NicknameEqualFold(*i.NicknameEqualFold))
	}
	if i.NicknameContainsFold != nil {
		predicates = append(predicates, staffaccount.NicknameContainsFold(*i.NicknameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, staffaccount.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, staffaccount.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, staffaccount.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, staffaccount.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, staffaccount.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, staffaccount.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, staffaccount.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, staffaccount.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, staffaccount.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, staffaccount.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, staffaccount.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, staffaccount.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, staffaccount.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, staffaccount.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, staffaccount.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, staffaccount.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, staffaccount.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, staffaccount.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, staffaccount.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, staffaccount.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, staffaccount.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, staffaccount.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, staffaccount.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, staffaccount.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, staffaccount.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, staffaccount.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, staffaccount.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, staffaccount.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.PasswordUpdatedAt != nil {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtEQ(*i.PasswordUpdatedAt))
	}
	if i.PasswordUpdatedAtNEQ != nil {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtNEQ(*i.PasswordUpdatedAtNEQ))
	}
	if len(i.PasswordUpdatedAtIn) > 0 {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtIn(i.PasswordUpdatedAtIn...))
	}
	if len(i.PasswordUpdatedAtNotIn) > 0 {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtNotIn(i.PasswordUpdatedAtNotIn...))
	}
	if i.PasswordUpdatedAtGT != nil {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtGT(*i.PasswordUpdatedAtGT))
	}
	if i.PasswordUpdatedAtGTE != nil {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtGTE(*i.PasswordUpdatedAtGTE))
	}
	if i.PasswordUpdatedAtLT != nil {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtLT(*i.PasswordUpdatedAtLT))
	}
	if i.PasswordUpdatedAtLTE != nil {
		predicates = append(predicates, staffaccount.PasswordUpdatedAtLTE(*i.PasswordUpdatedAtLTE))
	}
	if i.AuthTypeID != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDEQ(*i.AuthTypeID))
	}
	if i.AuthTypeIDNEQ != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDNEQ(*i.AuthTypeIDNEQ))
	}
	if len(i.AuthTypeIDIn) > 0 {
		predicates = append(predicates, staffaccount.AuthTypeIDIn(i.AuthTypeIDIn...))
	}
	if len(i.AuthTypeIDNotIn) > 0 {
		predicates = append(predicates, staffaccount.AuthTypeIDNotIn(i.AuthTypeIDNotIn...))
	}
	if i.AuthTypeIDGT != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDGT(*i.AuthTypeIDGT))
	}
	if i.AuthTypeIDGTE != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDGTE(*i.AuthTypeIDGTE))
	}
	if i.AuthTypeIDLT != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDLT(*i.AuthTypeIDLT))
	}
	if i.AuthTypeIDLTE != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDLTE(*i.AuthTypeIDLTE))
	}
	if i.AuthTypeIDContains != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDContains(*i.AuthTypeIDContains))
	}
	if i.AuthTypeIDHasPrefix != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDHasPrefix(*i.AuthTypeIDHasPrefix))
	}
	if i.AuthTypeIDHasSuffix != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDHasSuffix(*i.AuthTypeIDHasSuffix))
	}
	if i.AuthTypeIDEqualFold != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDEqualFold(*i.AuthTypeIDEqualFold))
	}
	if i.AuthTypeIDContainsFold != nil {
		predicates = append(predicates, staffaccount.AuthTypeIDContainsFold(*i.AuthTypeIDContainsFold))
	}

	if i.HasAuthRoles != nil {
		p := staffaccount.HasAuthRoles()
		if !*i.HasAuthRoles {
			p = staffaccount.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthRolesWith) > 0 {
		with := make([]predicate.AuthRole, 0, len(i.HasAuthRolesWith))
		for _, w := range i.HasAuthRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, staffaccount.HasAuthRolesWith(with...))
	}
	if i.HasAuthType != nil {
		p := staffaccount.HasAuthType()
		if !*i.HasAuthType {
			p = staffaccount.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthTypeWith) > 0 {
		with := make([]predicate.AuthType, 0, len(i.HasAuthTypeWith))
		for _, w := range i.HasAuthTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, staffaccount.HasAuthTypeWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStaffAccountWhereInput
	case 1:
		return predicates[0], nil
	default:
		return staffaccount.And(predicates...), nil
	}
}

// TransactionWhereInput represents a where input for filtering Transaction queries.
type TransactionWhereInput struct {
	Predicates []predicate.Transaction  `json:"-"`
	Not        *TransactionWhereInput   `json:"not,omitempty"`
	Or         []*TransactionWhereInput `json:"or,omitempty"`
	And        []*TransactionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "units" field predicates.
	Units      *int  `json:"units,omitempty"`
	UnitsNEQ   *int  `json:"unitsNEQ,omitempty"`
	UnitsIn    []int `json:"unitsIn,omitempty"`
	UnitsNotIn []int `json:"unitsNotIn,omitempty"`
	UnitsGT    *int  `json:"unitsGT,omitempty"`
	UnitsGTE   *int  `json:"unitsGTE,omitempty"`
	UnitsLT    *int  `json:"unitsLT,omitempty"`
	UnitsLTE   *int  `json:"unitsLTE,omitempty"`

	// "price_per_unit" field predicates.
	PricePerUnit      *float64  `json:"pricePerUnit,omitempty"`
	PricePerUnitNEQ   *float64  `json:"pricePerUnitNEQ,omitempty"`
	PricePerUnitIn    []float64 `json:"pricePerUnitIn,omitempty"`
	PricePerUnitNotIn []float64 `json:"pricePerUnitNotIn,omitempty"`
	PricePerUnitGT    *float64  `json:"pricePerUnitGT,omitempty"`
	PricePerUnitGTE   *float64  `json:"pricePerUnitGTE,omitempty"`
	PricePerUnitLT    *float64  `json:"pricePerUnitLT,omitempty"`
	PricePerUnitLTE   *float64  `json:"pricePerUnitLTE,omitempty"`

	// "blockchain_id" field predicates.
	BlockchainID             *pulid.PULID  `json:"blockchainID,omitempty"`
	BlockchainIDNEQ          *pulid.PULID  `json:"blockchainIDNEQ,omitempty"`
	BlockchainIDIn           []pulid.PULID `json:"blockchainIDIn,omitempty"`
	BlockchainIDNotIn        []pulid.PULID `json:"blockchainIDNotIn,omitempty"`
	BlockchainIDGT           *pulid.PULID  `json:"blockchainIDGT,omitempty"`
	BlockchainIDGTE          *pulid.PULID  `json:"blockchainIDGTE,omitempty"`
	BlockchainIDLT           *pulid.PULID  `json:"blockchainIDLT,omitempty"`
	BlockchainIDLTE          *pulid.PULID  `json:"blockchainIDLTE,omitempty"`
	BlockchainIDContains     *pulid.PULID  `json:"blockchainIDContains,omitempty"`
	BlockchainIDHasPrefix    *pulid.PULID  `json:"blockchainIDHasPrefix,omitempty"`
	BlockchainIDHasSuffix    *pulid.PULID  `json:"blockchainIDHasSuffix,omitempty"`
	BlockchainIDIsNil        bool          `json:"blockchainIDIsNil,omitempty"`
	BlockchainIDNotNil       bool          `json:"blockchainIDNotNil,omitempty"`
	BlockchainIDEqualFold    *pulid.PULID  `json:"blockchainIDEqualFold,omitempty"`
	BlockchainIDContainsFold *pulid.PULID  `json:"blockchainIDContainsFold,omitempty"`

	// "transaction_type_id" field predicates.
	TransactionTypeID             *pulid.PULID  `json:"transactionTypeID,omitempty"`
	TransactionTypeIDNEQ          *pulid.PULID  `json:"transactionTypeIDNEQ,omitempty"`
	TransactionTypeIDIn           []pulid.PULID `json:"transactionTypeIDIn,omitempty"`
	TransactionTypeIDNotIn        []pulid.PULID `json:"transactionTypeIDNotIn,omitempty"`
	TransactionTypeIDGT           *pulid.PULID  `json:"transactionTypeIDGT,omitempty"`
	TransactionTypeIDGTE          *pulid.PULID  `json:"transactionTypeIDGTE,omitempty"`
	TransactionTypeIDLT           *pulid.PULID  `json:"transactionTypeIDLT,omitempty"`
	TransactionTypeIDLTE          *pulid.PULID  `json:"transactionTypeIDLTE,omitempty"`
	TransactionTypeIDContains     *pulid.PULID  `json:"transactionTypeIDContains,omitempty"`
	TransactionTypeIDHasPrefix    *pulid.PULID  `json:"transactionTypeIDHasPrefix,omitempty"`
	TransactionTypeIDHasSuffix    *pulid.PULID  `json:"transactionTypeIDHasSuffix,omitempty"`
	TransactionTypeIDEqualFold    *pulid.PULID  `json:"transactionTypeIDEqualFold,omitempty"`
	TransactionTypeIDContainsFold *pulid.PULID  `json:"transactionTypeIDContainsFold,omitempty"`

	// "exchange_id" field predicates.
	ExchangeID             *pulid.PULID  `json:"exchangeID,omitempty"`
	ExchangeIDNEQ          *pulid.PULID  `json:"exchangeIDNEQ,omitempty"`
	ExchangeIDIn           []pulid.PULID `json:"exchangeIDIn,omitempty"`
	ExchangeIDNotIn        []pulid.PULID `json:"exchangeIDNotIn,omitempty"`
	ExchangeIDGT           *pulid.PULID  `json:"exchangeIDGT,omitempty"`
	ExchangeIDGTE          *pulid.PULID  `json:"exchangeIDGTE,omitempty"`
	ExchangeIDLT           *pulid.PULID  `json:"exchangeIDLT,omitempty"`
	ExchangeIDLTE          *pulid.PULID  `json:"exchangeIDLTE,omitempty"`
	ExchangeIDContains     *pulid.PULID  `json:"exchangeIDContains,omitempty"`
	ExchangeIDHasPrefix    *pulid.PULID  `json:"exchangeIDHasPrefix,omitempty"`
	ExchangeIDHasSuffix    *pulid.PULID  `json:"exchangeIDHasSuffix,omitempty"`
	ExchangeIDEqualFold    *pulid.PULID  `json:"exchangeIDEqualFold,omitempty"`
	ExchangeIDContainsFold *pulid.PULID  `json:"exchangeIDContainsFold,omitempty"`

	// "portfolio_id" field predicates.
	PortfolioID             *pulid.PULID  `json:"portfolioID,omitempty"`
	PortfolioIDNEQ          *pulid.PULID  `json:"portfolioIDNEQ,omitempty"`
	PortfolioIDIn           []pulid.PULID `json:"portfolioIDIn,omitempty"`
	PortfolioIDNotIn        []pulid.PULID `json:"portfolioIDNotIn,omitempty"`
	PortfolioIDGT           *pulid.PULID  `json:"portfolioIDGT,omitempty"`
	PortfolioIDGTE          *pulid.PULID  `json:"portfolioIDGTE,omitempty"`
	PortfolioIDLT           *pulid.PULID  `json:"portfolioIDLT,omitempty"`
	PortfolioIDLTE          *pulid.PULID  `json:"portfolioIDLTE,omitempty"`
	PortfolioIDContains     *pulid.PULID  `json:"portfolioIDContains,omitempty"`
	PortfolioIDHasPrefix    *pulid.PULID  `json:"portfolioIDHasPrefix,omitempty"`
	PortfolioIDHasSuffix    *pulid.PULID  `json:"portfolioIDHasSuffix,omitempty"`
	PortfolioIDEqualFold    *pulid.PULID  `json:"portfolioIDEqualFold,omitempty"`
	PortfolioIDContainsFold *pulid.PULID  `json:"portfolioIDContainsFold,omitempty"`

	// "base_asset_id" field predicates.
	BaseAssetID             *pulid.PULID  `json:"baseAssetID,omitempty"`
	BaseAssetIDNEQ          *pulid.PULID  `json:"baseAssetIDNEQ,omitempty"`
	BaseAssetIDIn           []pulid.PULID `json:"baseAssetIDIn,omitempty"`
	BaseAssetIDNotIn        []pulid.PULID `json:"baseAssetIDNotIn,omitempty"`
	BaseAssetIDGT           *pulid.PULID  `json:"baseAssetIDGT,omitempty"`
	BaseAssetIDGTE          *pulid.PULID  `json:"baseAssetIDGTE,omitempty"`
	BaseAssetIDLT           *pulid.PULID  `json:"baseAssetIDLT,omitempty"`
	BaseAssetIDLTE          *pulid.PULID  `json:"baseAssetIDLTE,omitempty"`
	BaseAssetIDContains     *pulid.PULID  `json:"baseAssetIDContains,omitempty"`
	BaseAssetIDHasPrefix    *pulid.PULID  `json:"baseAssetIDHasPrefix,omitempty"`
	BaseAssetIDHasSuffix    *pulid.PULID  `json:"baseAssetIDHasSuffix,omitempty"`
	BaseAssetIDEqualFold    *pulid.PULID  `json:"baseAssetIDEqualFold,omitempty"`
	BaseAssetIDContainsFold *pulid.PULID  `json:"baseAssetIDContainsFold,omitempty"`

	// "quote_asset_id" field predicates.
	QuoteAssetID             *pulid.PULID  `json:"quoteAssetID,omitempty"`
	QuoteAssetIDNEQ          *pulid.PULID  `json:"quoteAssetIDNEQ,omitempty"`
	QuoteAssetIDIn           []pulid.PULID `json:"quoteAssetIDIn,omitempty"`
	QuoteAssetIDNotIn        []pulid.PULID `json:"quoteAssetIDNotIn,omitempty"`
	QuoteAssetIDGT           *pulid.PULID  `json:"quoteAssetIDGT,omitempty"`
	QuoteAssetIDGTE          *pulid.PULID  `json:"quoteAssetIDGTE,omitempty"`
	QuoteAssetIDLT           *pulid.PULID  `json:"quoteAssetIDLT,omitempty"`
	QuoteAssetIDLTE          *pulid.PULID  `json:"quoteAssetIDLTE,omitempty"`
	QuoteAssetIDContains     *pulid.PULID  `json:"quoteAssetIDContains,omitempty"`
	QuoteAssetIDHasPrefix    *pulid.PULID  `json:"quoteAssetIDHasPrefix,omitempty"`
	QuoteAssetIDHasSuffix    *pulid.PULID  `json:"quoteAssetIDHasSuffix,omitempty"`
	QuoteAssetIDIsNil        bool          `json:"quoteAssetIDIsNil,omitempty"`
	QuoteAssetIDNotNil       bool          `json:"quoteAssetIDNotNil,omitempty"`
	QuoteAssetIDEqualFold    *pulid.PULID  `json:"quoteAssetIDEqualFold,omitempty"`
	QuoteAssetIDContainsFold *pulid.PULID  `json:"quoteAssetIDContainsFold,omitempty"`

	// "transaction_type" edge predicates.
	HasTransactionType     *bool                        `json:"hasTransactionType,omitempty"`
	HasTransactionTypeWith []*TransactionTypeWhereInput `json:"hasTransactionTypeWith,omitempty"`

	// "base_asset" edge predicates.
	HasBaseAsset     *bool              `json:"hasBaseAsset,omitempty"`
	HasBaseAssetWith []*AssetWhereInput `json:"hasBaseAssetWith,omitempty"`

	// "quote_asset" edge predicates.
	HasQuoteAsset     *bool              `json:"hasQuoteAsset,omitempty"`
	HasQuoteAssetWith []*AssetWhereInput `json:"hasQuoteAssetWith,omitempty"`

	// "portfolio" edge predicates.
	HasPortfolio     *bool                  `json:"hasPortfolio,omitempty"`
	HasPortfolioWith []*PortfolioWhereInput `json:"hasPortfolioWith,omitempty"`

	// "exchange" edge predicates.
	HasExchange     *bool                 `json:"hasExchange,omitempty"`
	HasExchangeWith []*ExchangeWhereInput `json:"hasExchangeWith,omitempty"`

	// "blockchain" edge predicates.
	HasBlockchain     *bool                   `json:"hasBlockchain,omitempty"`
	HasBlockchainWith []*BlockchainWhereInput `json:"hasBlockchainWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TransactionWhereInput) AddPredicates(predicates ...predicate.Transaction) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TransactionWhereInput filter on the TransactionQuery builder.
func (i *TransactionWhereInput) Filter(q *TransactionQuery) (*TransactionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTransactionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTransactionWhereInput is returned in case the TransactionWhereInput is empty.
var ErrEmptyTransactionWhereInput = errors.New("ent: empty predicate TransactionWhereInput")

// P returns a predicate for filtering transactions.
// An error is returned if the input is empty or invalid.
func (i *TransactionWhereInput) P() (predicate.Transaction, error) {
	var predicates []predicate.Transaction
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, transaction.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Transaction, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, transaction.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Transaction, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, transaction.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, transaction.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transaction.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transaction.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transaction.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transaction.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transaction.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transaction.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transaction.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, transaction.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, transaction.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, transaction.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, transaction.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, transaction.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, transaction.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, transaction.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, transaction.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, transaction.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, transaction.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, transaction.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, transaction.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, transaction.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, transaction.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, transaction.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, transaction.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, transaction.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, transaction.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, transaction.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, transaction.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, transaction.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, transaction.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, transaction.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, transaction.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, transaction.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, transaction.DeletedAtNotNil())
	}
	if i.Time != nil {
		predicates = append(predicates, transaction.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, transaction.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, transaction.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, transaction.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, transaction.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, transaction.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, transaction.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, transaction.TimeLTE(*i.TimeLTE))
	}
	if i.Units != nil {
		predicates = append(predicates, transaction.UnitsEQ(*i.Units))
	}
	if i.UnitsNEQ != nil {
		predicates = append(predicates, transaction.UnitsNEQ(*i.UnitsNEQ))
	}
	if len(i.UnitsIn) > 0 {
		predicates = append(predicates, transaction.UnitsIn(i.UnitsIn...))
	}
	if len(i.UnitsNotIn) > 0 {
		predicates = append(predicates, transaction.UnitsNotIn(i.UnitsNotIn...))
	}
	if i.UnitsGT != nil {
		predicates = append(predicates, transaction.UnitsGT(*i.UnitsGT))
	}
	if i.UnitsGTE != nil {
		predicates = append(predicates, transaction.UnitsGTE(*i.UnitsGTE))
	}
	if i.UnitsLT != nil {
		predicates = append(predicates, transaction.UnitsLT(*i.UnitsLT))
	}
	if i.UnitsLTE != nil {
		predicates = append(predicates, transaction.UnitsLTE(*i.UnitsLTE))
	}
	if i.PricePerUnit != nil {
		predicates = append(predicates, transaction.PricePerUnitEQ(*i.PricePerUnit))
	}
	if i.PricePerUnitNEQ != nil {
		predicates = append(predicates, transaction.PricePerUnitNEQ(*i.PricePerUnitNEQ))
	}
	if len(i.PricePerUnitIn) > 0 {
		predicates = append(predicates, transaction.PricePerUnitIn(i.PricePerUnitIn...))
	}
	if len(i.PricePerUnitNotIn) > 0 {
		predicates = append(predicates, transaction.PricePerUnitNotIn(i.PricePerUnitNotIn...))
	}
	if i.PricePerUnitGT != nil {
		predicates = append(predicates, transaction.PricePerUnitGT(*i.PricePerUnitGT))
	}
	if i.PricePerUnitGTE != nil {
		predicates = append(predicates, transaction.PricePerUnitGTE(*i.PricePerUnitGTE))
	}
	if i.PricePerUnitLT != nil {
		predicates = append(predicates, transaction.PricePerUnitLT(*i.PricePerUnitLT))
	}
	if i.PricePerUnitLTE != nil {
		predicates = append(predicates, transaction.PricePerUnitLTE(*i.PricePerUnitLTE))
	}
	if i.BlockchainID != nil {
		predicates = append(predicates, transaction.BlockchainIDEQ(*i.BlockchainID))
	}
	if i.BlockchainIDNEQ != nil {
		predicates = append(predicates, transaction.BlockchainIDNEQ(*i.BlockchainIDNEQ))
	}
	if len(i.BlockchainIDIn) > 0 {
		predicates = append(predicates, transaction.BlockchainIDIn(i.BlockchainIDIn...))
	}
	if len(i.BlockchainIDNotIn) > 0 {
		predicates = append(predicates, transaction.BlockchainIDNotIn(i.BlockchainIDNotIn...))
	}
	if i.BlockchainIDGT != nil {
		predicates = append(predicates, transaction.BlockchainIDGT(*i.BlockchainIDGT))
	}
	if i.BlockchainIDGTE != nil {
		predicates = append(predicates, transaction.BlockchainIDGTE(*i.BlockchainIDGTE))
	}
	if i.BlockchainIDLT != nil {
		predicates = append(predicates, transaction.BlockchainIDLT(*i.BlockchainIDLT))
	}
	if i.BlockchainIDLTE != nil {
		predicates = append(predicates, transaction.BlockchainIDLTE(*i.BlockchainIDLTE))
	}
	if i.BlockchainIDContains != nil {
		predicates = append(predicates, transaction.BlockchainIDContains(*i.BlockchainIDContains))
	}
	if i.BlockchainIDHasPrefix != nil {
		predicates = append(predicates, transaction.BlockchainIDHasPrefix(*i.BlockchainIDHasPrefix))
	}
	if i.BlockchainIDHasSuffix != nil {
		predicates = append(predicates, transaction.BlockchainIDHasSuffix(*i.BlockchainIDHasSuffix))
	}
	if i.BlockchainIDIsNil {
		predicates = append(predicates, transaction.BlockchainIDIsNil())
	}
	if i.BlockchainIDNotNil {
		predicates = append(predicates, transaction.BlockchainIDNotNil())
	}
	if i.BlockchainIDEqualFold != nil {
		predicates = append(predicates, transaction.BlockchainIDEqualFold(*i.BlockchainIDEqualFold))
	}
	if i.BlockchainIDContainsFold != nil {
		predicates = append(predicates, transaction.BlockchainIDContainsFold(*i.BlockchainIDContainsFold))
	}
	if i.TransactionTypeID != nil {
		predicates = append(predicates, transaction.TransactionTypeIDEQ(*i.TransactionTypeID))
	}
	if i.TransactionTypeIDNEQ != nil {
		predicates = append(predicates, transaction.TransactionTypeIDNEQ(*i.TransactionTypeIDNEQ))
	}
	if len(i.TransactionTypeIDIn) > 0 {
		predicates = append(predicates, transaction.TransactionTypeIDIn(i.TransactionTypeIDIn...))
	}
	if len(i.TransactionTypeIDNotIn) > 0 {
		predicates = append(predicates, transaction.TransactionTypeIDNotIn(i.TransactionTypeIDNotIn...))
	}
	if i.TransactionTypeIDGT != nil {
		predicates = append(predicates, transaction.TransactionTypeIDGT(*i.TransactionTypeIDGT))
	}
	if i.TransactionTypeIDGTE != nil {
		predicates = append(predicates, transaction.TransactionTypeIDGTE(*i.TransactionTypeIDGTE))
	}
	if i.TransactionTypeIDLT != nil {
		predicates = append(predicates, transaction.TransactionTypeIDLT(*i.TransactionTypeIDLT))
	}
	if i.TransactionTypeIDLTE != nil {
		predicates = append(predicates, transaction.TransactionTypeIDLTE(*i.TransactionTypeIDLTE))
	}
	if i.TransactionTypeIDContains != nil {
		predicates = append(predicates, transaction.TransactionTypeIDContains(*i.TransactionTypeIDContains))
	}
	if i.TransactionTypeIDHasPrefix != nil {
		predicates = append(predicates, transaction.TransactionTypeIDHasPrefix(*i.TransactionTypeIDHasPrefix))
	}
	if i.TransactionTypeIDHasSuffix != nil {
		predicates = append(predicates, transaction.TransactionTypeIDHasSuffix(*i.TransactionTypeIDHasSuffix))
	}
	if i.TransactionTypeIDEqualFold != nil {
		predicates = append(predicates, transaction.TransactionTypeIDEqualFold(*i.TransactionTypeIDEqualFold))
	}
	if i.TransactionTypeIDContainsFold != nil {
		predicates = append(predicates, transaction.TransactionTypeIDContainsFold(*i.TransactionTypeIDContainsFold))
	}
	if i.ExchangeID != nil {
		predicates = append(predicates, transaction.ExchangeIDEQ(*i.ExchangeID))
	}
	if i.ExchangeIDNEQ != nil {
		predicates = append(predicates, transaction.ExchangeIDNEQ(*i.ExchangeIDNEQ))
	}
	if len(i.ExchangeIDIn) > 0 {
		predicates = append(predicates, transaction.ExchangeIDIn(i.ExchangeIDIn...))
	}
	if len(i.ExchangeIDNotIn) > 0 {
		predicates = append(predicates, transaction.ExchangeIDNotIn(i.ExchangeIDNotIn...))
	}
	if i.ExchangeIDGT != nil {
		predicates = append(predicates, transaction.ExchangeIDGT(*i.ExchangeIDGT))
	}
	if i.ExchangeIDGTE != nil {
		predicates = append(predicates, transaction.ExchangeIDGTE(*i.ExchangeIDGTE))
	}
	if i.ExchangeIDLT != nil {
		predicates = append(predicates, transaction.ExchangeIDLT(*i.ExchangeIDLT))
	}
	if i.ExchangeIDLTE != nil {
		predicates = append(predicates, transaction.ExchangeIDLTE(*i.ExchangeIDLTE))
	}
	if i.ExchangeIDContains != nil {
		predicates = append(predicates, transaction.ExchangeIDContains(*i.ExchangeIDContains))
	}
	if i.ExchangeIDHasPrefix != nil {
		predicates = append(predicates, transaction.ExchangeIDHasPrefix(*i.ExchangeIDHasPrefix))
	}
	if i.ExchangeIDHasSuffix != nil {
		predicates = append(predicates, transaction.ExchangeIDHasSuffix(*i.ExchangeIDHasSuffix))
	}
	if i.ExchangeIDEqualFold != nil {
		predicates = append(predicates, transaction.ExchangeIDEqualFold(*i.ExchangeIDEqualFold))
	}
	if i.ExchangeIDContainsFold != nil {
		predicates = append(predicates, transaction.ExchangeIDContainsFold(*i.ExchangeIDContainsFold))
	}
	if i.PortfolioID != nil {
		predicates = append(predicates, transaction.PortfolioIDEQ(*i.PortfolioID))
	}
	if i.PortfolioIDNEQ != nil {
		predicates = append(predicates, transaction.PortfolioIDNEQ(*i.PortfolioIDNEQ))
	}
	if len(i.PortfolioIDIn) > 0 {
		predicates = append(predicates, transaction.PortfolioIDIn(i.PortfolioIDIn...))
	}
	if len(i.PortfolioIDNotIn) > 0 {
		predicates = append(predicates, transaction.PortfolioIDNotIn(i.PortfolioIDNotIn...))
	}
	if i.PortfolioIDGT != nil {
		predicates = append(predicates, transaction.PortfolioIDGT(*i.PortfolioIDGT))
	}
	if i.PortfolioIDGTE != nil {
		predicates = append(predicates, transaction.PortfolioIDGTE(*i.PortfolioIDGTE))
	}
	if i.PortfolioIDLT != nil {
		predicates = append(predicates, transaction.PortfolioIDLT(*i.PortfolioIDLT))
	}
	if i.PortfolioIDLTE != nil {
		predicates = append(predicates, transaction.PortfolioIDLTE(*i.PortfolioIDLTE))
	}
	if i.PortfolioIDContains != nil {
		predicates = append(predicates, transaction.PortfolioIDContains(*i.PortfolioIDContains))
	}
	if i.PortfolioIDHasPrefix != nil {
		predicates = append(predicates, transaction.PortfolioIDHasPrefix(*i.PortfolioIDHasPrefix))
	}
	if i.PortfolioIDHasSuffix != nil {
		predicates = append(predicates, transaction.PortfolioIDHasSuffix(*i.PortfolioIDHasSuffix))
	}
	if i.PortfolioIDEqualFold != nil {
		predicates = append(predicates, transaction.PortfolioIDEqualFold(*i.PortfolioIDEqualFold))
	}
	if i.PortfolioIDContainsFold != nil {
		predicates = append(predicates, transaction.PortfolioIDContainsFold(*i.PortfolioIDContainsFold))
	}
	if i.BaseAssetID != nil {
		predicates = append(predicates, transaction.BaseAssetIDEQ(*i.BaseAssetID))
	}
	if i.BaseAssetIDNEQ != nil {
		predicates = append(predicates, transaction.BaseAssetIDNEQ(*i.BaseAssetIDNEQ))
	}
	if len(i.BaseAssetIDIn) > 0 {
		predicates = append(predicates, transaction.BaseAssetIDIn(i.BaseAssetIDIn...))
	}
	if len(i.BaseAssetIDNotIn) > 0 {
		predicates = append(predicates, transaction.BaseAssetIDNotIn(i.BaseAssetIDNotIn...))
	}
	if i.BaseAssetIDGT != nil {
		predicates = append(predicates, transaction.BaseAssetIDGT(*i.BaseAssetIDGT))
	}
	if i.BaseAssetIDGTE != nil {
		predicates = append(predicates, transaction.BaseAssetIDGTE(*i.BaseAssetIDGTE))
	}
	if i.BaseAssetIDLT != nil {
		predicates = append(predicates, transaction.BaseAssetIDLT(*i.BaseAssetIDLT))
	}
	if i.BaseAssetIDLTE != nil {
		predicates = append(predicates, transaction.BaseAssetIDLTE(*i.BaseAssetIDLTE))
	}
	if i.BaseAssetIDContains != nil {
		predicates = append(predicates, transaction.BaseAssetIDContains(*i.BaseAssetIDContains))
	}
	if i.BaseAssetIDHasPrefix != nil {
		predicates = append(predicates, transaction.BaseAssetIDHasPrefix(*i.BaseAssetIDHasPrefix))
	}
	if i.BaseAssetIDHasSuffix != nil {
		predicates = append(predicates, transaction.BaseAssetIDHasSuffix(*i.BaseAssetIDHasSuffix))
	}
	if i.BaseAssetIDEqualFold != nil {
		predicates = append(predicates, transaction.BaseAssetIDEqualFold(*i.BaseAssetIDEqualFold))
	}
	if i.BaseAssetIDContainsFold != nil {
		predicates = append(predicates, transaction.BaseAssetIDContainsFold(*i.BaseAssetIDContainsFold))
	}
	if i.QuoteAssetID != nil {
		predicates = append(predicates, transaction.QuoteAssetIDEQ(*i.QuoteAssetID))
	}
	if i.QuoteAssetIDNEQ != nil {
		predicates = append(predicates, transaction.QuoteAssetIDNEQ(*i.QuoteAssetIDNEQ))
	}
	if len(i.QuoteAssetIDIn) > 0 {
		predicates = append(predicates, transaction.QuoteAssetIDIn(i.QuoteAssetIDIn...))
	}
	if len(i.QuoteAssetIDNotIn) > 0 {
		predicates = append(predicates, transaction.QuoteAssetIDNotIn(i.QuoteAssetIDNotIn...))
	}
	if i.QuoteAssetIDGT != nil {
		predicates = append(predicates, transaction.QuoteAssetIDGT(*i.QuoteAssetIDGT))
	}
	if i.QuoteAssetIDGTE != nil {
		predicates = append(predicates, transaction.QuoteAssetIDGTE(*i.QuoteAssetIDGTE))
	}
	if i.QuoteAssetIDLT != nil {
		predicates = append(predicates, transaction.QuoteAssetIDLT(*i.QuoteAssetIDLT))
	}
	if i.QuoteAssetIDLTE != nil {
		predicates = append(predicates, transaction.QuoteAssetIDLTE(*i.QuoteAssetIDLTE))
	}
	if i.QuoteAssetIDContains != nil {
		predicates = append(predicates, transaction.QuoteAssetIDContains(*i.QuoteAssetIDContains))
	}
	if i.QuoteAssetIDHasPrefix != nil {
		predicates = append(predicates, transaction.QuoteAssetIDHasPrefix(*i.QuoteAssetIDHasPrefix))
	}
	if i.QuoteAssetIDHasSuffix != nil {
		predicates = append(predicates, transaction.QuoteAssetIDHasSuffix(*i.QuoteAssetIDHasSuffix))
	}
	if i.QuoteAssetIDIsNil {
		predicates = append(predicates, transaction.QuoteAssetIDIsNil())
	}
	if i.QuoteAssetIDNotNil {
		predicates = append(predicates, transaction.QuoteAssetIDNotNil())
	}
	if i.QuoteAssetIDEqualFold != nil {
		predicates = append(predicates, transaction.QuoteAssetIDEqualFold(*i.QuoteAssetIDEqualFold))
	}
	if i.QuoteAssetIDContainsFold != nil {
		predicates = append(predicates, transaction.QuoteAssetIDContainsFold(*i.QuoteAssetIDContainsFold))
	}

	if i.HasTransactionType != nil {
		p := transaction.HasTransactionType()
		if !*i.HasTransactionType {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionTypeWith) > 0 {
		with := make([]predicate.TransactionType, 0, len(i.HasTransactionTypeWith))
		for _, w := range i.HasTransactionTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasTransactionTypeWith(with...))
	}
	if i.HasBaseAsset != nil {
		p := transaction.HasBaseAsset()
		if !*i.HasBaseAsset {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBaseAssetWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasBaseAssetWith))
		for _, w := range i.HasBaseAssetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBaseAssetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasBaseAssetWith(with...))
	}
	if i.HasQuoteAsset != nil {
		p := transaction.HasQuoteAsset()
		if !*i.HasQuoteAsset {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQuoteAssetWith) > 0 {
		with := make([]predicate.Asset, 0, len(i.HasQuoteAssetWith))
		for _, w := range i.HasQuoteAssetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQuoteAssetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasQuoteAssetWith(with...))
	}
	if i.HasPortfolio != nil {
		p := transaction.HasPortfolio()
		if !*i.HasPortfolio {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPortfolioWith) > 0 {
		with := make([]predicate.Portfolio, 0, len(i.HasPortfolioWith))
		for _, w := range i.HasPortfolioWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPortfolioWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasPortfolioWith(with...))
	}
	if i.HasExchange != nil {
		p := transaction.HasExchange()
		if !*i.HasExchange {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExchangeWith) > 0 {
		with := make([]predicate.Exchange, 0, len(i.HasExchangeWith))
		for _, w := range i.HasExchangeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExchangeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasExchangeWith(with...))
	}
	if i.HasBlockchain != nil {
		p := transaction.HasBlockchain()
		if !*i.HasBlockchain {
			p = transaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBlockchainWith) > 0 {
		with := make([]predicate.Blockchain, 0, len(i.HasBlockchainWith))
		for _, w := range i.HasBlockchainWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBlockchainWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transaction.HasBlockchainWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTransactionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return transaction.And(predicates...), nil
	}
}

// TransactionTypeWhereInput represents a where input for filtering TransactionType queries.
type TransactionTypeWhereInput struct {
	Predicates []predicate.TransactionType  `json:"-"`
	Not        *TransactionTypeWhereInput   `json:"not,omitempty"`
	Or         []*TransactionTypeWhereInput `json:"or,omitempty"`
	And        []*TransactionTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.PULID  `json:"id,omitempty"`
	IDNEQ   *pulid.PULID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.PULID `json:"idIn,omitempty"`
	IDNotIn []pulid.PULID `json:"idNotIn,omitempty"`
	IDGT    *pulid.PULID  `json:"idGT,omitempty"`
	IDGTE   *pulid.PULID  `json:"idGTE,omitempty"`
	IDLT    *pulid.PULID  `json:"idLT,omitempty"`
	IDLTE   *pulid.PULID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "value" field predicates.
	Value      *transactiontype.Value  `json:"value,omitempty"`
	ValueNEQ   *transactiontype.Value  `json:"valueNEQ,omitempty"`
	ValueIn    []transactiontype.Value `json:"valueIn,omitempty"`
	ValueNotIn []transactiontype.Value `json:"valueNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "transactions" edge predicates.
	HasTransactions     *bool                    `json:"hasTransactions,omitempty"`
	HasTransactionsWith []*TransactionWhereInput `json:"hasTransactionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TransactionTypeWhereInput) AddPredicates(predicates ...predicate.TransactionType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TransactionTypeWhereInput filter on the TransactionTypeQuery builder.
func (i *TransactionTypeWhereInput) Filter(q *TransactionTypeQuery) (*TransactionTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTransactionTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTransactionTypeWhereInput is returned in case the TransactionTypeWhereInput is empty.
var ErrEmptyTransactionTypeWhereInput = errors.New("ent: empty predicate TransactionTypeWhereInput")

// P returns a predicate for filtering transactiontypes.
// An error is returned if the input is empty or invalid.
func (i *TransactionTypeWhereInput) P() (predicate.TransactionType, error) {
	var predicates []predicate.TransactionType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, transactiontype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TransactionType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, transactiontype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TransactionType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, transactiontype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, transactiontype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, transactiontype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, transactiontype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, transactiontype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, transactiontype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, transactiontype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, transactiontype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, transactiontype.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, transactiontype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, transactiontype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, transactiontype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, transactiontype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, transactiontype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, transactiontype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, transactiontype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, transactiontype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, transactiontype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, transactiontype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, transactiontype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, transactiontype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, transactiontype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, transactiontype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, transactiontype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, transactiontype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, transactiontype.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, transactiontype.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, transactiontype.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, transactiontype.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, transactiontype.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, transactiontype.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, transactiontype.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, transactiontype.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, transactiontype.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, transactiontype.DeletedAtNotNil())
	}
	if i.Value != nil {
		predicates = append(predicates, transactiontype.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, transactiontype.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, transactiontype.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, transactiontype.ValueNotIn(i.ValueNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, transactiontype.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, transactiontype.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, transactiontype.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, transactiontype.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, transactiontype.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, transactiontype.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, transactiontype.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, transactiontype.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, transactiontype.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, transactiontype.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, transactiontype.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, transactiontype.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, transactiontype.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, transactiontype.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, transactiontype.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasTransactions != nil {
		p := transactiontype.HasTransactions()
		if !*i.HasTransactions {
			p = transactiontype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTransactionsWith) > 0 {
		with := make([]predicate.Transaction, 0, len(i.HasTransactionsWith))
		for _, w := range i.HasTransactionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTransactionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, transactiontype.HasTransactionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTransactionTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return transactiontype.And(predicates...), nil
	}
}
