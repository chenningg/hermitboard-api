// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/authtype"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/connection"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/predicate"
	"github.com/chenningg/hermitboard-api/ent/source"
	"github.com/chenningg/hermitboard-api/ent/sourcetype"
	"github.com/chenningg/hermitboard-api/ent/staffaccount"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"
	"github.com/chenningg/hermitboard-api/pulid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount         = "Account"
	TypeAsset           = "Asset"
	TypeAssetClass      = "AssetClass"
	TypeAuthRole        = "AuthRole"
	TypeAuthType        = "AuthType"
	TypeBlockchain      = "Blockchain"
	TypeConnection      = "Connection"
	TypeCryptocurrency  = "Cryptocurrency"
	TypeDailyAssetPrice = "DailyAssetPrice"
	TypeExchange        = "Exchange"
	TypePortfolio       = "Portfolio"
	TypeSource          = "Source"
	TypeSourceType      = "SourceType"
	TypeStaffAccount    = "StaffAccount"
	TypeTransaction     = "Transaction"
	TypeTransactionType = "TransactionType"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	nickname            *string
	email               *string
	password            *string
	password_updated_at *time.Time
	clearedFields       map[string]struct{}
	auth_roles          map[pulid.PULID]struct{}
	removedauth_roles   map[pulid.PULID]struct{}
	clearedauth_roles   bool
	portfolios          map[pulid.PULID]struct{}
	removedportfolios   map[pulid.PULID]struct{}
	clearedportfolios   bool
	auth_type           *pulid.PULID
	clearedauth_type    bool
	connections         map[pulid.PULID]struct{}
	removedconnections  map[pulid.PULID]struct{}
	clearedconnections  bool
	done                bool
	oldValue            func(context.Context) (*Account, error)
	predicates          []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id pulid.PULID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *AccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[account.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *AccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[account.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, account.FieldPassword)
}

// SetPasswordUpdatedAt sets the "password_updated_at" field.
func (m *AccountMutation) SetPasswordUpdatedAt(t time.Time) {
	m.password_updated_at = &t
}

// PasswordUpdatedAt returns the value of the "password_updated_at" field in the mutation.
func (m *AccountMutation) PasswordUpdatedAt() (r time.Time, exists bool) {
	v := m.password_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordUpdatedAt returns the old "password_updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordUpdatedAt: %w", err)
	}
	return oldValue.PasswordUpdatedAt, nil
}

// ResetPasswordUpdatedAt resets all changes to the "password_updated_at" field.
func (m *AccountMutation) ResetPasswordUpdatedAt() {
	m.password_updated_at = nil
}

// SetAuthTypeID sets the "auth_type_id" field.
func (m *AccountMutation) SetAuthTypeID(pu pulid.PULID) {
	m.auth_type = &pu
}

// AuthTypeID returns the value of the "auth_type_id" field in the mutation.
func (m *AccountMutation) AuthTypeID() (r pulid.PULID, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTypeID returns the old "auth_type_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAuthTypeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTypeID: %w", err)
	}
	return oldValue.AuthTypeID, nil
}

// ResetAuthTypeID resets all changes to the "auth_type_id" field.
func (m *AccountMutation) ResetAuthTypeID() {
	m.auth_type = nil
}

// AddAuthRoleIDs adds the "auth_roles" edge to the AuthRole entity by ids.
func (m *AccountMutation) AddAuthRoleIDs(ids ...pulid.PULID) {
	if m.auth_roles == nil {
		m.auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.auth_roles[ids[i]] = struct{}{}
	}
}

// ClearAuthRoles clears the "auth_roles" edge to the AuthRole entity.
func (m *AccountMutation) ClearAuthRoles() {
	m.clearedauth_roles = true
}

// AuthRolesCleared reports if the "auth_roles" edge to the AuthRole entity was cleared.
func (m *AccountMutation) AuthRolesCleared() bool {
	return m.clearedauth_roles
}

// RemoveAuthRoleIDs removes the "auth_roles" edge to the AuthRole entity by IDs.
func (m *AccountMutation) RemoveAuthRoleIDs(ids ...pulid.PULID) {
	if m.removedauth_roles == nil {
		m.removedauth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.auth_roles, ids[i])
		m.removedauth_roles[ids[i]] = struct{}{}
	}
}

// RemovedAuthRoles returns the removed IDs of the "auth_roles" edge to the AuthRole entity.
func (m *AccountMutation) RemovedAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.removedauth_roles {
		ids = append(ids, id)
	}
	return
}

// AuthRolesIDs returns the "auth_roles" edge IDs in the mutation.
func (m *AccountMutation) AuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.auth_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAuthRoles resets all changes to the "auth_roles" edge.
func (m *AccountMutation) ResetAuthRoles() {
	m.auth_roles = nil
	m.clearedauth_roles = false
	m.removedauth_roles = nil
}

// AddPortfolioIDs adds the "portfolios" edge to the Portfolio entity by ids.
func (m *AccountMutation) AddPortfolioIDs(ids ...pulid.PULID) {
	if m.portfolios == nil {
		m.portfolios = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.portfolios[ids[i]] = struct{}{}
	}
}

// ClearPortfolios clears the "portfolios" edge to the Portfolio entity.
func (m *AccountMutation) ClearPortfolios() {
	m.clearedportfolios = true
}

// PortfoliosCleared reports if the "portfolios" edge to the Portfolio entity was cleared.
func (m *AccountMutation) PortfoliosCleared() bool {
	return m.clearedportfolios
}

// RemovePortfolioIDs removes the "portfolios" edge to the Portfolio entity by IDs.
func (m *AccountMutation) RemovePortfolioIDs(ids ...pulid.PULID) {
	if m.removedportfolios == nil {
		m.removedportfolios = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.portfolios, ids[i])
		m.removedportfolios[ids[i]] = struct{}{}
	}
}

// RemovedPortfolios returns the removed IDs of the "portfolios" edge to the Portfolio entity.
func (m *AccountMutation) RemovedPortfoliosIDs() (ids []pulid.PULID) {
	for id := range m.removedportfolios {
		ids = append(ids, id)
	}
	return
}

// PortfoliosIDs returns the "portfolios" edge IDs in the mutation.
func (m *AccountMutation) PortfoliosIDs() (ids []pulid.PULID) {
	for id := range m.portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolios resets all changes to the "portfolios" edge.
func (m *AccountMutation) ResetPortfolios() {
	m.portfolios = nil
	m.clearedportfolios = false
	m.removedportfolios = nil
}

// ClearAuthType clears the "auth_type" edge to the AuthType entity.
func (m *AccountMutation) ClearAuthType() {
	m.clearedauth_type = true
}

// AuthTypeCleared reports if the "auth_type" edge to the AuthType entity was cleared.
func (m *AccountMutation) AuthTypeCleared() bool {
	return m.clearedauth_type
}

// AuthTypeIDs returns the "auth_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthTypeID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) AuthTypeIDs() (ids []pulid.PULID) {
	if id := m.auth_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthType resets all changes to the "auth_type" edge.
func (m *AccountMutation) ResetAuthType() {
	m.auth_type = nil
	m.clearedauth_type = false
}

// AddConnectionIDs adds the "connections" edge to the Connection entity by ids.
func (m *AccountMutation) AddConnectionIDs(ids ...pulid.PULID) {
	if m.connections == nil {
		m.connections = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.connections[ids[i]] = struct{}{}
	}
}

// ClearConnections clears the "connections" edge to the Connection entity.
func (m *AccountMutation) ClearConnections() {
	m.clearedconnections = true
}

// ConnectionsCleared reports if the "connections" edge to the Connection entity was cleared.
func (m *AccountMutation) ConnectionsCleared() bool {
	return m.clearedconnections
}

// RemoveConnectionIDs removes the "connections" edge to the Connection entity by IDs.
func (m *AccountMutation) RemoveConnectionIDs(ids ...pulid.PULID) {
	if m.removedconnections == nil {
		m.removedconnections = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.connections, ids[i])
		m.removedconnections[ids[i]] = struct{}{}
	}
}

// RemovedConnections returns the removed IDs of the "connections" edge to the Connection entity.
func (m *AccountMutation) RemovedConnectionsIDs() (ids []pulid.PULID) {
	for id := range m.removedconnections {
		ids = append(ids, id)
	}
	return
}

// ConnectionsIDs returns the "connections" edge IDs in the mutation.
func (m *AccountMutation) ConnectionsIDs() (ids []pulid.PULID) {
	for id := range m.connections {
		ids = append(ids, id)
	}
	return
}

// ResetConnections resets all changes to the "connections" edge.
func (m *AccountMutation) ResetConnections() {
	m.connections = nil
	m.clearedconnections = false
	m.removedconnections = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.password_updated_at != nil {
		fields = append(fields, account.FieldPasswordUpdatedAt)
	}
	if m.auth_type != nil {
		fields = append(fields, account.FieldAuthTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldEmail:
		return m.Email()
	case account.FieldPassword:
		return m.Password()
	case account.FieldPasswordUpdatedAt:
		return m.PasswordUpdatedAt()
	case account.FieldAuthTypeID:
		return m.AuthTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldPasswordUpdatedAt:
		return m.OldPasswordUpdatedAt(ctx)
	case account.FieldAuthTypeID:
		return m.OldAuthTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldPasswordUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordUpdatedAt(v)
		return nil
	case account.FieldAuthTypeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldPassword) {
		fields = append(fields, account.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldPasswordUpdatedAt:
		m.ResetPasswordUpdatedAt()
		return nil
	case account.FieldAuthTypeID:
		m.ResetAuthTypeID()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.auth_roles != nil {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.portfolios != nil {
		edges = append(edges, account.EdgePortfolios)
	}
	if m.auth_type != nil {
		edges = append(edges, account.EdgeAuthType)
	}
	if m.connections != nil {
		edges = append(edges, account.EdgeConnections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.auth_roles))
		for id := range m.auth_roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.portfolios))
		for id := range m.portfolios {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAuthType:
		if id := m.auth_type; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeConnections:
		ids := make([]ent.Value, 0, len(m.connections))
		for id := range m.connections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedauth_roles != nil {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.removedportfolios != nil {
		edges = append(edges, account.EdgePortfolios)
	}
	if m.removedconnections != nil {
		edges = append(edges, account.EdgeConnections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.removedauth_roles))
		for id := range m.removedauth_roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.removedportfolios))
		for id := range m.removedportfolios {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeConnections:
		ids := make([]ent.Value, 0, len(m.removedconnections))
		for id := range m.removedconnections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedauth_roles {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.clearedportfolios {
		edges = append(edges, account.EdgePortfolios)
	}
	if m.clearedauth_type {
		edges = append(edges, account.EdgeAuthType)
	}
	if m.clearedconnections {
		edges = append(edges, account.EdgeConnections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeAuthRoles:
		return m.clearedauth_roles
	case account.EdgePortfolios:
		return m.clearedportfolios
	case account.EdgeAuthType:
		return m.clearedauth_type
	case account.EdgeConnections:
		return m.clearedconnections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeAuthType:
		m.ClearAuthType()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeAuthRoles:
		m.ResetAuthRoles()
		return nil
	case account.EdgePortfolios:
		m.ResetPortfolios()
		return nil
	case account.EdgeAuthType:
		m.ResetAuthType()
		return nil
	case account.EdgeConnections:
		m.ResetConnections()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                        Op
	typ                       string
	id                        *pulid.PULID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	asset_class               *pulid.PULID
	clearedasset_class        bool
	cryptocurrency            *pulid.PULID
	clearedcryptocurrency     bool
	transaction_bases         map[pulid.PULID]struct{}
	removedtransaction_bases  map[pulid.PULID]struct{}
	clearedtransaction_bases  bool
	transaction_quotes        map[pulid.PULID]struct{}
	removedtransaction_quotes map[pulid.PULID]struct{}
	clearedtransaction_quotes bool
	daily_asset_prices        map[pulid.PULID]struct{}
	removeddaily_asset_prices map[pulid.PULID]struct{}
	cleareddaily_asset_prices bool
	done                      bool
	oldValue                  func(context.Context) (*Asset, error)
	predicates                []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id pulid.PULID) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[asset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[asset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, asset.FieldDeletedAt)
}

// SetAssetClassID sets the "asset_class_id" field.
func (m *AssetMutation) SetAssetClassID(pu pulid.PULID) {
	m.asset_class = &pu
}

// AssetClassID returns the value of the "asset_class_id" field in the mutation.
func (m *AssetMutation) AssetClassID() (r pulid.PULID, exists bool) {
	v := m.asset_class
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetClassID returns the old "asset_class_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAssetClassID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetClassID: %w", err)
	}
	return oldValue.AssetClassID, nil
}

// ResetAssetClassID resets all changes to the "asset_class_id" field.
func (m *AssetMutation) ResetAssetClassID() {
	m.asset_class = nil
}

// ClearAssetClass clears the "asset_class" edge to the AssetClass entity.
func (m *AssetMutation) ClearAssetClass() {
	m.clearedasset_class = true
}

// AssetClassCleared reports if the "asset_class" edge to the AssetClass entity was cleared.
func (m *AssetMutation) AssetClassCleared() bool {
	return m.clearedasset_class
}

// AssetClassIDs returns the "asset_class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetClassID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) AssetClassIDs() (ids []pulid.PULID) {
	if id := m.asset_class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssetClass resets all changes to the "asset_class" edge.
func (m *AssetMutation) ResetAssetClass() {
	m.asset_class = nil
	m.clearedasset_class = false
}

// SetCryptocurrencyID sets the "cryptocurrency" edge to the Cryptocurrency entity by id.
func (m *AssetMutation) SetCryptocurrencyID(id pulid.PULID) {
	m.cryptocurrency = &id
}

// ClearCryptocurrency clears the "cryptocurrency" edge to the Cryptocurrency entity.
func (m *AssetMutation) ClearCryptocurrency() {
	m.clearedcryptocurrency = true
}

// CryptocurrencyCleared reports if the "cryptocurrency" edge to the Cryptocurrency entity was cleared.
func (m *AssetMutation) CryptocurrencyCleared() bool {
	return m.clearedcryptocurrency
}

// CryptocurrencyID returns the "cryptocurrency" edge ID in the mutation.
func (m *AssetMutation) CryptocurrencyID() (id pulid.PULID, exists bool) {
	if m.cryptocurrency != nil {
		return *m.cryptocurrency, true
	}
	return
}

// CryptocurrencyIDs returns the "cryptocurrency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CryptocurrencyID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) CryptocurrencyIDs() (ids []pulid.PULID) {
	if id := m.cryptocurrency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCryptocurrency resets all changes to the "cryptocurrency" edge.
func (m *AssetMutation) ResetCryptocurrency() {
	m.cryptocurrency = nil
	m.clearedcryptocurrency = false
}

// AddTransactionBasisIDs adds the "transaction_bases" edge to the Transaction entity by ids.
func (m *AssetMutation) AddTransactionBasisIDs(ids ...pulid.PULID) {
	if m.transaction_bases == nil {
		m.transaction_bases = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transaction_bases[ids[i]] = struct{}{}
	}
}

// ClearTransactionBases clears the "transaction_bases" edge to the Transaction entity.
func (m *AssetMutation) ClearTransactionBases() {
	m.clearedtransaction_bases = true
}

// TransactionBasesCleared reports if the "transaction_bases" edge to the Transaction entity was cleared.
func (m *AssetMutation) TransactionBasesCleared() bool {
	return m.clearedtransaction_bases
}

// RemoveTransactionBasisIDs removes the "transaction_bases" edge to the Transaction entity by IDs.
func (m *AssetMutation) RemoveTransactionBasisIDs(ids ...pulid.PULID) {
	if m.removedtransaction_bases == nil {
		m.removedtransaction_bases = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transaction_bases, ids[i])
		m.removedtransaction_bases[ids[i]] = struct{}{}
	}
}

// RemovedTransactionBases returns the removed IDs of the "transaction_bases" edge to the Transaction entity.
func (m *AssetMutation) RemovedTransactionBasesIDs() (ids []pulid.PULID) {
	for id := range m.removedtransaction_bases {
		ids = append(ids, id)
	}
	return
}

// TransactionBasesIDs returns the "transaction_bases" edge IDs in the mutation.
func (m *AssetMutation) TransactionBasesIDs() (ids []pulid.PULID) {
	for id := range m.transaction_bases {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionBases resets all changes to the "transaction_bases" edge.
func (m *AssetMutation) ResetTransactionBases() {
	m.transaction_bases = nil
	m.clearedtransaction_bases = false
	m.removedtransaction_bases = nil
}

// AddTransactionQuoteIDs adds the "transaction_quotes" edge to the Transaction entity by ids.
func (m *AssetMutation) AddTransactionQuoteIDs(ids ...pulid.PULID) {
	if m.transaction_quotes == nil {
		m.transaction_quotes = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transaction_quotes[ids[i]] = struct{}{}
	}
}

// ClearTransactionQuotes clears the "transaction_quotes" edge to the Transaction entity.
func (m *AssetMutation) ClearTransactionQuotes() {
	m.clearedtransaction_quotes = true
}

// TransactionQuotesCleared reports if the "transaction_quotes" edge to the Transaction entity was cleared.
func (m *AssetMutation) TransactionQuotesCleared() bool {
	return m.clearedtransaction_quotes
}

// RemoveTransactionQuoteIDs removes the "transaction_quotes" edge to the Transaction entity by IDs.
func (m *AssetMutation) RemoveTransactionQuoteIDs(ids ...pulid.PULID) {
	if m.removedtransaction_quotes == nil {
		m.removedtransaction_quotes = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transaction_quotes, ids[i])
		m.removedtransaction_quotes[ids[i]] = struct{}{}
	}
}

// RemovedTransactionQuotes returns the removed IDs of the "transaction_quotes" edge to the Transaction entity.
func (m *AssetMutation) RemovedTransactionQuotesIDs() (ids []pulid.PULID) {
	for id := range m.removedtransaction_quotes {
		ids = append(ids, id)
	}
	return
}

// TransactionQuotesIDs returns the "transaction_quotes" edge IDs in the mutation.
func (m *AssetMutation) TransactionQuotesIDs() (ids []pulid.PULID) {
	for id := range m.transaction_quotes {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionQuotes resets all changes to the "transaction_quotes" edge.
func (m *AssetMutation) ResetTransactionQuotes() {
	m.transaction_quotes = nil
	m.clearedtransaction_quotes = false
	m.removedtransaction_quotes = nil
}

// AddDailyAssetPriceIDs adds the "daily_asset_prices" edge to the DailyAssetPrice entity by ids.
func (m *AssetMutation) AddDailyAssetPriceIDs(ids ...pulid.PULID) {
	if m.daily_asset_prices == nil {
		m.daily_asset_prices = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.daily_asset_prices[ids[i]] = struct{}{}
	}
}

// ClearDailyAssetPrices clears the "daily_asset_prices" edge to the DailyAssetPrice entity.
func (m *AssetMutation) ClearDailyAssetPrices() {
	m.cleareddaily_asset_prices = true
}

// DailyAssetPricesCleared reports if the "daily_asset_prices" edge to the DailyAssetPrice entity was cleared.
func (m *AssetMutation) DailyAssetPricesCleared() bool {
	return m.cleareddaily_asset_prices
}

// RemoveDailyAssetPriceIDs removes the "daily_asset_prices" edge to the DailyAssetPrice entity by IDs.
func (m *AssetMutation) RemoveDailyAssetPriceIDs(ids ...pulid.PULID) {
	if m.removeddaily_asset_prices == nil {
		m.removeddaily_asset_prices = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.daily_asset_prices, ids[i])
		m.removeddaily_asset_prices[ids[i]] = struct{}{}
	}
}

// RemovedDailyAssetPrices returns the removed IDs of the "daily_asset_prices" edge to the DailyAssetPrice entity.
func (m *AssetMutation) RemovedDailyAssetPricesIDs() (ids []pulid.PULID) {
	for id := range m.removeddaily_asset_prices {
		ids = append(ids, id)
	}
	return
}

// DailyAssetPricesIDs returns the "daily_asset_prices" edge IDs in the mutation.
func (m *AssetMutation) DailyAssetPricesIDs() (ids []pulid.PULID) {
	for id := range m.daily_asset_prices {
		ids = append(ids, id)
	}
	return
}

// ResetDailyAssetPrices resets all changes to the "daily_asset_prices" edge.
func (m *AssetMutation) ResetDailyAssetPrices() {
	m.daily_asset_prices = nil
	m.cleareddaily_asset_prices = false
	m.removeddaily_asset_prices = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, asset.FieldDeletedAt)
	}
	if m.asset_class != nil {
		fields = append(fields, asset.FieldAssetClassID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	case asset.FieldDeletedAt:
		return m.DeletedAt()
	case asset.FieldAssetClassID:
		return m.AssetClassID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case asset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case asset.FieldAssetClassID:
		return m.OldAssetClassID(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case asset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case asset.FieldAssetClassID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetClassID(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldDeletedAt) {
		fields = append(fields, asset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case asset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case asset.FieldAssetClassID:
		m.ResetAssetClassID()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.asset_class != nil {
		edges = append(edges, asset.EdgeAssetClass)
	}
	if m.cryptocurrency != nil {
		edges = append(edges, asset.EdgeCryptocurrency)
	}
	if m.transaction_bases != nil {
		edges = append(edges, asset.EdgeTransactionBases)
	}
	if m.transaction_quotes != nil {
		edges = append(edges, asset.EdgeTransactionQuotes)
	}
	if m.daily_asset_prices != nil {
		edges = append(edges, asset.EdgeDailyAssetPrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeAssetClass:
		if id := m.asset_class; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeCryptocurrency:
		if id := m.cryptocurrency; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeTransactionBases:
		ids := make([]ent.Value, 0, len(m.transaction_bases))
		for id := range m.transaction_bases {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTransactionQuotes:
		ids := make([]ent.Value, 0, len(m.transaction_quotes))
		for id := range m.transaction_quotes {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDailyAssetPrices:
		ids := make([]ent.Value, 0, len(m.daily_asset_prices))
		for id := range m.daily_asset_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtransaction_bases != nil {
		edges = append(edges, asset.EdgeTransactionBases)
	}
	if m.removedtransaction_quotes != nil {
		edges = append(edges, asset.EdgeTransactionQuotes)
	}
	if m.removeddaily_asset_prices != nil {
		edges = append(edges, asset.EdgeDailyAssetPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeTransactionBases:
		ids := make([]ent.Value, 0, len(m.removedtransaction_bases))
		for id := range m.removedtransaction_bases {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTransactionQuotes:
		ids := make([]ent.Value, 0, len(m.removedtransaction_quotes))
		for id := range m.removedtransaction_quotes {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDailyAssetPrices:
		ids := make([]ent.Value, 0, len(m.removeddaily_asset_prices))
		for id := range m.removeddaily_asset_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedasset_class {
		edges = append(edges, asset.EdgeAssetClass)
	}
	if m.clearedcryptocurrency {
		edges = append(edges, asset.EdgeCryptocurrency)
	}
	if m.clearedtransaction_bases {
		edges = append(edges, asset.EdgeTransactionBases)
	}
	if m.clearedtransaction_quotes {
		edges = append(edges, asset.EdgeTransactionQuotes)
	}
	if m.cleareddaily_asset_prices {
		edges = append(edges, asset.EdgeDailyAssetPrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeAssetClass:
		return m.clearedasset_class
	case asset.EdgeCryptocurrency:
		return m.clearedcryptocurrency
	case asset.EdgeTransactionBases:
		return m.clearedtransaction_bases
	case asset.EdgeTransactionQuotes:
		return m.clearedtransaction_quotes
	case asset.EdgeDailyAssetPrices:
		return m.cleareddaily_asset_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeAssetClass:
		m.ClearAssetClass()
		return nil
	case asset.EdgeCryptocurrency:
		m.ClearCryptocurrency()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeAssetClass:
		m.ResetAssetClass()
		return nil
	case asset.EdgeCryptocurrency:
		m.ResetCryptocurrency()
		return nil
	case asset.EdgeTransactionBases:
		m.ResetTransactionBases()
		return nil
	case asset.EdgeTransactionQuotes:
		m.ResetTransactionQuotes()
		return nil
	case asset.EdgeDailyAssetPrices:
		m.ResetDailyAssetPrices()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AssetClassMutation represents an operation that mutates the AssetClass nodes in the graph.
type AssetClassMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.PULID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	value         *assetclass.Value
	description   *string
	clearedFields map[string]struct{}
	assets        map[pulid.PULID]struct{}
	removedassets map[pulid.PULID]struct{}
	clearedassets bool
	done          bool
	oldValue      func(context.Context) (*AssetClass, error)
	predicates    []predicate.AssetClass
}

var _ ent.Mutation = (*AssetClassMutation)(nil)

// assetclassOption allows management of the mutation configuration using functional options.
type assetclassOption func(*AssetClassMutation)

// newAssetClassMutation creates new mutation for the AssetClass entity.
func newAssetClassMutation(c config, op Op, opts ...assetclassOption) *AssetClassMutation {
	m := &AssetClassMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetClassID sets the ID field of the mutation.
func withAssetClassID(id pulid.PULID) assetclassOption {
	return func(m *AssetClassMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetClass
		)
		m.oldValue = func(ctx context.Context) (*AssetClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetClass sets the old AssetClass of the mutation.
func withAssetClass(node *AssetClass) assetclassOption {
	return func(m *AssetClassMutation) {
		m.oldValue = func(context.Context) (*AssetClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetClass entities.
func (m *AssetClassMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetClassMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetClassMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssetClassMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssetClassMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssetClassMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assetclass.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssetClassMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assetclass.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssetClassMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assetclass.FieldDeletedAt)
}

// SetValue sets the "value" field.
func (m *AssetClassMutation) SetValue(a assetclass.Value) {
	m.value = &a
}

// Value returns the value of the "value" field in the mutation.
func (m *AssetClassMutation) Value() (r assetclass.Value, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldValue(ctx context.Context) (v assetclass.Value, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AssetClassMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *AssetClassMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssetClassMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssetClassMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assetclass.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssetClassMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assetclass.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssetClassMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assetclass.FieldDescription)
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetClassMutation) AddAssetIDs(ids ...pulid.PULID) {
	if m.assets == nil {
		m.assets = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetClassMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetClassMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetClassMutation) RemoveAssetIDs(ids ...pulid.PULID) {
	if m.removedassets == nil {
		m.removedassets = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetClassMutation) RemovedAssetsIDs() (ids []pulid.PULID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetClassMutation) AssetsIDs() (ids []pulid.PULID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetClassMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the AssetClassMutation builder.
func (m *AssetClassMutation) Where(ps ...predicate.AssetClass) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AssetClass).
func (m *AssetClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetClassMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, assetclass.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assetclass.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, assetclass.FieldDeletedAt)
	}
	if m.value != nil {
		fields = append(fields, assetclass.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, assetclass.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetclass.FieldCreatedAt:
		return m.CreatedAt()
	case assetclass.FieldUpdatedAt:
		return m.UpdatedAt()
	case assetclass.FieldDeletedAt:
		return m.DeletedAt()
	case assetclass.FieldValue:
		return m.Value()
	case assetclass.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetclass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assetclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assetclass.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assetclass.FieldValue:
		return m.OldValue(ctx)
	case assetclass.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AssetClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetclass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assetclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assetclass.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assetclass.FieldValue:
		v, ok := value.(assetclass.Value)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case assetclass.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AssetClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assetclass.FieldDeletedAt) {
		fields = append(fields, assetclass.FieldDeletedAt)
	}
	if m.FieldCleared(assetclass.FieldDescription) {
		fields = append(fields, assetclass.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetClassMutation) ClearField(name string) error {
	switch name {
	case assetclass.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assetclass.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetClassMutation) ResetField(name string) error {
	switch name {
	case assetclass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assetclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assetclass.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assetclass.FieldValue:
		m.ResetValue()
		return nil
	case assetclass.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assets != nil {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetclass.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedassets != nil {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assetclass.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassets {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetClassMutation) EdgeCleared(name string) bool {
	switch name {
	case assetclass.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetClassMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetClassMutation) ResetEdge(name string) error {
	switch name {
	case assetclass.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown AssetClass edge %s", name)
}

// AuthRoleMutation represents an operation that mutates the AuthRole nodes in the graph.
type AuthRoleMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.PULID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	value                 *authrole.Value
	description           *string
	clearedFields         map[string]struct{}
	accounts              map[pulid.PULID]struct{}
	removedaccounts       map[pulid.PULID]struct{}
	clearedaccounts       bool
	staff_accounts        map[pulid.PULID]struct{}
	removedstaff_accounts map[pulid.PULID]struct{}
	clearedstaff_accounts bool
	done                  bool
	oldValue              func(context.Context) (*AuthRole, error)
	predicates            []predicate.AuthRole
}

var _ ent.Mutation = (*AuthRoleMutation)(nil)

// authroleOption allows management of the mutation configuration using functional options.
type authroleOption func(*AuthRoleMutation)

// newAuthRoleMutation creates new mutation for the AuthRole entity.
func newAuthRoleMutation(c config, op Op, opts ...authroleOption) *AuthRoleMutation {
	m := &AuthRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRoleID sets the ID field of the mutation.
func withAuthRoleID(id pulid.PULID) authroleOption {
	return func(m *AuthRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRole
		)
		m.oldValue = func(ctx context.Context) (*AuthRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRole sets the old AuthRole of the mutation.
func withAuthRole(node *AuthRole) authroleOption {
	return func(m *AuthRoleMutation) {
		m.oldValue = func(context.Context) (*AuthRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthRole entities.
func (m *AuthRoleMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRoleMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRoleMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[authrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[authrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, authrole.FieldDeletedAt)
}

// SetValue sets the "value" field.
func (m *AuthRoleMutation) SetValue(a authrole.Value) {
	m.value = &a
}

// Value returns the value of the "value" field in the mutation.
func (m *AuthRoleMutation) Value() (r authrole.Value, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldValue(ctx context.Context) (v authrole.Value, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AuthRoleMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *AuthRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuthRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuthRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[authrole.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuthRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[authrole.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuthRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, authrole.FieldDescription)
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *AuthRoleMutation) AddAccountIDs(ids ...pulid.PULID) {
	if m.accounts == nil {
		m.accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *AuthRoleMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *AuthRoleMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *AuthRoleMutation) RemoveAccountIDs(ids ...pulid.PULID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *AuthRoleMutation) RemovedAccountsIDs() (ids []pulid.PULID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *AuthRoleMutation) AccountsIDs() (ids []pulid.PULID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AuthRoleMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddStaffAccountIDs adds the "staff_accounts" edge to the StaffAccount entity by ids.
func (m *AuthRoleMutation) AddStaffAccountIDs(ids ...pulid.PULID) {
	if m.staff_accounts == nil {
		m.staff_accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.staff_accounts[ids[i]] = struct{}{}
	}
}

// ClearStaffAccounts clears the "staff_accounts" edge to the StaffAccount entity.
func (m *AuthRoleMutation) ClearStaffAccounts() {
	m.clearedstaff_accounts = true
}

// StaffAccountsCleared reports if the "staff_accounts" edge to the StaffAccount entity was cleared.
func (m *AuthRoleMutation) StaffAccountsCleared() bool {
	return m.clearedstaff_accounts
}

// RemoveStaffAccountIDs removes the "staff_accounts" edge to the StaffAccount entity by IDs.
func (m *AuthRoleMutation) RemoveStaffAccountIDs(ids ...pulid.PULID) {
	if m.removedstaff_accounts == nil {
		m.removedstaff_accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.staff_accounts, ids[i])
		m.removedstaff_accounts[ids[i]] = struct{}{}
	}
}

// RemovedStaffAccounts returns the removed IDs of the "staff_accounts" edge to the StaffAccount entity.
func (m *AuthRoleMutation) RemovedStaffAccountsIDs() (ids []pulid.PULID) {
	for id := range m.removedstaff_accounts {
		ids = append(ids, id)
	}
	return
}

// StaffAccountsIDs returns the "staff_accounts" edge IDs in the mutation.
func (m *AuthRoleMutation) StaffAccountsIDs() (ids []pulid.PULID) {
	for id := range m.staff_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetStaffAccounts resets all changes to the "staff_accounts" edge.
func (m *AuthRoleMutation) ResetStaffAccounts() {
	m.staff_accounts = nil
	m.clearedstaff_accounts = false
	m.removedstaff_accounts = nil
}

// Where appends a list predicates to the AuthRoleMutation builder.
func (m *AuthRoleMutation) Where(ps ...predicate.AuthRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRole).
func (m *AuthRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, authrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authrole.FieldDeletedAt)
	}
	if m.value != nil {
		fields = append(fields, authrole.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, authrole.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrole.FieldCreatedAt:
		return m.CreatedAt()
	case authrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case authrole.FieldDeletedAt:
		return m.DeletedAt()
	case authrole.FieldValue:
		return m.Value()
	case authrole.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authrole.FieldValue:
		return m.OldValue(ctx)
	case authrole.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authrole.FieldValue:
		v, ok := value.(authrole.Value)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case authrole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authrole.FieldDeletedAt) {
		fields = append(fields, authrole.FieldDeletedAt)
	}
	if m.FieldCleared(authrole.FieldDescription) {
		fields = append(fields, authrole.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRoleMutation) ClearField(name string) error {
	switch name {
	case authrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case authrole.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRoleMutation) ResetField(name string) error {
	switch name {
	case authrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authrole.FieldValue:
		m.ResetValue()
		return nil
	case authrole.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, authrole.EdgeAccounts)
	}
	if m.staff_accounts != nil {
		edges = append(edges, authrole.EdgeStaffAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authrole.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case authrole.EdgeStaffAccounts:
		ids := make([]ent.Value, 0, len(m.staff_accounts))
		for id := range m.staff_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, authrole.EdgeAccounts)
	}
	if m.removedstaff_accounts != nil {
		edges = append(edges, authrole.EdgeStaffAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authrole.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case authrole.EdgeStaffAccounts:
		ids := make([]ent.Value, 0, len(m.removedstaff_accounts))
		for id := range m.removedstaff_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, authrole.EdgeAccounts)
	}
	if m.clearedstaff_accounts {
		edges = append(edges, authrole.EdgeStaffAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case authrole.EdgeAccounts:
		return m.clearedaccounts
	case authrole.EdgeStaffAccounts:
		return m.clearedstaff_accounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRoleMutation) ResetEdge(name string) error {
	switch name {
	case authrole.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case authrole.EdgeStaffAccounts:
		m.ResetStaffAccounts()
		return nil
	}
	return fmt.Errorf("unknown AuthRole edge %s", name)
}

// AuthTypeMutation represents an operation that mutates the AuthType nodes in the graph.
type AuthTypeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.PULID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	value                 *authtype.Value
	description           *string
	clearedFields         map[string]struct{}
	accounts              map[pulid.PULID]struct{}
	removedaccounts       map[pulid.PULID]struct{}
	clearedaccounts       bool
	staff_accounts        map[pulid.PULID]struct{}
	removedstaff_accounts map[pulid.PULID]struct{}
	clearedstaff_accounts bool
	done                  bool
	oldValue              func(context.Context) (*AuthType, error)
	predicates            []predicate.AuthType
}

var _ ent.Mutation = (*AuthTypeMutation)(nil)

// authtypeOption allows management of the mutation configuration using functional options.
type authtypeOption func(*AuthTypeMutation)

// newAuthTypeMutation creates new mutation for the AuthType entity.
func newAuthTypeMutation(c config, op Op, opts ...authtypeOption) *AuthTypeMutation {
	m := &AuthTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTypeID sets the ID field of the mutation.
func withAuthTypeID(id pulid.PULID) authtypeOption {
	return func(m *AuthTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthType
		)
		m.oldValue = func(ctx context.Context) (*AuthType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthType sets the old AuthType of the mutation.
func withAuthType(node *AuthType) authtypeOption {
	return func(m *AuthTypeMutation) {
		m.oldValue = func(context.Context) (*AuthType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthType entities.
func (m *AuthTypeMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTypeMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTypeMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthType entity.
// If the AuthType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthType entity.
// If the AuthType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthType entity.
// If the AuthType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[authtype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[authtype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, authtype.FieldDeletedAt)
}

// SetValue sets the "value" field.
func (m *AuthTypeMutation) SetValue(a authtype.Value) {
	m.value = &a
}

// Value returns the value of the "value" field in the mutation.
func (m *AuthTypeMutation) Value() (r authtype.Value, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AuthType entity.
// If the AuthType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTypeMutation) OldValue(ctx context.Context) (v authtype.Value, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AuthTypeMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *AuthTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuthTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuthType entity.
// If the AuthType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuthTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[authtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuthTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[authtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuthTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, authtype.FieldDescription)
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *AuthTypeMutation) AddAccountIDs(ids ...pulid.PULID) {
	if m.accounts == nil {
		m.accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *AuthTypeMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *AuthTypeMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *AuthTypeMutation) RemoveAccountIDs(ids ...pulid.PULID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *AuthTypeMutation) RemovedAccountsIDs() (ids []pulid.PULID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *AuthTypeMutation) AccountsIDs() (ids []pulid.PULID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AuthTypeMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddStaffAccountIDs adds the "staff_accounts" edge to the StaffAccount entity by ids.
func (m *AuthTypeMutation) AddStaffAccountIDs(ids ...pulid.PULID) {
	if m.staff_accounts == nil {
		m.staff_accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.staff_accounts[ids[i]] = struct{}{}
	}
}

// ClearStaffAccounts clears the "staff_accounts" edge to the StaffAccount entity.
func (m *AuthTypeMutation) ClearStaffAccounts() {
	m.clearedstaff_accounts = true
}

// StaffAccountsCleared reports if the "staff_accounts" edge to the StaffAccount entity was cleared.
func (m *AuthTypeMutation) StaffAccountsCleared() bool {
	return m.clearedstaff_accounts
}

// RemoveStaffAccountIDs removes the "staff_accounts" edge to the StaffAccount entity by IDs.
func (m *AuthTypeMutation) RemoveStaffAccountIDs(ids ...pulid.PULID) {
	if m.removedstaff_accounts == nil {
		m.removedstaff_accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.staff_accounts, ids[i])
		m.removedstaff_accounts[ids[i]] = struct{}{}
	}
}

// RemovedStaffAccounts returns the removed IDs of the "staff_accounts" edge to the StaffAccount entity.
func (m *AuthTypeMutation) RemovedStaffAccountsIDs() (ids []pulid.PULID) {
	for id := range m.removedstaff_accounts {
		ids = append(ids, id)
	}
	return
}

// StaffAccountsIDs returns the "staff_accounts" edge IDs in the mutation.
func (m *AuthTypeMutation) StaffAccountsIDs() (ids []pulid.PULID) {
	for id := range m.staff_accounts {
		ids = append(ids, id)
	}
	return
}

// ResetStaffAccounts resets all changes to the "staff_accounts" edge.
func (m *AuthTypeMutation) ResetStaffAccounts() {
	m.staff_accounts = nil
	m.clearedstaff_accounts = false
	m.removedstaff_accounts = nil
}

// Where appends a list predicates to the AuthTypeMutation builder.
func (m *AuthTypeMutation) Where(ps ...predicate.AuthType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthType).
func (m *AuthTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, authtype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authtype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authtype.FieldDeletedAt)
	}
	if m.value != nil {
		fields = append(fields, authtype.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, authtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtype.FieldCreatedAt:
		return m.CreatedAt()
	case authtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case authtype.FieldDeletedAt:
		return m.DeletedAt()
	case authtype.FieldValue:
		return m.Value()
	case authtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authtype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authtype.FieldValue:
		return m.OldValue(ctx)
	case authtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AuthType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authtype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authtype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authtype.FieldValue:
		v, ok := value.(authtype.Value)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case authtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AuthType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authtype.FieldDeletedAt) {
		fields = append(fields, authtype.FieldDeletedAt)
	}
	if m.FieldCleared(authtype.FieldDescription) {
		fields = append(fields, authtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTypeMutation) ClearField(name string) error {
	switch name {
	case authtype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case authtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTypeMutation) ResetField(name string) error {
	switch name {
	case authtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authtype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authtype.FieldValue:
		m.ResetValue()
		return nil
	case authtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, authtype.EdgeAccounts)
	}
	if m.staff_accounts != nil {
		edges = append(edges, authtype.EdgeStaffAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authtype.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case authtype.EdgeStaffAccounts:
		ids := make([]ent.Value, 0, len(m.staff_accounts))
		for id := range m.staff_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, authtype.EdgeAccounts)
	}
	if m.removedstaff_accounts != nil {
		edges = append(edges, authtype.EdgeStaffAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authtype.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case authtype.EdgeStaffAccounts:
		ids := make([]ent.Value, 0, len(m.removedstaff_accounts))
		for id := range m.removedstaff_accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, authtype.EdgeAccounts)
	}
	if m.clearedstaff_accounts {
		edges = append(edges, authtype.EdgeStaffAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case authtype.EdgeAccounts:
		return m.clearedaccounts
	case authtype.EdgeStaffAccounts:
		return m.clearedstaff_accounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTypeMutation) ResetEdge(name string) error {
	switch name {
	case authtype.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case authtype.EdgeStaffAccounts:
		m.ResetStaffAccounts()
		return nil
	}
	return fmt.Errorf("unknown AuthType edge %s", name)
}

// BlockchainMutation represents an operation that mutates the Blockchain nodes in the graph.
type BlockchainMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.PULID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	name                    *string
	symbol                  *string
	icon                    *string
	chain_id                *int64
	addchain_id             *int64
	clearedFields           map[string]struct{}
	cryptocurrencies        map[pulid.PULID]struct{}
	removedcryptocurrencies map[pulid.PULID]struct{}
	clearedcryptocurrencies bool
	transactions            map[pulid.PULID]struct{}
	removedtransactions     map[pulid.PULID]struct{}
	clearedtransactions     bool
	done                    bool
	oldValue                func(context.Context) (*Blockchain, error)
	predicates              []predicate.Blockchain
}

var _ ent.Mutation = (*BlockchainMutation)(nil)

// blockchainOption allows management of the mutation configuration using functional options.
type blockchainOption func(*BlockchainMutation)

// newBlockchainMutation creates new mutation for the Blockchain entity.
func newBlockchainMutation(c config, op Op, opts ...blockchainOption) *BlockchainMutation {
	m := &BlockchainMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockchain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockchainID sets the ID field of the mutation.
func withBlockchainID(id pulid.PULID) blockchainOption {
	return func(m *BlockchainMutation) {
		var (
			err   error
			once  sync.Once
			value *Blockchain
		)
		m.oldValue = func(ctx context.Context) (*Blockchain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blockchain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockchain sets the old Blockchain of the mutation.
func withBlockchain(node *Blockchain) blockchainOption {
	return func(m *BlockchainMutation) {
		m.oldValue = func(context.Context) (*Blockchain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockchainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockchainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blockchain entities.
func (m *BlockchainMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockchainMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockchainMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blockchain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockchainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockchainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockchainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockchainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockchainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockchainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlockchainMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlockchainMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BlockchainMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[blockchain.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BlockchainMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlockchainMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, blockchain.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BlockchainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlockchainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlockchainMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *BlockchainMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *BlockchainMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *BlockchainMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIcon sets the "icon" field.
func (m *BlockchainMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *BlockchainMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *BlockchainMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[blockchain.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *BlockchainMutation) IconCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *BlockchainMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, blockchain.FieldIcon)
}

// SetChainID sets the "chain_id" field.
func (m *BlockchainMutation) SetChainID(i int64) {
	m.chain_id = &i
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *BlockchainMutation) ChainID() (r int64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldChainID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds i to the "chain_id" field.
func (m *BlockchainMutation) AddChainID(i int64) {
	if m.addchain_id != nil {
		*m.addchain_id += i
	} else {
		m.addchain_id = &i
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *BlockchainMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearChainID clears the value of the "chain_id" field.
func (m *BlockchainMutation) ClearChainID() {
	m.chain_id = nil
	m.addchain_id = nil
	m.clearedFields[blockchain.FieldChainID] = struct{}{}
}

// ChainIDCleared returns if the "chain_id" field was cleared in this mutation.
func (m *BlockchainMutation) ChainIDCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldChainID]
	return ok
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *BlockchainMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
	delete(m.clearedFields, blockchain.FieldChainID)
}

// AddCryptocurrencyIDs adds the "cryptocurrencies" edge to the Cryptocurrency entity by ids.
func (m *BlockchainMutation) AddCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.cryptocurrencies == nil {
		m.cryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.cryptocurrencies[ids[i]] = struct{}{}
	}
}

// ClearCryptocurrencies clears the "cryptocurrencies" edge to the Cryptocurrency entity.
func (m *BlockchainMutation) ClearCryptocurrencies() {
	m.clearedcryptocurrencies = true
}

// CryptocurrenciesCleared reports if the "cryptocurrencies" edge to the Cryptocurrency entity was cleared.
func (m *BlockchainMutation) CryptocurrenciesCleared() bool {
	return m.clearedcryptocurrencies
}

// RemoveCryptocurrencyIDs removes the "cryptocurrencies" edge to the Cryptocurrency entity by IDs.
func (m *BlockchainMutation) RemoveCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.removedcryptocurrencies == nil {
		m.removedcryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.cryptocurrencies, ids[i])
		m.removedcryptocurrencies[ids[i]] = struct{}{}
	}
}

// RemovedCryptocurrencies returns the removed IDs of the "cryptocurrencies" edge to the Cryptocurrency entity.
func (m *BlockchainMutation) RemovedCryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.removedcryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// CryptocurrenciesIDs returns the "cryptocurrencies" edge IDs in the mutation.
func (m *BlockchainMutation) CryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// ResetCryptocurrencies resets all changes to the "cryptocurrencies" edge.
func (m *BlockchainMutation) ResetCryptocurrencies() {
	m.cryptocurrencies = nil
	m.clearedcryptocurrencies = false
	m.removedcryptocurrencies = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *BlockchainMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *BlockchainMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *BlockchainMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *BlockchainMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *BlockchainMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *BlockchainMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *BlockchainMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the BlockchainMutation builder.
func (m *BlockchainMutation) Where(ps ...predicate.Blockchain) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BlockchainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Blockchain).
func (m *BlockchainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockchainMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, blockchain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockchain.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, blockchain.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, blockchain.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, blockchain.FieldSymbol)
	}
	if m.icon != nil {
		fields = append(fields, blockchain.FieldIcon)
	}
	if m.chain_id != nil {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockchainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.CreatedAt()
	case blockchain.FieldUpdatedAt:
		return m.UpdatedAt()
	case blockchain.FieldDeletedAt:
		return m.DeletedAt()
	case blockchain.FieldName:
		return m.Name()
	case blockchain.FieldSymbol:
		return m.Symbol()
	case blockchain.FieldIcon:
		return m.Icon()
	case blockchain.FieldChainID:
		return m.ChainID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockchainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockchain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blockchain.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blockchain.FieldName:
		return m.OldName(ctx)
	case blockchain.FieldSymbol:
		return m.OldSymbol(ctx)
	case blockchain.FieldIcon:
		return m.OldIcon(ctx)
	case blockchain.FieldChainID:
		return m.OldChainID(ctx)
	}
	return nil, fmt.Errorf("unknown Blockchain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockchain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blockchain.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blockchain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blockchain.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case blockchain.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case blockchain.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockchainMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockchainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldChainID:
		return m.AddedChainID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockchainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockchain.FieldDeletedAt) {
		fields = append(fields, blockchain.FieldDeletedAt)
	}
	if m.FieldCleared(blockchain.FieldIcon) {
		fields = append(fields, blockchain.FieldIcon)
	}
	if m.FieldCleared(blockchain.FieldChainID) {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockchainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockchainMutation) ClearField(name string) error {
	switch name {
	case blockchain.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case blockchain.FieldIcon:
		m.ClearIcon()
		return nil
	case blockchain.FieldChainID:
		m.ClearChainID()
		return nil
	}
	return fmt.Errorf("unknown Blockchain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockchainMutation) ResetField(name string) error {
	switch name {
	case blockchain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockchain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blockchain.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blockchain.FieldName:
		m.ResetName()
		return nil
	case blockchain.FieldSymbol:
		m.ResetSymbol()
		return nil
	case blockchain.FieldIcon:
		m.ResetIcon()
		return nil
	case blockchain.FieldChainID:
		m.ResetChainID()
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockchainMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	if m.transactions != nil {
		edges = append(edges, blockchain.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockchainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.cryptocurrencies))
		for id := range m.cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	case blockchain.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockchainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	if m.removedtransactions != nil {
		edges = append(edges, blockchain.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockchainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.removedcryptocurrencies))
		for id := range m.removedcryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	case blockchain.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockchainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcryptocurrencies {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	if m.clearedtransactions {
		edges = append(edges, blockchain.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockchainMutation) EdgeCleared(name string) bool {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		return m.clearedcryptocurrencies
	case blockchain.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockchainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Blockchain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockchainMutation) ResetEdge(name string) error {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		m.ResetCryptocurrencies()
		return nil
	case blockchain.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Blockchain edge %s", name)
}

// ConnectionMutation represents an operation that mutates the Connection nodes in the graph.
type ConnectionMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.PULID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	access_token      *string
	clearedFields     map[string]struct{}
	account           *pulid.PULID
	clearedaccount    bool
	portfolios        map[pulid.PULID]struct{}
	removedportfolios map[pulid.PULID]struct{}
	clearedportfolios bool
	done              bool
	oldValue          func(context.Context) (*Connection, error)
	predicates        []predicate.Connection
}

var _ ent.Mutation = (*ConnectionMutation)(nil)

// connectionOption allows management of the mutation configuration using functional options.
type connectionOption func(*ConnectionMutation)

// newConnectionMutation creates new mutation for the Connection entity.
func newConnectionMutation(c config, op Op, opts ...connectionOption) *ConnectionMutation {
	m := &ConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionID sets the ID field of the mutation.
func withConnectionID(id pulid.PULID) connectionOption {
	return func(m *ConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Connection
		)
		m.oldValue = func(ctx context.Context) (*Connection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnection sets the old Connection of the mutation.
func withConnection(node *Connection) connectionOption {
	return func(m *ConnectionMutation) {
		m.oldValue = func(context.Context) (*Connection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connection entities.
func (m *ConnectionMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ConnectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ConnectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ConnectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[connection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ConnectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[connection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ConnectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, connection.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ConnectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectionMutation) ResetName() {
	m.name = nil
}

// SetAccessToken sets the "access_token" field.
func (m *ConnectionMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *ConnectionMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *ConnectionMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetAccountID sets the "account_id" field.
func (m *ConnectionMutation) SetAccountID(pu pulid.PULID) {
	m.account = &pu
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *ConnectionMutation) AccountID() (r pulid.PULID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldAccountID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *ConnectionMutation) ResetAccountID() {
	m.account = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *ConnectionMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *ConnectionMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) AccountIDs() (ids []pulid.PULID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *ConnectionMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// AddPortfolioIDs adds the "portfolios" edge to the Portfolio entity by ids.
func (m *ConnectionMutation) AddPortfolioIDs(ids ...pulid.PULID) {
	if m.portfolios == nil {
		m.portfolios = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.portfolios[ids[i]] = struct{}{}
	}
}

// ClearPortfolios clears the "portfolios" edge to the Portfolio entity.
func (m *ConnectionMutation) ClearPortfolios() {
	m.clearedportfolios = true
}

// PortfoliosCleared reports if the "portfolios" edge to the Portfolio entity was cleared.
func (m *ConnectionMutation) PortfoliosCleared() bool {
	return m.clearedportfolios
}

// RemovePortfolioIDs removes the "portfolios" edge to the Portfolio entity by IDs.
func (m *ConnectionMutation) RemovePortfolioIDs(ids ...pulid.PULID) {
	if m.removedportfolios == nil {
		m.removedportfolios = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.portfolios, ids[i])
		m.removedportfolios[ids[i]] = struct{}{}
	}
}

// RemovedPortfolios returns the removed IDs of the "portfolios" edge to the Portfolio entity.
func (m *ConnectionMutation) RemovedPortfoliosIDs() (ids []pulid.PULID) {
	for id := range m.removedportfolios {
		ids = append(ids, id)
	}
	return
}

// PortfoliosIDs returns the "portfolios" edge IDs in the mutation.
func (m *ConnectionMutation) PortfoliosIDs() (ids []pulid.PULID) {
	for id := range m.portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolios resets all changes to the "portfolios" edge.
func (m *ConnectionMutation) ResetPortfolios() {
	m.portfolios = nil
	m.clearedportfolios = false
	m.removedportfolios = nil
}

// Where appends a list predicates to the ConnectionMutation builder.
func (m *ConnectionMutation) Where(ps ...predicate.Connection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ConnectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Connection).
func (m *ConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, connection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, connection.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, connection.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, connection.FieldName)
	}
	if m.access_token != nil {
		fields = append(fields, connection.FieldAccessToken)
	}
	if m.account != nil {
		fields = append(fields, connection.FieldAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connection.FieldCreatedAt:
		return m.CreatedAt()
	case connection.FieldUpdatedAt:
		return m.UpdatedAt()
	case connection.FieldDeletedAt:
		return m.DeletedAt()
	case connection.FieldName:
		return m.Name()
	case connection.FieldAccessToken:
		return m.AccessToken()
	case connection.FieldAccountID:
		return m.AccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case connection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case connection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case connection.FieldName:
		return m.OldName(ctx)
	case connection.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case connection.FieldAccountID:
		return m.OldAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Connection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case connection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case connection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case connection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connection.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case connection.FieldAccountID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connection.FieldDeletedAt) {
		fields = append(fields, connection.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionMutation) ClearField(name string) error {
	switch name {
	case connection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Connection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionMutation) ResetField(name string) error {
	switch name {
	case connection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case connection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case connection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case connection.FieldName:
		m.ResetName()
		return nil
	case connection.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case connection.FieldAccountID:
		m.ResetAccountID()
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, connection.EdgeAccount)
	}
	if m.portfolios != nil {
		edges = append(edges, connection.EdgePortfolios)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.portfolios))
		for id := range m.portfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedportfolios != nil {
		edges = append(edges, connection.EdgePortfolios)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.removedportfolios))
		for id := range m.removedportfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, connection.EdgeAccount)
	}
	if m.clearedportfolios {
		edges = append(edges, connection.EdgePortfolios)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case connection.EdgeAccount:
		return m.clearedaccount
	case connection.EdgePortfolios:
		return m.clearedportfolios
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionMutation) ClearEdge(name string) error {
	switch name {
	case connection.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Connection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionMutation) ResetEdge(name string) error {
	switch name {
	case connection.EdgeAccount:
		m.ResetAccount()
		return nil
	case connection.EdgePortfolios:
		m.ResetPortfolios()
		return nil
	}
	return fmt.Errorf("unknown Connection edge %s", name)
}

// CryptocurrencyMutation represents an operation that mutates the Cryptocurrency nodes in the graph.
type CryptocurrencyMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.PULID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	symbol             *string
	icon               *string
	name               *string
	clearedFields      map[string]struct{}
	asset              *pulid.PULID
	clearedasset       bool
	blockchains        map[pulid.PULID]struct{}
	removedblockchains map[pulid.PULID]struct{}
	clearedblockchains bool
	done               bool
	oldValue           func(context.Context) (*Cryptocurrency, error)
	predicates         []predicate.Cryptocurrency
}

var _ ent.Mutation = (*CryptocurrencyMutation)(nil)

// cryptocurrencyOption allows management of the mutation configuration using functional options.
type cryptocurrencyOption func(*CryptocurrencyMutation)

// newCryptocurrencyMutation creates new mutation for the Cryptocurrency entity.
func newCryptocurrencyMutation(c config, op Op, opts ...cryptocurrencyOption) *CryptocurrencyMutation {
	m := &CryptocurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCryptocurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCryptocurrencyID sets the ID field of the mutation.
func withCryptocurrencyID(id pulid.PULID) cryptocurrencyOption {
	return func(m *CryptocurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Cryptocurrency
		)
		m.oldValue = func(ctx context.Context) (*Cryptocurrency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cryptocurrency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCryptocurrency sets the old Cryptocurrency of the mutation.
func withCryptocurrency(node *Cryptocurrency) cryptocurrencyOption {
	return func(m *CryptocurrencyMutation) {
		m.oldValue = func(context.Context) (*Cryptocurrency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CryptocurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CryptocurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cryptocurrency entities.
func (m *CryptocurrencyMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CryptocurrencyMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CryptocurrencyMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cryptocurrency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CryptocurrencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CryptocurrencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CryptocurrencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CryptocurrencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CryptocurrencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CryptocurrencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CryptocurrencyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CryptocurrencyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CryptocurrencyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cryptocurrency.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CryptocurrencyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cryptocurrency.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CryptocurrencyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cryptocurrency.FieldDeletedAt)
}

// SetSymbol sets the "symbol" field.
func (m *CryptocurrencyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *CryptocurrencyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *CryptocurrencyMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIcon sets the "icon" field.
func (m *CryptocurrencyMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CryptocurrencyMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CryptocurrencyMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[cryptocurrency.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CryptocurrencyMutation) IconCleared() bool {
	_, ok := m.clearedFields[cryptocurrency.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CryptocurrencyMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, cryptocurrency.FieldIcon)
}

// SetName sets the "name" field.
func (m *CryptocurrencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CryptocurrencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CryptocurrencyMutation) ResetName() {
	m.name = nil
}

// SetAssetID sets the "asset_id" field.
func (m *CryptocurrencyMutation) SetAssetID(pu pulid.PULID) {
	m.asset = &pu
}

// AssetID returns the value of the "asset_id" field in the mutation.
func (m *CryptocurrencyMutation) AssetID() (r pulid.PULID, exists bool) {
	v := m.asset
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "asset_id" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldAssetID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// ResetAssetID resets all changes to the "asset_id" field.
func (m *CryptocurrencyMutation) ResetAssetID() {
	m.asset = nil
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *CryptocurrencyMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *CryptocurrencyMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *CryptocurrencyMutation) AssetIDs() (ids []pulid.PULID) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *CryptocurrencyMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddBlockchainIDs adds the "blockchains" edge to the Blockchain entity by ids.
func (m *CryptocurrencyMutation) AddBlockchainIDs(ids ...pulid.PULID) {
	if m.blockchains == nil {
		m.blockchains = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.blockchains[ids[i]] = struct{}{}
	}
}

// ClearBlockchains clears the "blockchains" edge to the Blockchain entity.
func (m *CryptocurrencyMutation) ClearBlockchains() {
	m.clearedblockchains = true
}

// BlockchainsCleared reports if the "blockchains" edge to the Blockchain entity was cleared.
func (m *CryptocurrencyMutation) BlockchainsCleared() bool {
	return m.clearedblockchains
}

// RemoveBlockchainIDs removes the "blockchains" edge to the Blockchain entity by IDs.
func (m *CryptocurrencyMutation) RemoveBlockchainIDs(ids ...pulid.PULID) {
	if m.removedblockchains == nil {
		m.removedblockchains = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.blockchains, ids[i])
		m.removedblockchains[ids[i]] = struct{}{}
	}
}

// RemovedBlockchains returns the removed IDs of the "blockchains" edge to the Blockchain entity.
func (m *CryptocurrencyMutation) RemovedBlockchainsIDs() (ids []pulid.PULID) {
	for id := range m.removedblockchains {
		ids = append(ids, id)
	}
	return
}

// BlockchainsIDs returns the "blockchains" edge IDs in the mutation.
func (m *CryptocurrencyMutation) BlockchainsIDs() (ids []pulid.PULID) {
	for id := range m.blockchains {
		ids = append(ids, id)
	}
	return
}

// ResetBlockchains resets all changes to the "blockchains" edge.
func (m *CryptocurrencyMutation) ResetBlockchains() {
	m.blockchains = nil
	m.clearedblockchains = false
	m.removedblockchains = nil
}

// Where appends a list predicates to the CryptocurrencyMutation builder.
func (m *CryptocurrencyMutation) Where(ps ...predicate.Cryptocurrency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CryptocurrencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cryptocurrency).
func (m *CryptocurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CryptocurrencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, cryptocurrency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cryptocurrency.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cryptocurrency.FieldDeletedAt)
	}
	if m.symbol != nil {
		fields = append(fields, cryptocurrency.FieldSymbol)
	}
	if m.icon != nil {
		fields = append(fields, cryptocurrency.FieldIcon)
	}
	if m.name != nil {
		fields = append(fields, cryptocurrency.FieldName)
	}
	if m.asset != nil {
		fields = append(fields, cryptocurrency.FieldAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CryptocurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		return m.CreatedAt()
	case cryptocurrency.FieldUpdatedAt:
		return m.UpdatedAt()
	case cryptocurrency.FieldDeletedAt:
		return m.DeletedAt()
	case cryptocurrency.FieldSymbol:
		return m.Symbol()
	case cryptocurrency.FieldIcon:
		return m.Icon()
	case cryptocurrency.FieldName:
		return m.Name()
	case cryptocurrency.FieldAssetID:
		return m.AssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CryptocurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cryptocurrency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cryptocurrency.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cryptocurrency.FieldSymbol:
		return m.OldSymbol(ctx)
	case cryptocurrency.FieldIcon:
		return m.OldIcon(ctx)
	case cryptocurrency.FieldName:
		return m.OldName(ctx)
	case cryptocurrency.FieldAssetID:
		return m.OldAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptocurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cryptocurrency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cryptocurrency.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cryptocurrency.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case cryptocurrency.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case cryptocurrency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cryptocurrency.FieldAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CryptocurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CryptocurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptocurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cryptocurrency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CryptocurrencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cryptocurrency.FieldDeletedAt) {
		fields = append(fields, cryptocurrency.FieldDeletedAt)
	}
	if m.FieldCleared(cryptocurrency.FieldIcon) {
		fields = append(fields, cryptocurrency.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CryptocurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CryptocurrencyMutation) ClearField(name string) error {
	switch name {
	case cryptocurrency.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cryptocurrency.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CryptocurrencyMutation) ResetField(name string) error {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cryptocurrency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cryptocurrency.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cryptocurrency.FieldSymbol:
		m.ResetSymbol()
		return nil
	case cryptocurrency.FieldIcon:
		m.ResetIcon()
		return nil
	case cryptocurrency.FieldName:
		m.ResetName()
		return nil
	case cryptocurrency.FieldAssetID:
		m.ResetAssetID()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CryptocurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.asset != nil {
		edges = append(edges, cryptocurrency.EdgeAsset)
	}
	if m.blockchains != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CryptocurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cryptocurrency.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case cryptocurrency.EdgeBlockchains:
		ids := make([]ent.Value, 0, len(m.blockchains))
		for id := range m.blockchains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CryptocurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblockchains != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CryptocurrencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cryptocurrency.EdgeBlockchains:
		ids := make([]ent.Value, 0, len(m.removedblockchains))
		for id := range m.removedblockchains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CryptocurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedasset {
		edges = append(edges, cryptocurrency.EdgeAsset)
	}
	if m.clearedblockchains {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CryptocurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case cryptocurrency.EdgeAsset:
		return m.clearedasset
	case cryptocurrency.EdgeBlockchains:
		return m.clearedblockchains
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CryptocurrencyMutation) ClearEdge(name string) error {
	switch name {
	case cryptocurrency.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CryptocurrencyMutation) ResetEdge(name string) error {
	switch name {
	case cryptocurrency.EdgeAsset:
		m.ResetAsset()
		return nil
	case cryptocurrency.EdgeBlockchains:
		m.ResetBlockchains()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency edge %s", name)
}

// DailyAssetPriceMutation represents an operation that mutates the DailyAssetPrice nodes in the graph.
type DailyAssetPriceMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.PULID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	time              *time.Time
	open              *float64
	addopen           *float64
	high              *float64
	addhigh           *float64
	low               *float64
	addlow            *float64
	close             *float64
	addclose          *float64
	adjusted_close    *float64
	addadjusted_close *float64
	clearedFields     map[string]struct{}
	asset             *pulid.PULID
	clearedasset      bool
	done              bool
	oldValue          func(context.Context) (*DailyAssetPrice, error)
	predicates        []predicate.DailyAssetPrice
}

var _ ent.Mutation = (*DailyAssetPriceMutation)(nil)

// dailyassetpriceOption allows management of the mutation configuration using functional options.
type dailyassetpriceOption func(*DailyAssetPriceMutation)

// newDailyAssetPriceMutation creates new mutation for the DailyAssetPrice entity.
func newDailyAssetPriceMutation(c config, op Op, opts ...dailyassetpriceOption) *DailyAssetPriceMutation {
	m := &DailyAssetPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeDailyAssetPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDailyAssetPriceID sets the ID field of the mutation.
func withDailyAssetPriceID(id pulid.PULID) dailyassetpriceOption {
	return func(m *DailyAssetPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *DailyAssetPrice
		)
		m.oldValue = func(ctx context.Context) (*DailyAssetPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DailyAssetPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDailyAssetPrice sets the old DailyAssetPrice of the mutation.
func withDailyAssetPrice(node *DailyAssetPrice) dailyassetpriceOption {
	return func(m *DailyAssetPriceMutation) {
		m.oldValue = func(context.Context) (*DailyAssetPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DailyAssetPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DailyAssetPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DailyAssetPrice entities.
func (m *DailyAssetPriceMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DailyAssetPriceMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DailyAssetPriceMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DailyAssetPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DailyAssetPriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DailyAssetPriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DailyAssetPriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DailyAssetPriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DailyAssetPriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DailyAssetPriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DailyAssetPriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DailyAssetPriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DailyAssetPriceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dailyassetprice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DailyAssetPriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dailyassetprice.FieldDeletedAt)
}

// SetTime sets the "time" field.
func (m *DailyAssetPriceMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *DailyAssetPriceMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *DailyAssetPriceMutation) ResetTime() {
	m.time = nil
}

// SetOpen sets the "open" field.
func (m *DailyAssetPriceMutation) SetOpen(f float64) {
	m.open = &f
	m.addopen = nil
}

// Open returns the value of the "open" field in the mutation.
func (m *DailyAssetPriceMutation) Open() (r float64, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldOpen(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// AddOpen adds f to the "open" field.
func (m *DailyAssetPriceMutation) AddOpen(f float64) {
	if m.addopen != nil {
		*m.addopen += f
	} else {
		m.addopen = &f
	}
}

// AddedOpen returns the value that was added to the "open" field in this mutation.
func (m *DailyAssetPriceMutation) AddedOpen() (r float64, exists bool) {
	v := m.addopen
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpen clears the value of the "open" field.
func (m *DailyAssetPriceMutation) ClearOpen() {
	m.open = nil
	m.addopen = nil
	m.clearedFields[dailyassetprice.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) OpenCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *DailyAssetPriceMutation) ResetOpen() {
	m.open = nil
	m.addopen = nil
	delete(m.clearedFields, dailyassetprice.FieldOpen)
}

// SetHigh sets the "high" field.
func (m *DailyAssetPriceMutation) SetHigh(f float64) {
	m.high = &f
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *DailyAssetPriceMutation) High() (r float64, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldHigh(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds f to the "high" field.
func (m *DailyAssetPriceMutation) AddHigh(f float64) {
	if m.addhigh != nil {
		*m.addhigh += f
	} else {
		m.addhigh = &f
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *DailyAssetPriceMutation) AddedHigh() (r float64, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ClearHigh clears the value of the "high" field.
func (m *DailyAssetPriceMutation) ClearHigh() {
	m.high = nil
	m.addhigh = nil
	m.clearedFields[dailyassetprice.FieldHigh] = struct{}{}
}

// HighCleared returns if the "high" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) HighCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldHigh]
	return ok
}

// ResetHigh resets all changes to the "high" field.
func (m *DailyAssetPriceMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
	delete(m.clearedFields, dailyassetprice.FieldHigh)
}

// SetLow sets the "low" field.
func (m *DailyAssetPriceMutation) SetLow(f float64) {
	m.low = &f
	m.addlow = nil
}

// Low returns the value of the "low" field in the mutation.
func (m *DailyAssetPriceMutation) Low() (r float64, exists bool) {
	v := m.low
	if v == nil {
		return
	}
	return *v, true
}

// OldLow returns the old "low" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldLow(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLow: %w", err)
	}
	return oldValue.Low, nil
}

// AddLow adds f to the "low" field.
func (m *DailyAssetPriceMutation) AddLow(f float64) {
	if m.addlow != nil {
		*m.addlow += f
	} else {
		m.addlow = &f
	}
}

// AddedLow returns the value that was added to the "low" field in this mutation.
func (m *DailyAssetPriceMutation) AddedLow() (r float64, exists bool) {
	v := m.addlow
	if v == nil {
		return
	}
	return *v, true
}

// ClearLow clears the value of the "low" field.
func (m *DailyAssetPriceMutation) ClearLow() {
	m.low = nil
	m.addlow = nil
	m.clearedFields[dailyassetprice.FieldLow] = struct{}{}
}

// LowCleared returns if the "low" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) LowCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldLow]
	return ok
}

// ResetLow resets all changes to the "low" field.
func (m *DailyAssetPriceMutation) ResetLow() {
	m.low = nil
	m.addlow = nil
	delete(m.clearedFields, dailyassetprice.FieldLow)
}

// SetClose sets the "close" field.
func (m *DailyAssetPriceMutation) SetClose(f float64) {
	m.close = &f
	m.addclose = nil
}

// Close returns the value of the "close" field in the mutation.
func (m *DailyAssetPriceMutation) Close() (r float64, exists bool) {
	v := m.close
	if v == nil {
		return
	}
	return *v, true
}

// OldClose returns the old "close" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldClose(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClose: %w", err)
	}
	return oldValue.Close, nil
}

// AddClose adds f to the "close" field.
func (m *DailyAssetPriceMutation) AddClose(f float64) {
	if m.addclose != nil {
		*m.addclose += f
	} else {
		m.addclose = &f
	}
}

// AddedClose returns the value that was added to the "close" field in this mutation.
func (m *DailyAssetPriceMutation) AddedClose() (r float64, exists bool) {
	v := m.addclose
	if v == nil {
		return
	}
	return *v, true
}

// ClearClose clears the value of the "close" field.
func (m *DailyAssetPriceMutation) ClearClose() {
	m.close = nil
	m.addclose = nil
	m.clearedFields[dailyassetprice.FieldClose] = struct{}{}
}

// CloseCleared returns if the "close" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) CloseCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldClose]
	return ok
}

// ResetClose resets all changes to the "close" field.
func (m *DailyAssetPriceMutation) ResetClose() {
	m.close = nil
	m.addclose = nil
	delete(m.clearedFields, dailyassetprice.FieldClose)
}

// SetAdjustedClose sets the "adjusted_close" field.
func (m *DailyAssetPriceMutation) SetAdjustedClose(f float64) {
	m.adjusted_close = &f
	m.addadjusted_close = nil
}

// AdjustedClose returns the value of the "adjusted_close" field in the mutation.
func (m *DailyAssetPriceMutation) AdjustedClose() (r float64, exists bool) {
	v := m.adjusted_close
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustedClose returns the old "adjusted_close" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldAdjustedClose(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdjustedClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdjustedClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustedClose: %w", err)
	}
	return oldValue.AdjustedClose, nil
}

// AddAdjustedClose adds f to the "adjusted_close" field.
func (m *DailyAssetPriceMutation) AddAdjustedClose(f float64) {
	if m.addadjusted_close != nil {
		*m.addadjusted_close += f
	} else {
		m.addadjusted_close = &f
	}
}

// AddedAdjustedClose returns the value that was added to the "adjusted_close" field in this mutation.
func (m *DailyAssetPriceMutation) AddedAdjustedClose() (r float64, exists bool) {
	v := m.addadjusted_close
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdjustedClose resets all changes to the "adjusted_close" field.
func (m *DailyAssetPriceMutation) ResetAdjustedClose() {
	m.adjusted_close = nil
	m.addadjusted_close = nil
}

// SetAssetID sets the "asset_id" field.
func (m *DailyAssetPriceMutation) SetAssetID(pu pulid.PULID) {
	m.asset = &pu
}

// AssetID returns the value of the "asset_id" field in the mutation.
func (m *DailyAssetPriceMutation) AssetID() (r pulid.PULID, exists bool) {
	v := m.asset
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "asset_id" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldAssetID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// ResetAssetID resets all changes to the "asset_id" field.
func (m *DailyAssetPriceMutation) ResetAssetID() {
	m.asset = nil
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *DailyAssetPriceMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *DailyAssetPriceMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *DailyAssetPriceMutation) AssetIDs() (ids []pulid.PULID) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *DailyAssetPriceMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// Where appends a list predicates to the DailyAssetPriceMutation builder.
func (m *DailyAssetPriceMutation) Where(ps ...predicate.DailyAssetPrice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DailyAssetPriceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DailyAssetPrice).
func (m *DailyAssetPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DailyAssetPriceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, dailyassetprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dailyassetprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dailyassetprice.FieldDeletedAt)
	}
	if m.time != nil {
		fields = append(fields, dailyassetprice.FieldTime)
	}
	if m.open != nil {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.high != nil {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.low != nil {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.close != nil {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	if m.adjusted_close != nil {
		fields = append(fields, dailyassetprice.FieldAdjustedClose)
	}
	if m.asset != nil {
		fields = append(fields, dailyassetprice.FieldAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DailyAssetPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		return m.CreatedAt()
	case dailyassetprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case dailyassetprice.FieldDeletedAt:
		return m.DeletedAt()
	case dailyassetprice.FieldTime:
		return m.Time()
	case dailyassetprice.FieldOpen:
		return m.Open()
	case dailyassetprice.FieldHigh:
		return m.High()
	case dailyassetprice.FieldLow:
		return m.Low()
	case dailyassetprice.FieldClose:
		return m.Close()
	case dailyassetprice.FieldAdjustedClose:
		return m.AdjustedClose()
	case dailyassetprice.FieldAssetID:
		return m.AssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DailyAssetPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dailyassetprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dailyassetprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dailyassetprice.FieldTime:
		return m.OldTime(ctx)
	case dailyassetprice.FieldOpen:
		return m.OldOpen(ctx)
	case dailyassetprice.FieldHigh:
		return m.OldHigh(ctx)
	case dailyassetprice.FieldLow:
		return m.OldLow(ctx)
	case dailyassetprice.FieldClose:
		return m.OldClose(ctx)
	case dailyassetprice.FieldAdjustedClose:
		return m.OldAdjustedClose(ctx)
	case dailyassetprice.FieldAssetID:
		return m.OldAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyAssetPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dailyassetprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dailyassetprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dailyassetprice.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case dailyassetprice.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case dailyassetprice.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case dailyassetprice.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLow(v)
		return nil
	case dailyassetprice.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClose(v)
		return nil
	case dailyassetprice.FieldAdjustedClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustedClose(v)
		return nil
	case dailyassetprice.FieldAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DailyAssetPriceMutation) AddedFields() []string {
	var fields []string
	if m.addopen != nil {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.addhigh != nil {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.addlow != nil {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.addclose != nil {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	if m.addadjusted_close != nil {
		fields = append(fields, dailyassetprice.FieldAdjustedClose)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DailyAssetPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dailyassetprice.FieldOpen:
		return m.AddedOpen()
	case dailyassetprice.FieldHigh:
		return m.AddedHigh()
	case dailyassetprice.FieldLow:
		return m.AddedLow()
	case dailyassetprice.FieldClose:
		return m.AddedClose()
	case dailyassetprice.FieldAdjustedClose:
		return m.AddedAdjustedClose()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyAssetPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dailyassetprice.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpen(v)
		return nil
	case dailyassetprice.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case dailyassetprice.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLow(v)
		return nil
	case dailyassetprice.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClose(v)
		return nil
	case dailyassetprice.FieldAdjustedClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdjustedClose(v)
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DailyAssetPriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dailyassetprice.FieldDeletedAt) {
		fields = append(fields, dailyassetprice.FieldDeletedAt)
	}
	if m.FieldCleared(dailyassetprice.FieldOpen) {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.FieldCleared(dailyassetprice.FieldHigh) {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.FieldCleared(dailyassetprice.FieldLow) {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.FieldCleared(dailyassetprice.FieldClose) {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DailyAssetPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DailyAssetPriceMutation) ClearField(name string) error {
	switch name {
	case dailyassetprice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dailyassetprice.FieldOpen:
		m.ClearOpen()
		return nil
	case dailyassetprice.FieldHigh:
		m.ClearHigh()
		return nil
	case dailyassetprice.FieldLow:
		m.ClearLow()
		return nil
	case dailyassetprice.FieldClose:
		m.ClearClose()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DailyAssetPriceMutation) ResetField(name string) error {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dailyassetprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dailyassetprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dailyassetprice.FieldTime:
		m.ResetTime()
		return nil
	case dailyassetprice.FieldOpen:
		m.ResetOpen()
		return nil
	case dailyassetprice.FieldHigh:
		m.ResetHigh()
		return nil
	case dailyassetprice.FieldLow:
		m.ResetLow()
		return nil
	case dailyassetprice.FieldClose:
		m.ResetClose()
		return nil
	case dailyassetprice.FieldAdjustedClose:
		m.ResetAdjustedClose()
		return nil
	case dailyassetprice.FieldAssetID:
		m.ResetAssetID()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DailyAssetPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.asset != nil {
		edges = append(edges, dailyassetprice.EdgeAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DailyAssetPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dailyassetprice.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DailyAssetPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DailyAssetPriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DailyAssetPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedasset {
		edges = append(edges, dailyassetprice.EdgeAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DailyAssetPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case dailyassetprice.EdgeAsset:
		return m.clearedasset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DailyAssetPriceMutation) ClearEdge(name string) error {
	switch name {
	case dailyassetprice.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DailyAssetPriceMutation) ResetEdge(name string) error {
	switch name {
	case dailyassetprice.EdgeAsset:
		m.ResetAsset()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	icon                *string
	url                 *string
	clearedFields       map[string]struct{}
	transactions        map[pulid.PULID]struct{}
	removedtransactions map[pulid.PULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Exchange, error)
	predicates          []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id pulid.PULID) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExchangeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExchangeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExchangeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exchange.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExchangeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExchangeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exchange.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *ExchangeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *ExchangeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *ExchangeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[exchange.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *ExchangeMutation) IconCleared() bool {
	_, ok := m.clearedFields[exchange.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *ExchangeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, exchange.FieldIcon)
}

// SetURL sets the "url" field.
func (m *ExchangeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ExchangeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ExchangeMutation) ClearURL() {
	m.url = nil
	m.clearedFields[exchange.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ExchangeMutation) URLCleared() bool {
	_, ok := m.clearedFields[exchange.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ExchangeMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, exchange.FieldURL)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *ExchangeMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *ExchangeMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *ExchangeMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *ExchangeMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *ExchangeMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *ExchangeMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *ExchangeMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, exchange.FieldIcon)
	}
	if m.url != nil {
		fields = append(fields, exchange.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	case exchange.FieldDeletedAt:
		return m.DeletedAt()
	case exchange.FieldName:
		return m.Name()
	case exchange.FieldIcon:
		return m.Icon()
	case exchange.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exchange.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exchange.FieldName:
		return m.OldName(ctx)
	case exchange.FieldIcon:
		return m.OldIcon(ctx)
	case exchange.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exchange.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exchange.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchange.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case exchange.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldDeletedAt) {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.FieldCleared(exchange.FieldIcon) {
		fields = append(fields, exchange.FieldIcon)
	}
	if m.FieldCleared(exchange.FieldURL) {
		fields = append(fields, exchange.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exchange.FieldIcon:
		m.ClearIcon()
		return nil
	case exchange.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exchange.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exchange.FieldName:
		m.ResetName()
		return nil
	case exchange.FieldIcon:
		m.ResetIcon()
		return nil
	case exchange.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	is_public           *bool
	is_visible          *bool
	clearedFields       map[string]struct{}
	account             *pulid.PULID
	clearedaccount      bool
	transactions        map[pulid.PULID]struct{}
	removedtransactions map[pulid.PULID]struct{}
	clearedtransactions bool
	connections         map[pulid.PULID]struct{}
	removedconnections  map[pulid.PULID]struct{}
	clearedconnections  bool
	done                bool
	oldValue            func(context.Context) (*Portfolio, error)
	predicates          []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id pulid.PULID) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Portfolio entities.
func (m *PortfolioMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PortfolioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortfolioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortfolioMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortfolioMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortfolioMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortfolioMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PortfolioMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PortfolioMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PortfolioMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[portfolio.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PortfolioMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PortfolioMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, portfolio.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PortfolioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortfolioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortfolioMutation) ResetName() {
	m.name = nil
}

// SetIsPublic sets the "is_public" field.
func (m *PortfolioMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *PortfolioMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *PortfolioMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetIsVisible sets the "is_visible" field.
func (m *PortfolioMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *PortfolioMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *PortfolioMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetAccountID sets the "account_id" field.
func (m *PortfolioMutation) SetAccountID(pu pulid.PULID) {
	m.account = &pu
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PortfolioMutation) AccountID() (r pulid.PULID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldAccountID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PortfolioMutation) ResetAccountID() {
	m.account = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *PortfolioMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *PortfolioMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) AccountIDs() (ids []pulid.PULID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *PortfolioMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *PortfolioMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *PortfolioMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *PortfolioMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *PortfolioMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *PortfolioMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PortfolioMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PortfolioMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddConnectionIDs adds the "connections" edge to the Connection entity by ids.
func (m *PortfolioMutation) AddConnectionIDs(ids ...pulid.PULID) {
	if m.connections == nil {
		m.connections = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.connections[ids[i]] = struct{}{}
	}
}

// ClearConnections clears the "connections" edge to the Connection entity.
func (m *PortfolioMutation) ClearConnections() {
	m.clearedconnections = true
}

// ConnectionsCleared reports if the "connections" edge to the Connection entity was cleared.
func (m *PortfolioMutation) ConnectionsCleared() bool {
	return m.clearedconnections
}

// RemoveConnectionIDs removes the "connections" edge to the Connection entity by IDs.
func (m *PortfolioMutation) RemoveConnectionIDs(ids ...pulid.PULID) {
	if m.removedconnections == nil {
		m.removedconnections = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.connections, ids[i])
		m.removedconnections[ids[i]] = struct{}{}
	}
}

// RemovedConnections returns the removed IDs of the "connections" edge to the Connection entity.
func (m *PortfolioMutation) RemovedConnectionsIDs() (ids []pulid.PULID) {
	for id := range m.removedconnections {
		ids = append(ids, id)
	}
	return
}

// ConnectionsIDs returns the "connections" edge IDs in the mutation.
func (m *PortfolioMutation) ConnectionsIDs() (ids []pulid.PULID) {
	for id := range m.connections {
		ids = append(ids, id)
	}
	return
}

// ResetConnections resets all changes to the "connections" edge.
func (m *PortfolioMutation) ResetConnections() {
	m.connections = nil
	m.clearedconnections = false
	m.removedconnections = nil
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, portfolio.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, portfolio.FieldName)
	}
	if m.is_public != nil {
		fields = append(fields, portfolio.FieldIsPublic)
	}
	if m.is_visible != nil {
		fields = append(fields, portfolio.FieldIsVisible)
	}
	if m.account != nil {
		fields = append(fields, portfolio.FieldAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.CreatedAt()
	case portfolio.FieldUpdatedAt:
		return m.UpdatedAt()
	case portfolio.FieldDeletedAt:
		return m.DeletedAt()
	case portfolio.FieldName:
		return m.Name()
	case portfolio.FieldIsPublic:
		return m.IsPublic()
	case portfolio.FieldIsVisible:
		return m.IsVisible()
	case portfolio.FieldAccountID:
		return m.AccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portfolio.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case portfolio.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case portfolio.FieldName:
		return m.OldName(ctx)
	case portfolio.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case portfolio.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case portfolio.FieldAccountID:
		return m.OldAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portfolio.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case portfolio.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case portfolio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portfolio.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case portfolio.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case portfolio.FieldAccountID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portfolio.FieldDeletedAt) {
		fields = append(fields, portfolio.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	switch name {
	case portfolio.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case portfolio.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case portfolio.FieldName:
		m.ResetName()
		return nil
	case portfolio.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case portfolio.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case portfolio.FieldAccountID:
		m.ResetAccountID()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.account != nil {
		edges = append(edges, portfolio.EdgeAccount)
	}
	if m.transactions != nil {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	if m.connections != nil {
		edges = append(edges, portfolio.EdgeConnections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case portfolio.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case portfolio.EdgeConnections:
		ids := make([]ent.Value, 0, len(m.connections))
		for id := range m.connections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransactions != nil {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	if m.removedconnections != nil {
		edges = append(edges, portfolio.EdgeConnections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case portfolio.EdgeConnections:
		ids := make([]ent.Value, 0, len(m.removedconnections))
		for id := range m.removedconnections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaccount {
		edges = append(edges, portfolio.EdgeAccount)
	}
	if m.clearedtransactions {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	if m.clearedconnections {
		edges = append(edges, portfolio.EdgeConnections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	switch name {
	case portfolio.EdgeAccount:
		return m.clearedaccount
	case portfolio.EdgeTransactions:
		return m.clearedtransactions
	case portfolio.EdgeConnections:
		return m.clearedconnections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	switch name {
	case portfolio.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	switch name {
	case portfolio.EdgeAccount:
		m.ResetAccount()
		return nil
	case portfolio.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case portfolio.EdgeConnections:
		m.ResetConnections()
		return nil
	}
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// SourceMutation represents an operation that mutates the Source nodes in the graph.
type SourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.PULID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	icon               *string
	clearedFields      map[string]struct{}
	source_type        *pulid.PULID
	clearedsource_type bool
	done               bool
	oldValue           func(context.Context) (*Source, error)
	predicates         []predicate.Source
}

var _ ent.Mutation = (*SourceMutation)(nil)

// sourceOption allows management of the mutation configuration using functional options.
type sourceOption func(*SourceMutation)

// newSourceMutation creates new mutation for the Source entity.
func newSourceMutation(c config, op Op, opts ...sourceOption) *SourceMutation {
	m := &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceID sets the ID field of the mutation.
func withSourceID(id pulid.PULID) sourceOption {
	return func(m *SourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Source
		)
		m.oldValue = func(ctx context.Context) (*Source, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Source.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSource sets the old Source of the mutation.
func withSource(node *Source) sourceOption {
	return func(m *SourceMutation) {
		m.oldValue = func(context.Context) (*Source, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Source entities.
func (m *SourceMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Source.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SourceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SourceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SourceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[source.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SourceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[source.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SourceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, source.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SourceMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *SourceMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *SourceMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *SourceMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[source.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *SourceMutation) IconCleared() bool {
	_, ok := m.clearedFields[source.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *SourceMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, source.FieldIcon)
}

// SetSourceTypeID sets the "source_type_id" field.
func (m *SourceMutation) SetSourceTypeID(pu pulid.PULID) {
	m.source_type = &pu
}

// SourceTypeID returns the value of the "source_type_id" field in the mutation.
func (m *SourceMutation) SourceTypeID() (r pulid.PULID, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceTypeID returns the old "source_type_id" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldSourceTypeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceTypeID: %w", err)
	}
	return oldValue.SourceTypeID, nil
}

// ResetSourceTypeID resets all changes to the "source_type_id" field.
func (m *SourceMutation) ResetSourceTypeID() {
	m.source_type = nil
}

// ClearSourceType clears the "source_type" edge to the SourceType entity.
func (m *SourceMutation) ClearSourceType() {
	m.clearedsource_type = true
}

// SourceTypeCleared reports if the "source_type" edge to the SourceType entity was cleared.
func (m *SourceMutation) SourceTypeCleared() bool {
	return m.clearedsource_type
}

// SourceTypeIDs returns the "source_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceTypeID instead. It exists only for internal usage by the builders.
func (m *SourceMutation) SourceTypeIDs() (ids []pulid.PULID) {
	if id := m.source_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceType resets all changes to the "source_type" edge.
func (m *SourceMutation) ResetSourceType() {
	m.source_type = nil
	m.clearedsource_type = false
}

// Where appends a list predicates to the SourceMutation builder.
func (m *SourceMutation) Where(ps ...predicate.Source) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, source.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, source.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, source.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, source.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, source.FieldIcon)
	}
	if m.source_type != nil {
		fields = append(fields, source.FieldSourceTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldCreatedAt:
		return m.CreatedAt()
	case source.FieldUpdatedAt:
		return m.UpdatedAt()
	case source.FieldDeletedAt:
		return m.DeletedAt()
	case source.FieldName:
		return m.Name()
	case source.FieldIcon:
		return m.Icon()
	case source.FieldSourceTypeID:
		return m.SourceTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case source.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case source.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case source.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case source.FieldName:
		return m.OldName(ctx)
	case source.FieldIcon:
		return m.OldIcon(ctx)
	case source.FieldSourceTypeID:
		return m.OldSourceTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown Source field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case source.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case source.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case source.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case source.FieldSourceTypeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(source.FieldDeletedAt) {
		fields = append(fields, source.FieldDeletedAt)
	}
	if m.FieldCleared(source.FieldIcon) {
		fields = append(fields, source.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	switch name {
	case source.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case source.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case source.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case source.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case source.FieldName:
		m.ResetName()
		return nil
	case source.FieldIcon:
		m.ResetIcon()
		return nil
	case source.FieldSourceTypeID:
		m.ResetSourceTypeID()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source_type != nil {
		edges = append(edges, source.EdgeSourceType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeSourceType:
		if id := m.source_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource_type {
		edges = append(edges, source.EdgeSourceType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	switch name {
	case source.EdgeSourceType:
		return m.clearedsource_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	switch name {
	case source.EdgeSourceType:
		m.ClearSourceType()
		return nil
	}
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	switch name {
	case source.EdgeSourceType:
		m.ResetSourceType()
		return nil
	}
	return fmt.Errorf("unknown Source edge %s", name)
}

// SourceTypeMutation represents an operation that mutates the SourceType nodes in the graph.
type SourceTypeMutation struct {
	config
	op             Op
	typ            string
	id             *pulid.PULID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	value          *sourcetype.Value
	description    *string
	clearedFields  map[string]struct{}
	sources        map[pulid.PULID]struct{}
	removedsources map[pulid.PULID]struct{}
	clearedsources bool
	done           bool
	oldValue       func(context.Context) (*SourceType, error)
	predicates     []predicate.SourceType
}

var _ ent.Mutation = (*SourceTypeMutation)(nil)

// sourcetypeOption allows management of the mutation configuration using functional options.
type sourcetypeOption func(*SourceTypeMutation)

// newSourceTypeMutation creates new mutation for the SourceType entity.
func newSourceTypeMutation(c config, op Op, opts ...sourcetypeOption) *SourceTypeMutation {
	m := &SourceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceTypeID sets the ID field of the mutation.
func withSourceTypeID(id pulid.PULID) sourcetypeOption {
	return func(m *SourceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceType
		)
		m.oldValue = func(ctx context.Context) (*SourceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceType sets the old SourceType of the mutation.
func withSourceType(node *SourceType) sourcetypeOption {
	return func(m *SourceTypeMutation) {
		m.oldValue = func(context.Context) (*SourceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceType entities.
func (m *SourceTypeMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceTypeMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceTypeMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SourceTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SourceTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SourceTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SourceTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SourceTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SourceTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sourcetype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SourceTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sourcetype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SourceTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sourcetype.FieldDeletedAt)
}

// SetValue sets the "value" field.
func (m *SourceTypeMutation) SetValue(s sourcetype.Value) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SourceTypeMutation) Value() (r sourcetype.Value, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldValue(ctx context.Context) (v sourcetype.Value, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SourceTypeMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *SourceTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SourceTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SourceType entity.
// If the SourceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SourceTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[sourcetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SourceTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[sourcetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SourceTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, sourcetype.FieldDescription)
}

// AddSourceIDs adds the "sources" edge to the Source entity by ids.
func (m *SourceTypeMutation) AddSourceIDs(ids ...pulid.PULID) {
	if m.sources == nil {
		m.sources = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.sources[ids[i]] = struct{}{}
	}
}

// ClearSources clears the "sources" edge to the Source entity.
func (m *SourceTypeMutation) ClearSources() {
	m.clearedsources = true
}

// SourcesCleared reports if the "sources" edge to the Source entity was cleared.
func (m *SourceTypeMutation) SourcesCleared() bool {
	return m.clearedsources
}

// RemoveSourceIDs removes the "sources" edge to the Source entity by IDs.
func (m *SourceTypeMutation) RemoveSourceIDs(ids ...pulid.PULID) {
	if m.removedsources == nil {
		m.removedsources = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.sources, ids[i])
		m.removedsources[ids[i]] = struct{}{}
	}
}

// RemovedSources returns the removed IDs of the "sources" edge to the Source entity.
func (m *SourceTypeMutation) RemovedSourcesIDs() (ids []pulid.PULID) {
	for id := range m.removedsources {
		ids = append(ids, id)
	}
	return
}

// SourcesIDs returns the "sources" edge IDs in the mutation.
func (m *SourceTypeMutation) SourcesIDs() (ids []pulid.PULID) {
	for id := range m.sources {
		ids = append(ids, id)
	}
	return
}

// ResetSources resets all changes to the "sources" edge.
func (m *SourceTypeMutation) ResetSources() {
	m.sources = nil
	m.clearedsources = false
	m.removedsources = nil
}

// Where appends a list predicates to the SourceTypeMutation builder.
func (m *SourceTypeMutation) Where(ps ...predicate.SourceType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SourceTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SourceType).
func (m *SourceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, sourcetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sourcetype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sourcetype.FieldDeletedAt)
	}
	if m.value != nil {
		fields = append(fields, sourcetype.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, sourcetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourcetype.FieldCreatedAt:
		return m.CreatedAt()
	case sourcetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case sourcetype.FieldDeletedAt:
		return m.DeletedAt()
	case sourcetype.FieldValue:
		return m.Value()
	case sourcetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourcetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sourcetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sourcetype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case sourcetype.FieldValue:
		return m.OldValue(ctx)
	case sourcetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SourceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourcetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sourcetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sourcetype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case sourcetype.FieldValue:
		v, ok := value.(sourcetype.Value)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case sourcetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SourceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourcetype.FieldDeletedAt) {
		fields = append(fields, sourcetype.FieldDeletedAt)
	}
	if m.FieldCleared(sourcetype.FieldDescription) {
		fields = append(fields, sourcetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceTypeMutation) ClearField(name string) error {
	switch name {
	case sourcetype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case sourcetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SourceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceTypeMutation) ResetField(name string) error {
	switch name {
	case sourcetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sourcetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sourcetype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case sourcetype.FieldValue:
		m.ResetValue()
		return nil
	case sourcetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SourceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sources != nil {
		edges = append(edges, sourcetype.EdgeSources)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourcetype.EdgeSources:
		ids := make([]ent.Value, 0, len(m.sources))
		for id := range m.sources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsources != nil {
		edges = append(edges, sourcetype.EdgeSources)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sourcetype.EdgeSources:
		ids := make([]ent.Value, 0, len(m.removedsources))
		for id := range m.removedsources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsources {
		edges = append(edges, sourcetype.EdgeSources)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case sourcetype.EdgeSources:
		return m.clearedsources
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceTypeMutation) ResetEdge(name string) error {
	switch name {
	case sourcetype.EdgeSources:
		m.ResetSources()
		return nil
	}
	return fmt.Errorf("unknown SourceType edge %s", name)
}

// StaffAccountMutation represents an operation that mutates the StaffAccount nodes in the graph.
type StaffAccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	nickname            *string
	email               *string
	password            *string
	password_updated_at *time.Time
	clearedFields       map[string]struct{}
	auth_roles          map[pulid.PULID]struct{}
	removedauth_roles   map[pulid.PULID]struct{}
	clearedauth_roles   bool
	auth_type           *pulid.PULID
	clearedauth_type    bool
	done                bool
	oldValue            func(context.Context) (*StaffAccount, error)
	predicates          []predicate.StaffAccount
}

var _ ent.Mutation = (*StaffAccountMutation)(nil)

// staffaccountOption allows management of the mutation configuration using functional options.
type staffaccountOption func(*StaffAccountMutation)

// newStaffAccountMutation creates new mutation for the StaffAccount entity.
func newStaffAccountMutation(c config, op Op, opts ...staffaccountOption) *StaffAccountMutation {
	m := &StaffAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeStaffAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffAccountID sets the ID field of the mutation.
func withStaffAccountID(id pulid.PULID) staffaccountOption {
	return func(m *StaffAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *StaffAccount
		)
		m.oldValue = func(ctx context.Context) (*StaffAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StaffAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaffAccount sets the old StaffAccount of the mutation.
func withStaffAccount(node *StaffAccount) staffaccountOption {
	return func(m *StaffAccountMutation) {
		m.oldValue = func(context.Context) (*StaffAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StaffAccount entities.
func (m *StaffAccountMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffAccountMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffAccountMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StaffAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StaffAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StaffAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StaffAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StaffAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StaffAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StaffAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StaffAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StaffAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StaffAccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[staffaccount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StaffAccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[staffaccount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StaffAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, staffaccount.FieldDeletedAt)
}

// SetNickname sets the "nickname" field.
func (m *StaffAccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *StaffAccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *StaffAccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *StaffAccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StaffAccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StaffAccountMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *StaffAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StaffAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *StaffAccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[staffaccount.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *StaffAccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[staffaccount.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *StaffAccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, staffaccount.FieldPassword)
}

// SetPasswordUpdatedAt sets the "password_updated_at" field.
func (m *StaffAccountMutation) SetPasswordUpdatedAt(t time.Time) {
	m.password_updated_at = &t
}

// PasswordUpdatedAt returns the value of the "password_updated_at" field in the mutation.
func (m *StaffAccountMutation) PasswordUpdatedAt() (r time.Time, exists bool) {
	v := m.password_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordUpdatedAt returns the old "password_updated_at" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldPasswordUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordUpdatedAt: %w", err)
	}
	return oldValue.PasswordUpdatedAt, nil
}

// ResetPasswordUpdatedAt resets all changes to the "password_updated_at" field.
func (m *StaffAccountMutation) ResetPasswordUpdatedAt() {
	m.password_updated_at = nil
}

// SetAuthTypeID sets the "auth_type_id" field.
func (m *StaffAccountMutation) SetAuthTypeID(pu pulid.PULID) {
	m.auth_type = &pu
}

// AuthTypeID returns the value of the "auth_type_id" field in the mutation.
func (m *StaffAccountMutation) AuthTypeID() (r pulid.PULID, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTypeID returns the old "auth_type_id" field's value of the StaffAccount entity.
// If the StaffAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffAccountMutation) OldAuthTypeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTypeID: %w", err)
	}
	return oldValue.AuthTypeID, nil
}

// ResetAuthTypeID resets all changes to the "auth_type_id" field.
func (m *StaffAccountMutation) ResetAuthTypeID() {
	m.auth_type = nil
}

// AddAuthRoleIDs adds the "auth_roles" edge to the AuthRole entity by ids.
func (m *StaffAccountMutation) AddAuthRoleIDs(ids ...pulid.PULID) {
	if m.auth_roles == nil {
		m.auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.auth_roles[ids[i]] = struct{}{}
	}
}

// ClearAuthRoles clears the "auth_roles" edge to the AuthRole entity.
func (m *StaffAccountMutation) ClearAuthRoles() {
	m.clearedauth_roles = true
}

// AuthRolesCleared reports if the "auth_roles" edge to the AuthRole entity was cleared.
func (m *StaffAccountMutation) AuthRolesCleared() bool {
	return m.clearedauth_roles
}

// RemoveAuthRoleIDs removes the "auth_roles" edge to the AuthRole entity by IDs.
func (m *StaffAccountMutation) RemoveAuthRoleIDs(ids ...pulid.PULID) {
	if m.removedauth_roles == nil {
		m.removedauth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.auth_roles, ids[i])
		m.removedauth_roles[ids[i]] = struct{}{}
	}
}

// RemovedAuthRoles returns the removed IDs of the "auth_roles" edge to the AuthRole entity.
func (m *StaffAccountMutation) RemovedAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.removedauth_roles {
		ids = append(ids, id)
	}
	return
}

// AuthRolesIDs returns the "auth_roles" edge IDs in the mutation.
func (m *StaffAccountMutation) AuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.auth_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAuthRoles resets all changes to the "auth_roles" edge.
func (m *StaffAccountMutation) ResetAuthRoles() {
	m.auth_roles = nil
	m.clearedauth_roles = false
	m.removedauth_roles = nil
}

// ClearAuthType clears the "auth_type" edge to the AuthType entity.
func (m *StaffAccountMutation) ClearAuthType() {
	m.clearedauth_type = true
}

// AuthTypeCleared reports if the "auth_type" edge to the AuthType entity was cleared.
func (m *StaffAccountMutation) AuthTypeCleared() bool {
	return m.clearedauth_type
}

// AuthTypeIDs returns the "auth_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthTypeID instead. It exists only for internal usage by the builders.
func (m *StaffAccountMutation) AuthTypeIDs() (ids []pulid.PULID) {
	if id := m.auth_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthType resets all changes to the "auth_type" edge.
func (m *StaffAccountMutation) ResetAuthType() {
	m.auth_type = nil
	m.clearedauth_type = false
}

// Where appends a list predicates to the StaffAccountMutation builder.
func (m *StaffAccountMutation) Where(ps ...predicate.StaffAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StaffAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StaffAccount).
func (m *StaffAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffAccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, staffaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, staffaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, staffaccount.FieldDeletedAt)
	}
	if m.nickname != nil {
		fields = append(fields, staffaccount.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, staffaccount.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, staffaccount.FieldPassword)
	}
	if m.password_updated_at != nil {
		fields = append(fields, staffaccount.FieldPasswordUpdatedAt)
	}
	if m.auth_type != nil {
		fields = append(fields, staffaccount.FieldAuthTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staffaccount.FieldCreatedAt:
		return m.CreatedAt()
	case staffaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case staffaccount.FieldDeletedAt:
		return m.DeletedAt()
	case staffaccount.FieldNickname:
		return m.Nickname()
	case staffaccount.FieldEmail:
		return m.Email()
	case staffaccount.FieldPassword:
		return m.Password()
	case staffaccount.FieldPasswordUpdatedAt:
		return m.PasswordUpdatedAt()
	case staffaccount.FieldAuthTypeID:
		return m.AuthTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staffaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case staffaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case staffaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case staffaccount.FieldNickname:
		return m.OldNickname(ctx)
	case staffaccount.FieldEmail:
		return m.OldEmail(ctx)
	case staffaccount.FieldPassword:
		return m.OldPassword(ctx)
	case staffaccount.FieldPasswordUpdatedAt:
		return m.OldPasswordUpdatedAt(ctx)
	case staffaccount.FieldAuthTypeID:
		return m.OldAuthTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown StaffAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staffaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case staffaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case staffaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case staffaccount.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case staffaccount.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case staffaccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case staffaccount.FieldPasswordUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordUpdatedAt(v)
		return nil
	case staffaccount.FieldAuthTypeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown StaffAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StaffAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(staffaccount.FieldDeletedAt) {
		fields = append(fields, staffaccount.FieldDeletedAt)
	}
	if m.FieldCleared(staffaccount.FieldPassword) {
		fields = append(fields, staffaccount.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffAccountMutation) ClearField(name string) error {
	switch name {
	case staffaccount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case staffaccount.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown StaffAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffAccountMutation) ResetField(name string) error {
	switch name {
	case staffaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case staffaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case staffaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case staffaccount.FieldNickname:
		m.ResetNickname()
		return nil
	case staffaccount.FieldEmail:
		m.ResetEmail()
		return nil
	case staffaccount.FieldPassword:
		m.ResetPassword()
		return nil
	case staffaccount.FieldPasswordUpdatedAt:
		m.ResetPasswordUpdatedAt()
		return nil
	case staffaccount.FieldAuthTypeID:
		m.ResetAuthTypeID()
		return nil
	}
	return fmt.Errorf("unknown StaffAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.auth_roles != nil {
		edges = append(edges, staffaccount.EdgeAuthRoles)
	}
	if m.auth_type != nil {
		edges = append(edges, staffaccount.EdgeAuthType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staffaccount.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.auth_roles))
		for id := range m.auth_roles {
			ids = append(ids, id)
		}
		return ids
	case staffaccount.EdgeAuthType:
		if id := m.auth_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedauth_roles != nil {
		edges = append(edges, staffaccount.EdgeAuthRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staffaccount.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.removedauth_roles))
		for id := range m.removedauth_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauth_roles {
		edges = append(edges, staffaccount.EdgeAuthRoles)
	}
	if m.clearedauth_type {
		edges = append(edges, staffaccount.EdgeAuthType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case staffaccount.EdgeAuthRoles:
		return m.clearedauth_roles
	case staffaccount.EdgeAuthType:
		return m.clearedauth_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffAccountMutation) ClearEdge(name string) error {
	switch name {
	case staffaccount.EdgeAuthType:
		m.ClearAuthType()
		return nil
	}
	return fmt.Errorf("unknown StaffAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffAccountMutation) ResetEdge(name string) error {
	switch name {
	case staffaccount.EdgeAuthRoles:
		m.ResetAuthRoles()
		return nil
	case staffaccount.EdgeAuthType:
		m.ResetAuthType()
		return nil
	}
	return fmt.Errorf("unknown StaffAccount edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.PULID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	time                    *time.Time
	units                   *int
	addunits                *int
	price_per_unit          *float64
	addprice_per_unit       *float64
	clearedFields           map[string]struct{}
	transaction_type        *pulid.PULID
	clearedtransaction_type bool
	base_asset              *pulid.PULID
	clearedbase_asset       bool
	quote_asset             *pulid.PULID
	clearedquote_asset      bool
	portfolio               *pulid.PULID
	clearedportfolio        bool
	exchange                *pulid.PULID
	clearedexchange         bool
	blockchain              *pulid.PULID
	clearedblockchain       bool
	done                    bool
	oldValue                func(context.Context) (*Transaction, error)
	predicates              []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id pulid.PULID) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransactionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransactionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransactionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transaction.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransactionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransactionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transaction.FieldDeletedAt)
}

// SetTime sets the "time" field.
func (m *TransactionMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TransactionMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TransactionMutation) ResetTime() {
	m.time = nil
}

// SetUnits sets the "units" field.
func (m *TransactionMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *TransactionMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *TransactionMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *TransactionMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *TransactionMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetPricePerUnit sets the "price_per_unit" field.
func (m *TransactionMutation) SetPricePerUnit(f float64) {
	m.price_per_unit = &f
	m.addprice_per_unit = nil
}

// PricePerUnit returns the value of the "price_per_unit" field in the mutation.
func (m *TransactionMutation) PricePerUnit() (r float64, exists bool) {
	v := m.price_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerUnit returns the old "price_per_unit" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPricePerUnit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerUnit: %w", err)
	}
	return oldValue.PricePerUnit, nil
}

// AddPricePerUnit adds f to the "price_per_unit" field.
func (m *TransactionMutation) AddPricePerUnit(f float64) {
	if m.addprice_per_unit != nil {
		*m.addprice_per_unit += f
	} else {
		m.addprice_per_unit = &f
	}
}

// AddedPricePerUnit returns the value that was added to the "price_per_unit" field in this mutation.
func (m *TransactionMutation) AddedPricePerUnit() (r float64, exists bool) {
	v := m.addprice_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerUnit resets all changes to the "price_per_unit" field.
func (m *TransactionMutation) ResetPricePerUnit() {
	m.price_per_unit = nil
	m.addprice_per_unit = nil
}

// SetBlockchainID sets the "blockchain_id" field.
func (m *TransactionMutation) SetBlockchainID(pu pulid.PULID) {
	m.blockchain = &pu
}

// BlockchainID returns the value of the "blockchain_id" field in the mutation.
func (m *TransactionMutation) BlockchainID() (r pulid.PULID, exists bool) {
	v := m.blockchain
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockchainID returns the old "blockchain_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBlockchainID(ctx context.Context) (v *pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockchainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockchainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockchainID: %w", err)
	}
	return oldValue.BlockchainID, nil
}

// ClearBlockchainID clears the value of the "blockchain_id" field.
func (m *TransactionMutation) ClearBlockchainID() {
	m.blockchain = nil
	m.clearedFields[transaction.FieldBlockchainID] = struct{}{}
}

// BlockchainIDCleared returns if the "blockchain_id" field was cleared in this mutation.
func (m *TransactionMutation) BlockchainIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldBlockchainID]
	return ok
}

// ResetBlockchainID resets all changes to the "blockchain_id" field.
func (m *TransactionMutation) ResetBlockchainID() {
	m.blockchain = nil
	delete(m.clearedFields, transaction.FieldBlockchainID)
}

// SetTransactionTypeID sets the "transaction_type_id" field.
func (m *TransactionMutation) SetTransactionTypeID(pu pulid.PULID) {
	m.transaction_type = &pu
}

// TransactionTypeID returns the value of the "transaction_type_id" field in the mutation.
func (m *TransactionMutation) TransactionTypeID() (r pulid.PULID, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionTypeID returns the old "transaction_type_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionTypeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionTypeID: %w", err)
	}
	return oldValue.TransactionTypeID, nil
}

// ResetTransactionTypeID resets all changes to the "transaction_type_id" field.
func (m *TransactionMutation) ResetTransactionTypeID() {
	m.transaction_type = nil
}

// SetExchangeID sets the "exchange_id" field.
func (m *TransactionMutation) SetExchangeID(pu pulid.PULID) {
	m.exchange = &pu
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *TransactionMutation) ExchangeID() (r pulid.PULID, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldExchangeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *TransactionMutation) ResetExchangeID() {
	m.exchange = nil
}

// SetPortfolioID sets the "portfolio_id" field.
func (m *TransactionMutation) SetPortfolioID(pu pulid.PULID) {
	m.portfolio = &pu
}

// PortfolioID returns the value of the "portfolio_id" field in the mutation.
func (m *TransactionMutation) PortfolioID() (r pulid.PULID, exists bool) {
	v := m.portfolio
	if v == nil {
		return
	}
	return *v, true
}

// OldPortfolioID returns the old "portfolio_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPortfolioID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPortfolioID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPortfolioID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPortfolioID: %w", err)
	}
	return oldValue.PortfolioID, nil
}

// ResetPortfolioID resets all changes to the "portfolio_id" field.
func (m *TransactionMutation) ResetPortfolioID() {
	m.portfolio = nil
}

// SetBaseAssetID sets the "base_asset_id" field.
func (m *TransactionMutation) SetBaseAssetID(pu pulid.PULID) {
	m.base_asset = &pu
}

// BaseAssetID returns the value of the "base_asset_id" field in the mutation.
func (m *TransactionMutation) BaseAssetID() (r pulid.PULID, exists bool) {
	v := m.base_asset
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseAssetID returns the old "base_asset_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBaseAssetID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseAssetID: %w", err)
	}
	return oldValue.BaseAssetID, nil
}

// ResetBaseAssetID resets all changes to the "base_asset_id" field.
func (m *TransactionMutation) ResetBaseAssetID() {
	m.base_asset = nil
}

// SetQuoteAssetID sets the "quote_asset_id" field.
func (m *TransactionMutation) SetQuoteAssetID(pu pulid.PULID) {
	m.quote_asset = &pu
}

// QuoteAssetID returns the value of the "quote_asset_id" field in the mutation.
func (m *TransactionMutation) QuoteAssetID() (r pulid.PULID, exists bool) {
	v := m.quote_asset
	if v == nil {
		return
	}
	return *v, true
}

// OldQuoteAssetID returns the old "quote_asset_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldQuoteAssetID(ctx context.Context) (v *pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuoteAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuoteAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuoteAssetID: %w", err)
	}
	return oldValue.QuoteAssetID, nil
}

// ClearQuoteAssetID clears the value of the "quote_asset_id" field.
func (m *TransactionMutation) ClearQuoteAssetID() {
	m.quote_asset = nil
	m.clearedFields[transaction.FieldQuoteAssetID] = struct{}{}
}

// QuoteAssetIDCleared returns if the "quote_asset_id" field was cleared in this mutation.
func (m *TransactionMutation) QuoteAssetIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldQuoteAssetID]
	return ok
}

// ResetQuoteAssetID resets all changes to the "quote_asset_id" field.
func (m *TransactionMutation) ResetQuoteAssetID() {
	m.quote_asset = nil
	delete(m.clearedFields, transaction.FieldQuoteAssetID)
}

// ClearTransactionType clears the "transaction_type" edge to the TransactionType entity.
func (m *TransactionMutation) ClearTransactionType() {
	m.clearedtransaction_type = true
}

// TransactionTypeCleared reports if the "transaction_type" edge to the TransactionType entity was cleared.
func (m *TransactionMutation) TransactionTypeCleared() bool {
	return m.clearedtransaction_type
}

// TransactionTypeIDs returns the "transaction_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionTypeID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) TransactionTypeIDs() (ids []pulid.PULID) {
	if id := m.transaction_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransactionType resets all changes to the "transaction_type" edge.
func (m *TransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
	m.clearedtransaction_type = false
}

// ClearBaseAsset clears the "base_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearBaseAsset() {
	m.clearedbase_asset = true
}

// BaseAssetCleared reports if the "base_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) BaseAssetCleared() bool {
	return m.clearedbase_asset
}

// BaseAssetIDs returns the "base_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseAssetID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) BaseAssetIDs() (ids []pulid.PULID) {
	if id := m.base_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBaseAsset resets all changes to the "base_asset" edge.
func (m *TransactionMutation) ResetBaseAsset() {
	m.base_asset = nil
	m.clearedbase_asset = false
}

// ClearQuoteAsset clears the "quote_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearQuoteAsset() {
	m.clearedquote_asset = true
}

// QuoteAssetCleared reports if the "quote_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) QuoteAssetCleared() bool {
	return m.QuoteAssetIDCleared() || m.clearedquote_asset
}

// QuoteAssetIDs returns the "quote_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuoteAssetID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) QuoteAssetIDs() (ids []pulid.PULID) {
	if id := m.quote_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuoteAsset resets all changes to the "quote_asset" edge.
func (m *TransactionMutation) ResetQuoteAsset() {
	m.quote_asset = nil
	m.clearedquote_asset = false
}

// ClearPortfolio clears the "portfolio" edge to the Portfolio entity.
func (m *TransactionMutation) ClearPortfolio() {
	m.clearedportfolio = true
}

// PortfolioCleared reports if the "portfolio" edge to the Portfolio entity was cleared.
func (m *TransactionMutation) PortfolioCleared() bool {
	return m.clearedportfolio
}

// PortfolioIDs returns the "portfolio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PortfolioID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) PortfolioIDs() (ids []pulid.PULID) {
	if id := m.portfolio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPortfolio resets all changes to the "portfolio" edge.
func (m *TransactionMutation) ResetPortfolio() {
	m.portfolio = nil
	m.clearedportfolio = false
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *TransactionMutation) ClearExchange() {
	m.clearedexchange = true
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *TransactionMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ExchangeIDs() (ids []pulid.PULID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *TransactionMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// ClearBlockchain clears the "blockchain" edge to the Blockchain entity.
func (m *TransactionMutation) ClearBlockchain() {
	m.clearedblockchain = true
}

// BlockchainCleared reports if the "blockchain" edge to the Blockchain entity was cleared.
func (m *TransactionMutation) BlockchainCleared() bool {
	return m.BlockchainIDCleared() || m.clearedblockchain
}

// BlockchainIDs returns the "blockchain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockchainID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) BlockchainIDs() (ids []pulid.PULID) {
	if id := m.blockchain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockchain resets all changes to the "blockchain" edge.
func (m *TransactionMutation) ResetBlockchain() {
	m.blockchain = nil
	m.clearedblockchain = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transaction.FieldDeletedAt)
	}
	if m.time != nil {
		fields = append(fields, transaction.FieldTime)
	}
	if m.units != nil {
		fields = append(fields, transaction.FieldUnits)
	}
	if m.price_per_unit != nil {
		fields = append(fields, transaction.FieldPricePerUnit)
	}
	if m.blockchain != nil {
		fields = append(fields, transaction.FieldBlockchainID)
	}
	if m.transaction_type != nil {
		fields = append(fields, transaction.FieldTransactionTypeID)
	}
	if m.exchange != nil {
		fields = append(fields, transaction.FieldExchangeID)
	}
	if m.portfolio != nil {
		fields = append(fields, transaction.FieldPortfolioID)
	}
	if m.base_asset != nil {
		fields = append(fields, transaction.FieldBaseAssetID)
	}
	if m.quote_asset != nil {
		fields = append(fields, transaction.FieldQuoteAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case transaction.FieldDeletedAt:
		return m.DeletedAt()
	case transaction.FieldTime:
		return m.Time()
	case transaction.FieldUnits:
		return m.Units()
	case transaction.FieldPricePerUnit:
		return m.PricePerUnit()
	case transaction.FieldBlockchainID:
		return m.BlockchainID()
	case transaction.FieldTransactionTypeID:
		return m.TransactionTypeID()
	case transaction.FieldExchangeID:
		return m.ExchangeID()
	case transaction.FieldPortfolioID:
		return m.PortfolioID()
	case transaction.FieldBaseAssetID:
		return m.BaseAssetID()
	case transaction.FieldQuoteAssetID:
		return m.QuoteAssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transaction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transaction.FieldTime:
		return m.OldTime(ctx)
	case transaction.FieldUnits:
		return m.OldUnits(ctx)
	case transaction.FieldPricePerUnit:
		return m.OldPricePerUnit(ctx)
	case transaction.FieldBlockchainID:
		return m.OldBlockchainID(ctx)
	case transaction.FieldTransactionTypeID:
		return m.OldTransactionTypeID(ctx)
	case transaction.FieldExchangeID:
		return m.OldExchangeID(ctx)
	case transaction.FieldPortfolioID:
		return m.OldPortfolioID(ctx)
	case transaction.FieldBaseAssetID:
		return m.OldBaseAssetID(ctx)
	case transaction.FieldQuoteAssetID:
		return m.OldQuoteAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transaction.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transaction.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case transaction.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case transaction.FieldPricePerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerUnit(v)
		return nil
	case transaction.FieldBlockchainID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockchainID(v)
		return nil
	case transaction.FieldTransactionTypeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionTypeID(v)
		return nil
	case transaction.FieldExchangeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	case transaction.FieldPortfolioID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPortfolioID(v)
		return nil
	case transaction.FieldBaseAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseAssetID(v)
		return nil
	case transaction.FieldQuoteAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuoteAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addunits != nil {
		fields = append(fields, transaction.FieldUnits)
	}
	if m.addprice_per_unit != nil {
		fields = append(fields, transaction.FieldPricePerUnit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldUnits:
		return m.AddedUnits()
	case transaction.FieldPricePerUnit:
		return m.AddedPricePerUnit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	case transaction.FieldPricePerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldDeletedAt) {
		fields = append(fields, transaction.FieldDeletedAt)
	}
	if m.FieldCleared(transaction.FieldBlockchainID) {
		fields = append(fields, transaction.FieldBlockchainID)
	}
	if m.FieldCleared(transaction.FieldQuoteAssetID) {
		fields = append(fields, transaction.FieldQuoteAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case transaction.FieldBlockchainID:
		m.ClearBlockchainID()
		return nil
	case transaction.FieldQuoteAssetID:
		m.ClearQuoteAssetID()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transaction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transaction.FieldTime:
		m.ResetTime()
		return nil
	case transaction.FieldUnits:
		m.ResetUnits()
		return nil
	case transaction.FieldPricePerUnit:
		m.ResetPricePerUnit()
		return nil
	case transaction.FieldBlockchainID:
		m.ResetBlockchainID()
		return nil
	case transaction.FieldTransactionTypeID:
		m.ResetTransactionTypeID()
		return nil
	case transaction.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	case transaction.FieldPortfolioID:
		m.ResetPortfolioID()
		return nil
	case transaction.FieldBaseAssetID:
		m.ResetBaseAssetID()
		return nil
	case transaction.FieldQuoteAssetID:
		m.ResetQuoteAssetID()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.transaction_type != nil {
		edges = append(edges, transaction.EdgeTransactionType)
	}
	if m.base_asset != nil {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.quote_asset != nil {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	if m.portfolio != nil {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.exchange != nil {
		edges = append(edges, transaction.EdgeExchange)
	}
	if m.blockchain != nil {
		edges = append(edges, transaction.EdgeBlockchain)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionType:
		if id := m.transaction_type; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeBaseAsset:
		if id := m.base_asset; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeQuoteAsset:
		if id := m.quote_asset; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgePortfolio:
		if id := m.portfolio; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeBlockchain:
		if id := m.blockchain; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtransaction_type {
		edges = append(edges, transaction.EdgeTransactionType)
	}
	if m.clearedbase_asset {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.clearedquote_asset {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	if m.clearedportfolio {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.clearedexchange {
		edges = append(edges, transaction.EdgeExchange)
	}
	if m.clearedblockchain {
		edges = append(edges, transaction.EdgeBlockchain)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeTransactionType:
		return m.clearedtransaction_type
	case transaction.EdgeBaseAsset:
		return m.clearedbase_asset
	case transaction.EdgeQuoteAsset:
		return m.clearedquote_asset
	case transaction.EdgePortfolio:
		return m.clearedportfolio
	case transaction.EdgeExchange:
		return m.clearedexchange
	case transaction.EdgeBlockchain:
		return m.clearedblockchain
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeTransactionType:
		m.ClearTransactionType()
		return nil
	case transaction.EdgeBaseAsset:
		m.ClearBaseAsset()
		return nil
	case transaction.EdgeQuoteAsset:
		m.ClearQuoteAsset()
		return nil
	case transaction.EdgePortfolio:
		m.ClearPortfolio()
		return nil
	case transaction.EdgeExchange:
		m.ClearExchange()
		return nil
	case transaction.EdgeBlockchain:
		m.ClearBlockchain()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeTransactionType:
		m.ResetTransactionType()
		return nil
	case transaction.EdgeBaseAsset:
		m.ResetBaseAsset()
		return nil
	case transaction.EdgeQuoteAsset:
		m.ResetQuoteAsset()
		return nil
	case transaction.EdgePortfolio:
		m.ResetPortfolio()
		return nil
	case transaction.EdgeExchange:
		m.ResetExchange()
		return nil
	case transaction.EdgeBlockchain:
		m.ResetBlockchain()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionTypeMutation represents an operation that mutates the TransactionType nodes in the graph.
type TransactionTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	value               *transactiontype.Value
	description         *string
	clearedFields       map[string]struct{}
	transactions        map[pulid.PULID]struct{}
	removedtransactions map[pulid.PULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*TransactionType, error)
	predicates          []predicate.TransactionType
}

var _ ent.Mutation = (*TransactionTypeMutation)(nil)

// transactiontypeOption allows management of the mutation configuration using functional options.
type transactiontypeOption func(*TransactionTypeMutation)

// newTransactionTypeMutation creates new mutation for the TransactionType entity.
func newTransactionTypeMutation(c config, op Op, opts ...transactiontypeOption) *TransactionTypeMutation {
	m := &TransactionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionTypeID sets the ID field of the mutation.
func withTransactionTypeID(id pulid.PULID) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionType
		)
		m.oldValue = func(ctx context.Context) (*TransactionType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionType sets the old TransactionType of the mutation.
func withTransactionType(node *TransactionType) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		m.oldValue = func(context.Context) (*TransactionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransactionType entities.
func (m *TransactionTypeMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionTypeMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionTypeMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransactionTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransactionTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransactionTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transactiontype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransactionTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transactiontype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransactionTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transactiontype.FieldDeletedAt)
}

// SetValue sets the "value" field.
func (m *TransactionTypeMutation) SetValue(t transactiontype.Value) {
	m.value = &t
}

// Value returns the value of the "value" field in the mutation.
func (m *TransactionTypeMutation) Value() (r transactiontype.Value, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldValue(ctx context.Context) (v transactiontype.Value, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *TransactionTypeMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *TransactionTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transactiontype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transactiontype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transactiontype.FieldDescription)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *TransactionTypeMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *TransactionTypeMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *TransactionTypeMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *TransactionTypeMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *TransactionTypeMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *TransactionTypeMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *TransactionTypeMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the TransactionTypeMutation builder.
func (m *TransactionTypeMutation) Where(ps ...predicate.TransactionType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransactionType).
func (m *TransactionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, transactiontype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transactiontype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transactiontype.FieldDeletedAt)
	}
	if m.value != nil {
		fields = append(fields, transactiontype.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, transactiontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.CreatedAt()
	case transactiontype.FieldUpdatedAt:
		return m.UpdatedAt()
	case transactiontype.FieldDeletedAt:
		return m.DeletedAt()
	case transactiontype.FieldValue:
		return m.Value()
	case transactiontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transactiontype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transactiontype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transactiontype.FieldValue:
		return m.OldValue(ctx)
	case transactiontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transactiontype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transactiontype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transactiontype.FieldValue:
		v, ok := value.(transactiontype.Value)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case transactiontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactiontype.FieldDeletedAt) {
		fields = append(fields, transactiontype.FieldDeletedAt)
	}
	if m.FieldCleared(transactiontype.FieldDescription) {
		fields = append(fields, transactiontype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ClearField(name string) error {
	switch name {
	case transactiontype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case transactiontype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TransactionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ResetField(name string) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transactiontype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transactiontype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transactiontype.FieldValue:
		m.ResetValue()
		return nil
	case transactiontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactiontype.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transactiontype.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case transactiontype.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionTypeMutation) ResetEdge(name string) error {
	switch name {
	case transactiontype.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown TransactionType edge %s", name)
}
