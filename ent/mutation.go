// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/accountauthrole"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/blockchaincryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/predicate"
	"github.com/chenningg/hermitboard-api/ent/schema/pulid"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount                  = "Account"
	TypeAccountAuthRole          = "AccountAuthRole"
	TypeAsset                    = "Asset"
	TypeAssetClass               = "AssetClass"
	TypeAuthRole                 = "AuthRole"
	TypeBlockchain               = "Blockchain"
	TypeBlockchainCryptocurrency = "BlockchainCryptocurrency"
	TypeCryptocurrency           = "Cryptocurrency"
	TypeDailyAssetPrice          = "DailyAssetPrice"
	TypeExchange                 = "Exchange"
	TypePortfolio                = "Portfolio"
	TypeTransaction              = "Transaction"
	TypeTransactionType          = "TransactionType"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                        Op
	typ                       string
	id                        *pulid.PULID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	auth_type                 *account.AuthType
	nickname                  *string
	email                     *string
	password                  *string
	password_updated_at       *time.Time
	clearedFields             map[string]struct{}
	auth_roles                map[pulid.PULID]struct{}
	removedauth_roles         map[pulid.PULID]struct{}
	clearedauth_roles         bool
	portfolios                map[pulid.PULID]struct{}
	removedportfolios         map[pulid.PULID]struct{}
	clearedportfolios         bool
	account_auth_roles        map[pulid.PULID]struct{}
	removedaccount_auth_roles map[pulid.PULID]struct{}
	clearedaccount_auth_roles bool
	done                      bool
	oldValue                  func(context.Context) (*Account, error)
	predicates                []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id pulid.PULID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetAuthType sets the "auth_type" field.
func (m *AccountMutation) SetAuthType(at account.AuthType) {
	m.auth_type = &at
}

// AuthType returns the value of the "auth_type" field in the mutation.
func (m *AccountMutation) AuthType() (r account.AuthType, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old "auth_type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAuthType(ctx context.Context) (v account.AuthType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType resets all changes to the "auth_type" field.
func (m *AccountMutation) ResetAuthType() {
	m.auth_type = nil
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *AccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[account.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *AccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[account.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, account.FieldPassword)
}

// SetPasswordUpdatedAt sets the "password_updated_at" field.
func (m *AccountMutation) SetPasswordUpdatedAt(t time.Time) {
	m.password_updated_at = &t
}

// PasswordUpdatedAt returns the value of the "password_updated_at" field in the mutation.
func (m *AccountMutation) PasswordUpdatedAt() (r time.Time, exists bool) {
	v := m.password_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordUpdatedAt returns the old "password_updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordUpdatedAt: %w", err)
	}
	return oldValue.PasswordUpdatedAt, nil
}

// ResetPasswordUpdatedAt resets all changes to the "password_updated_at" field.
func (m *AccountMutation) ResetPasswordUpdatedAt() {
	m.password_updated_at = nil
}

// AddAuthRoleIDs adds the "auth_roles" edge to the AuthRole entity by ids.
func (m *AccountMutation) AddAuthRoleIDs(ids ...pulid.PULID) {
	if m.auth_roles == nil {
		m.auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.auth_roles[ids[i]] = struct{}{}
	}
}

// ClearAuthRoles clears the "auth_roles" edge to the AuthRole entity.
func (m *AccountMutation) ClearAuthRoles() {
	m.clearedauth_roles = true
}

// AuthRolesCleared reports if the "auth_roles" edge to the AuthRole entity was cleared.
func (m *AccountMutation) AuthRolesCleared() bool {
	return m.clearedauth_roles
}

// RemoveAuthRoleIDs removes the "auth_roles" edge to the AuthRole entity by IDs.
func (m *AccountMutation) RemoveAuthRoleIDs(ids ...pulid.PULID) {
	if m.removedauth_roles == nil {
		m.removedauth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.auth_roles, ids[i])
		m.removedauth_roles[ids[i]] = struct{}{}
	}
}

// RemovedAuthRoles returns the removed IDs of the "auth_roles" edge to the AuthRole entity.
func (m *AccountMutation) RemovedAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.removedauth_roles {
		ids = append(ids, id)
	}
	return
}

// AuthRolesIDs returns the "auth_roles" edge IDs in the mutation.
func (m *AccountMutation) AuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.auth_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAuthRoles resets all changes to the "auth_roles" edge.
func (m *AccountMutation) ResetAuthRoles() {
	m.auth_roles = nil
	m.clearedauth_roles = false
	m.removedauth_roles = nil
}

// AddPortfolioIDs adds the "portfolios" edge to the Portfolio entity by ids.
func (m *AccountMutation) AddPortfolioIDs(ids ...pulid.PULID) {
	if m.portfolios == nil {
		m.portfolios = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.portfolios[ids[i]] = struct{}{}
	}
}

// ClearPortfolios clears the "portfolios" edge to the Portfolio entity.
func (m *AccountMutation) ClearPortfolios() {
	m.clearedportfolios = true
}

// PortfoliosCleared reports if the "portfolios" edge to the Portfolio entity was cleared.
func (m *AccountMutation) PortfoliosCleared() bool {
	return m.clearedportfolios
}

// RemovePortfolioIDs removes the "portfolios" edge to the Portfolio entity by IDs.
func (m *AccountMutation) RemovePortfolioIDs(ids ...pulid.PULID) {
	if m.removedportfolios == nil {
		m.removedportfolios = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.portfolios, ids[i])
		m.removedportfolios[ids[i]] = struct{}{}
	}
}

// RemovedPortfolios returns the removed IDs of the "portfolios" edge to the Portfolio entity.
func (m *AccountMutation) RemovedPortfoliosIDs() (ids []pulid.PULID) {
	for id := range m.removedportfolios {
		ids = append(ids, id)
	}
	return
}

// PortfoliosIDs returns the "portfolios" edge IDs in the mutation.
func (m *AccountMutation) PortfoliosIDs() (ids []pulid.PULID) {
	for id := range m.portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolios resets all changes to the "portfolios" edge.
func (m *AccountMutation) ResetPortfolios() {
	m.portfolios = nil
	m.clearedportfolios = false
	m.removedportfolios = nil
}

// AddAccountAuthRoleIDs adds the "account_auth_roles" edge to the AccountAuthRole entity by ids.
func (m *AccountMutation) AddAccountAuthRoleIDs(ids ...pulid.PULID) {
	if m.account_auth_roles == nil {
		m.account_auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.account_auth_roles[ids[i]] = struct{}{}
	}
}

// ClearAccountAuthRoles clears the "account_auth_roles" edge to the AccountAuthRole entity.
func (m *AccountMutation) ClearAccountAuthRoles() {
	m.clearedaccount_auth_roles = true
}

// AccountAuthRolesCleared reports if the "account_auth_roles" edge to the AccountAuthRole entity was cleared.
func (m *AccountMutation) AccountAuthRolesCleared() bool {
	return m.clearedaccount_auth_roles
}

// RemoveAccountAuthRoleIDs removes the "account_auth_roles" edge to the AccountAuthRole entity by IDs.
func (m *AccountMutation) RemoveAccountAuthRoleIDs(ids ...pulid.PULID) {
	if m.removedaccount_auth_roles == nil {
		m.removedaccount_auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.account_auth_roles, ids[i])
		m.removedaccount_auth_roles[ids[i]] = struct{}{}
	}
}

// RemovedAccountAuthRoles returns the removed IDs of the "account_auth_roles" edge to the AccountAuthRole entity.
func (m *AccountMutation) RemovedAccountAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.removedaccount_auth_roles {
		ids = append(ids, id)
	}
	return
}

// AccountAuthRolesIDs returns the "account_auth_roles" edge IDs in the mutation.
func (m *AccountMutation) AccountAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.account_auth_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAccountAuthRoles resets all changes to the "account_auth_roles" edge.
func (m *AccountMutation) ResetAccountAuthRoles() {
	m.account_auth_roles = nil
	m.clearedaccount_auth_roles = false
	m.removedaccount_auth_roles = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.auth_type != nil {
		fields = append(fields, account.FieldAuthType)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.password_updated_at != nil {
		fields = append(fields, account.FieldPasswordUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldAuthType:
		return m.AuthType()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldEmail:
		return m.Email()
	case account.FieldPassword:
		return m.Password()
	case account.FieldPasswordUpdatedAt:
		return m.PasswordUpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldAuthType:
		return m.OldAuthType(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldPasswordUpdatedAt:
		return m.OldPasswordUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldAuthType:
		v, ok := value.(account.AuthType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldPasswordUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldPassword) {
		fields = append(fields, account.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldAuthType:
		m.ResetAuthType()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldPasswordUpdatedAt:
		m.ResetPasswordUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.auth_roles != nil {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.portfolios != nil {
		edges = append(edges, account.EdgePortfolios)
	}
	if m.account_auth_roles != nil {
		edges = append(edges, account.EdgeAccountAuthRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.auth_roles))
		for id := range m.auth_roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.portfolios))
		for id := range m.portfolios {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountAuthRoles:
		ids := make([]ent.Value, 0, len(m.account_auth_roles))
		for id := range m.account_auth_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedauth_roles != nil {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.removedportfolios != nil {
		edges = append(edges, account.EdgePortfolios)
	}
	if m.removedaccount_auth_roles != nil {
		edges = append(edges, account.EdgeAccountAuthRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.removedauth_roles))
		for id := range m.removedauth_roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.removedportfolios))
		for id := range m.removedportfolios {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountAuthRoles:
		ids := make([]ent.Value, 0, len(m.removedaccount_auth_roles))
		for id := range m.removedaccount_auth_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauth_roles {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.clearedportfolios {
		edges = append(edges, account.EdgePortfolios)
	}
	if m.clearedaccount_auth_roles {
		edges = append(edges, account.EdgeAccountAuthRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeAuthRoles:
		return m.clearedauth_roles
	case account.EdgePortfolios:
		return m.clearedportfolios
	case account.EdgeAccountAuthRoles:
		return m.clearedaccount_auth_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeAuthRoles:
		m.ResetAuthRoles()
		return nil
	case account.EdgePortfolios:
		m.ResetPortfolios()
		return nil
	case account.EdgeAccountAuthRoles:
		m.ResetAccountAuthRoles()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountAuthRoleMutation represents an operation that mutates the AccountAuthRole nodes in the graph.
type AccountAuthRoleMutation struct {
	config
	op               Op
	typ              string
	id               *pulid.PULID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	account          *pulid.PULID
	clearedaccount   bool
	auth_role        *pulid.PULID
	clearedauth_role bool
	done             bool
	oldValue         func(context.Context) (*AccountAuthRole, error)
	predicates       []predicate.AccountAuthRole
}

var _ ent.Mutation = (*AccountAuthRoleMutation)(nil)

// accountauthroleOption allows management of the mutation configuration using functional options.
type accountauthroleOption func(*AccountAuthRoleMutation)

// newAccountAuthRoleMutation creates new mutation for the AccountAuthRole entity.
func newAccountAuthRoleMutation(c config, op Op, opts ...accountauthroleOption) *AccountAuthRoleMutation {
	m := &AccountAuthRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountAuthRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountAuthRoleID sets the ID field of the mutation.
func withAccountAuthRoleID(id pulid.PULID) accountauthroleOption {
	return func(m *AccountAuthRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountAuthRole
		)
		m.oldValue = func(ctx context.Context) (*AccountAuthRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountAuthRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountAuthRole sets the old AccountAuthRole of the mutation.
func withAccountAuthRole(node *AccountAuthRole) accountauthroleOption {
	return func(m *AccountAuthRoleMutation) {
		m.oldValue = func(context.Context) (*AccountAuthRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountAuthRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountAuthRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountAuthRole entities.
func (m *AccountAuthRoleMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountAuthRoleMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountAuthRoleMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountAuthRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountAuthRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountAuthRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountAuthRole entity.
// If the AccountAuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountAuthRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountAuthRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountAuthRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountAuthRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountAuthRole entity.
// If the AccountAuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountAuthRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountAuthRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountAuthRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountAuthRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AccountAuthRole entity.
// If the AccountAuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountAuthRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountAuthRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[accountauthrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountAuthRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[accountauthrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountAuthRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, accountauthrole.FieldDeletedAt)
}

// SetAccountID sets the "account_id" field.
func (m *AccountAuthRoleMutation) SetAccountID(pu pulid.PULID) {
	m.account = &pu
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountAuthRoleMutation) AccountID() (r pulid.PULID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountAuthRole entity.
// If the AccountAuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountAuthRoleMutation) OldAccountID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountAuthRoleMutation) ResetAccountID() {
	m.account = nil
}

// SetAuthRoleID sets the "auth_role_id" field.
func (m *AccountAuthRoleMutation) SetAuthRoleID(pu pulid.PULID) {
	m.auth_role = &pu
}

// AuthRoleID returns the value of the "auth_role_id" field in the mutation.
func (m *AccountAuthRoleMutation) AuthRoleID() (r pulid.PULID, exists bool) {
	v := m.auth_role
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthRoleID returns the old "auth_role_id" field's value of the AccountAuthRole entity.
// If the AccountAuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountAuthRoleMutation) OldAuthRoleID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthRoleID: %w", err)
	}
	return oldValue.AuthRoleID, nil
}

// ResetAuthRoleID resets all changes to the "auth_role_id" field.
func (m *AccountAuthRoleMutation) ResetAuthRoleID() {
	m.auth_role = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountAuthRoleMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountAuthRoleMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountAuthRoleMutation) AccountIDs() (ids []pulid.PULID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountAuthRoleMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearAuthRole clears the "auth_role" edge to the AuthRole entity.
func (m *AccountAuthRoleMutation) ClearAuthRole() {
	m.clearedauth_role = true
}

// AuthRoleCleared reports if the "auth_role" edge to the AuthRole entity was cleared.
func (m *AccountAuthRoleMutation) AuthRoleCleared() bool {
	return m.clearedauth_role
}

// AuthRoleIDs returns the "auth_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthRoleID instead. It exists only for internal usage by the builders.
func (m *AccountAuthRoleMutation) AuthRoleIDs() (ids []pulid.PULID) {
	if id := m.auth_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthRole resets all changes to the "auth_role" edge.
func (m *AccountAuthRoleMutation) ResetAuthRole() {
	m.auth_role = nil
	m.clearedauth_role = false
}

// Where appends a list predicates to the AccountAuthRoleMutation builder.
func (m *AccountAuthRoleMutation) Where(ps ...predicate.AccountAuthRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountAuthRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccountAuthRole).
func (m *AccountAuthRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountAuthRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, accountauthrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountauthrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, accountauthrole.FieldDeletedAt)
	}
	if m.account != nil {
		fields = append(fields, accountauthrole.FieldAccountID)
	}
	if m.auth_role != nil {
		fields = append(fields, accountauthrole.FieldAuthRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountAuthRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountauthrole.FieldCreatedAt:
		return m.CreatedAt()
	case accountauthrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountauthrole.FieldDeletedAt:
		return m.DeletedAt()
	case accountauthrole.FieldAccountID:
		return m.AccountID()
	case accountauthrole.FieldAuthRoleID:
		return m.AuthRoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountAuthRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountauthrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountauthrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountauthrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accountauthrole.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountauthrole.FieldAuthRoleID:
		return m.OldAuthRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown AccountAuthRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountAuthRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountauthrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountauthrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountauthrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accountauthrole.FieldAccountID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountauthrole.FieldAuthRoleID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountAuthRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountAuthRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountAuthRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountAuthRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountAuthRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountAuthRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountauthrole.FieldDeletedAt) {
		fields = append(fields, accountauthrole.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountAuthRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountAuthRoleMutation) ClearField(name string) error {
	switch name {
	case accountauthrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountAuthRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountAuthRoleMutation) ResetField(name string) error {
	switch name {
	case accountauthrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountauthrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountauthrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accountauthrole.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountauthrole.FieldAuthRoleID:
		m.ResetAuthRoleID()
		return nil
	}
	return fmt.Errorf("unknown AccountAuthRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountAuthRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, accountauthrole.EdgeAccount)
	}
	if m.auth_role != nil {
		edges = append(edges, accountauthrole.EdgeAuthRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountAuthRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountauthrole.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case accountauthrole.EdgeAuthRole:
		if id := m.auth_role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountAuthRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountAuthRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountAuthRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, accountauthrole.EdgeAccount)
	}
	if m.clearedauth_role {
		edges = append(edges, accountauthrole.EdgeAuthRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountAuthRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case accountauthrole.EdgeAccount:
		return m.clearedaccount
	case accountauthrole.EdgeAuthRole:
		return m.clearedauth_role
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountAuthRoleMutation) ClearEdge(name string) error {
	switch name {
	case accountauthrole.EdgeAccount:
		m.ClearAccount()
		return nil
	case accountauthrole.EdgeAuthRole:
		m.ClearAuthRole()
		return nil
	}
	return fmt.Errorf("unknown AccountAuthRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountAuthRoleMutation) ResetEdge(name string) error {
	switch name {
	case accountauthrole.EdgeAccount:
		m.ResetAccount()
		return nil
	case accountauthrole.EdgeAuthRole:
		m.ResetAuthRole()
		return nil
	}
	return fmt.Errorf("unknown AccountAuthRole edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                       Op
	typ                      string
	id                       *pulid.PULID
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	asset_class              *pulid.PULID
	clearedasset_class       bool
	cryptocurrency           *pulid.PULID
	clearedcryptocurrency    bool
	transaction_base         map[pulid.PULID]struct{}
	removedtransaction_base  map[pulid.PULID]struct{}
	clearedtransaction_base  bool
	transaction_quote        map[pulid.PULID]struct{}
	removedtransaction_quote map[pulid.PULID]struct{}
	clearedtransaction_quote bool
	daily_asset_price        map[pulid.PULID]struct{}
	removeddaily_asset_price map[pulid.PULID]struct{}
	cleareddaily_asset_price bool
	done                     bool
	oldValue                 func(context.Context) (*Asset, error)
	predicates               []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id pulid.PULID) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[asset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[asset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, asset.FieldDeletedAt)
}

// SetAssetClassID sets the "asset_class_id" field.
func (m *AssetMutation) SetAssetClassID(pu pulid.PULID) {
	m.asset_class = &pu
}

// AssetClassID returns the value of the "asset_class_id" field in the mutation.
func (m *AssetMutation) AssetClassID() (r pulid.PULID, exists bool) {
	v := m.asset_class
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetClassID returns the old "asset_class_id" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldAssetClassID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetClassID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetClassID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetClassID: %w", err)
	}
	return oldValue.AssetClassID, nil
}

// ResetAssetClassID resets all changes to the "asset_class_id" field.
func (m *AssetMutation) ResetAssetClassID() {
	m.asset_class = nil
}

// ClearAssetClass clears the "asset_class" edge to the AssetClass entity.
func (m *AssetMutation) ClearAssetClass() {
	m.clearedasset_class = true
}

// AssetClassCleared reports if the "asset_class" edge to the AssetClass entity was cleared.
func (m *AssetMutation) AssetClassCleared() bool {
	return m.clearedasset_class
}

// AssetClassIDs returns the "asset_class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetClassID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) AssetClassIDs() (ids []pulid.PULID) {
	if id := m.asset_class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssetClass resets all changes to the "asset_class" edge.
func (m *AssetMutation) ResetAssetClass() {
	m.asset_class = nil
	m.clearedasset_class = false
}

// SetCryptocurrencyID sets the "cryptocurrency" edge to the Cryptocurrency entity by id.
func (m *AssetMutation) SetCryptocurrencyID(id pulid.PULID) {
	m.cryptocurrency = &id
}

// ClearCryptocurrency clears the "cryptocurrency" edge to the Cryptocurrency entity.
func (m *AssetMutation) ClearCryptocurrency() {
	m.clearedcryptocurrency = true
}

// CryptocurrencyCleared reports if the "cryptocurrency" edge to the Cryptocurrency entity was cleared.
func (m *AssetMutation) CryptocurrencyCleared() bool {
	return m.clearedcryptocurrency
}

// CryptocurrencyID returns the "cryptocurrency" edge ID in the mutation.
func (m *AssetMutation) CryptocurrencyID() (id pulid.PULID, exists bool) {
	if m.cryptocurrency != nil {
		return *m.cryptocurrency, true
	}
	return
}

// CryptocurrencyIDs returns the "cryptocurrency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CryptocurrencyID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) CryptocurrencyIDs() (ids []pulid.PULID) {
	if id := m.cryptocurrency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCryptocurrency resets all changes to the "cryptocurrency" edge.
func (m *AssetMutation) ResetCryptocurrency() {
	m.cryptocurrency = nil
	m.clearedcryptocurrency = false
}

// AddTransactionBaseIDs adds the "transaction_base" edge to the Transaction entity by ids.
func (m *AssetMutation) AddTransactionBaseIDs(ids ...pulid.PULID) {
	if m.transaction_base == nil {
		m.transaction_base = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transaction_base[ids[i]] = struct{}{}
	}
}

// ClearTransactionBase clears the "transaction_base" edge to the Transaction entity.
func (m *AssetMutation) ClearTransactionBase() {
	m.clearedtransaction_base = true
}

// TransactionBaseCleared reports if the "transaction_base" edge to the Transaction entity was cleared.
func (m *AssetMutation) TransactionBaseCleared() bool {
	return m.clearedtransaction_base
}

// RemoveTransactionBaseIDs removes the "transaction_base" edge to the Transaction entity by IDs.
func (m *AssetMutation) RemoveTransactionBaseIDs(ids ...pulid.PULID) {
	if m.removedtransaction_base == nil {
		m.removedtransaction_base = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transaction_base, ids[i])
		m.removedtransaction_base[ids[i]] = struct{}{}
	}
}

// RemovedTransactionBase returns the removed IDs of the "transaction_base" edge to the Transaction entity.
func (m *AssetMutation) RemovedTransactionBaseIDs() (ids []pulid.PULID) {
	for id := range m.removedtransaction_base {
		ids = append(ids, id)
	}
	return
}

// TransactionBaseIDs returns the "transaction_base" edge IDs in the mutation.
func (m *AssetMutation) TransactionBaseIDs() (ids []pulid.PULID) {
	for id := range m.transaction_base {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionBase resets all changes to the "transaction_base" edge.
func (m *AssetMutation) ResetTransactionBase() {
	m.transaction_base = nil
	m.clearedtransaction_base = false
	m.removedtransaction_base = nil
}

// AddTransactionQuoteIDs adds the "transaction_quote" edge to the Transaction entity by ids.
func (m *AssetMutation) AddTransactionQuoteIDs(ids ...pulid.PULID) {
	if m.transaction_quote == nil {
		m.transaction_quote = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transaction_quote[ids[i]] = struct{}{}
	}
}

// ClearTransactionQuote clears the "transaction_quote" edge to the Transaction entity.
func (m *AssetMutation) ClearTransactionQuote() {
	m.clearedtransaction_quote = true
}

// TransactionQuoteCleared reports if the "transaction_quote" edge to the Transaction entity was cleared.
func (m *AssetMutation) TransactionQuoteCleared() bool {
	return m.clearedtransaction_quote
}

// RemoveTransactionQuoteIDs removes the "transaction_quote" edge to the Transaction entity by IDs.
func (m *AssetMutation) RemoveTransactionQuoteIDs(ids ...pulid.PULID) {
	if m.removedtransaction_quote == nil {
		m.removedtransaction_quote = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transaction_quote, ids[i])
		m.removedtransaction_quote[ids[i]] = struct{}{}
	}
}

// RemovedTransactionQuote returns the removed IDs of the "transaction_quote" edge to the Transaction entity.
func (m *AssetMutation) RemovedTransactionQuoteIDs() (ids []pulid.PULID) {
	for id := range m.removedtransaction_quote {
		ids = append(ids, id)
	}
	return
}

// TransactionQuoteIDs returns the "transaction_quote" edge IDs in the mutation.
func (m *AssetMutation) TransactionQuoteIDs() (ids []pulid.PULID) {
	for id := range m.transaction_quote {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionQuote resets all changes to the "transaction_quote" edge.
func (m *AssetMutation) ResetTransactionQuote() {
	m.transaction_quote = nil
	m.clearedtransaction_quote = false
	m.removedtransaction_quote = nil
}

// AddDailyAssetPriceIDs adds the "daily_asset_price" edge to the DailyAssetPrice entity by ids.
func (m *AssetMutation) AddDailyAssetPriceIDs(ids ...pulid.PULID) {
	if m.daily_asset_price == nil {
		m.daily_asset_price = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.daily_asset_price[ids[i]] = struct{}{}
	}
}

// ClearDailyAssetPrice clears the "daily_asset_price" edge to the DailyAssetPrice entity.
func (m *AssetMutation) ClearDailyAssetPrice() {
	m.cleareddaily_asset_price = true
}

// DailyAssetPriceCleared reports if the "daily_asset_price" edge to the DailyAssetPrice entity was cleared.
func (m *AssetMutation) DailyAssetPriceCleared() bool {
	return m.cleareddaily_asset_price
}

// RemoveDailyAssetPriceIDs removes the "daily_asset_price" edge to the DailyAssetPrice entity by IDs.
func (m *AssetMutation) RemoveDailyAssetPriceIDs(ids ...pulid.PULID) {
	if m.removeddaily_asset_price == nil {
		m.removeddaily_asset_price = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.daily_asset_price, ids[i])
		m.removeddaily_asset_price[ids[i]] = struct{}{}
	}
}

// RemovedDailyAssetPrice returns the removed IDs of the "daily_asset_price" edge to the DailyAssetPrice entity.
func (m *AssetMutation) RemovedDailyAssetPriceIDs() (ids []pulid.PULID) {
	for id := range m.removeddaily_asset_price {
		ids = append(ids, id)
	}
	return
}

// DailyAssetPriceIDs returns the "daily_asset_price" edge IDs in the mutation.
func (m *AssetMutation) DailyAssetPriceIDs() (ids []pulid.PULID) {
	for id := range m.daily_asset_price {
		ids = append(ids, id)
	}
	return
}

// ResetDailyAssetPrice resets all changes to the "daily_asset_price" edge.
func (m *AssetMutation) ResetDailyAssetPrice() {
	m.daily_asset_price = nil
	m.cleareddaily_asset_price = false
	m.removeddaily_asset_price = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, asset.FieldDeletedAt)
	}
	if m.asset_class != nil {
		fields = append(fields, asset.FieldAssetClassID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	case asset.FieldDeletedAt:
		return m.DeletedAt()
	case asset.FieldAssetClassID:
		return m.AssetClassID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case asset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case asset.FieldAssetClassID:
		return m.OldAssetClassID(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case asset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case asset.FieldAssetClassID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetClassID(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldDeletedAt) {
		fields = append(fields, asset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case asset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case asset.FieldAssetClassID:
		m.ResetAssetClassID()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.asset_class != nil {
		edges = append(edges, asset.EdgeAssetClass)
	}
	if m.cryptocurrency != nil {
		edges = append(edges, asset.EdgeCryptocurrency)
	}
	if m.transaction_base != nil {
		edges = append(edges, asset.EdgeTransactionBase)
	}
	if m.transaction_quote != nil {
		edges = append(edges, asset.EdgeTransactionQuote)
	}
	if m.daily_asset_price != nil {
		edges = append(edges, asset.EdgeDailyAssetPrice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeAssetClass:
		if id := m.asset_class; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeCryptocurrency:
		if id := m.cryptocurrency; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeTransactionBase:
		ids := make([]ent.Value, 0, len(m.transaction_base))
		for id := range m.transaction_base {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTransactionQuote:
		ids := make([]ent.Value, 0, len(m.transaction_quote))
		for id := range m.transaction_quote {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDailyAssetPrice:
		ids := make([]ent.Value, 0, len(m.daily_asset_price))
		for id := range m.daily_asset_price {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtransaction_base != nil {
		edges = append(edges, asset.EdgeTransactionBase)
	}
	if m.removedtransaction_quote != nil {
		edges = append(edges, asset.EdgeTransactionQuote)
	}
	if m.removeddaily_asset_price != nil {
		edges = append(edges, asset.EdgeDailyAssetPrice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeTransactionBase:
		ids := make([]ent.Value, 0, len(m.removedtransaction_base))
		for id := range m.removedtransaction_base {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTransactionQuote:
		ids := make([]ent.Value, 0, len(m.removedtransaction_quote))
		for id := range m.removedtransaction_quote {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDailyAssetPrice:
		ids := make([]ent.Value, 0, len(m.removeddaily_asset_price))
		for id := range m.removeddaily_asset_price {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedasset_class {
		edges = append(edges, asset.EdgeAssetClass)
	}
	if m.clearedcryptocurrency {
		edges = append(edges, asset.EdgeCryptocurrency)
	}
	if m.clearedtransaction_base {
		edges = append(edges, asset.EdgeTransactionBase)
	}
	if m.clearedtransaction_quote {
		edges = append(edges, asset.EdgeTransactionQuote)
	}
	if m.cleareddaily_asset_price {
		edges = append(edges, asset.EdgeDailyAssetPrice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeAssetClass:
		return m.clearedasset_class
	case asset.EdgeCryptocurrency:
		return m.clearedcryptocurrency
	case asset.EdgeTransactionBase:
		return m.clearedtransaction_base
	case asset.EdgeTransactionQuote:
		return m.clearedtransaction_quote
	case asset.EdgeDailyAssetPrice:
		return m.cleareddaily_asset_price
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeAssetClass:
		m.ClearAssetClass()
		return nil
	case asset.EdgeCryptocurrency:
		m.ClearCryptocurrency()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeAssetClass:
		m.ResetAssetClass()
		return nil
	case asset.EdgeCryptocurrency:
		m.ResetCryptocurrency()
		return nil
	case asset.EdgeTransactionBase:
		m.ResetTransactionBase()
		return nil
	case asset.EdgeTransactionQuote:
		m.ResetTransactionQuote()
		return nil
	case asset.EdgeDailyAssetPrice:
		m.ResetDailyAssetPrice()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AssetClassMutation represents an operation that mutates the AssetClass nodes in the graph.
type AssetClassMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.PULID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	asset_class   *assetclass.AssetClass
	description   *string
	clearedFields map[string]struct{}
	assets        map[pulid.PULID]struct{}
	removedassets map[pulid.PULID]struct{}
	clearedassets bool
	done          bool
	oldValue      func(context.Context) (*AssetClass, error)
	predicates    []predicate.AssetClass
}

var _ ent.Mutation = (*AssetClassMutation)(nil)

// assetclassOption allows management of the mutation configuration using functional options.
type assetclassOption func(*AssetClassMutation)

// newAssetClassMutation creates new mutation for the AssetClass entity.
func newAssetClassMutation(c config, op Op, opts ...assetclassOption) *AssetClassMutation {
	m := &AssetClassMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetClassID sets the ID field of the mutation.
func withAssetClassID(id pulid.PULID) assetclassOption {
	return func(m *AssetClassMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetClass
		)
		m.oldValue = func(ctx context.Context) (*AssetClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetClass sets the old AssetClass of the mutation.
func withAssetClass(node *AssetClass) assetclassOption {
	return func(m *AssetClassMutation) {
		m.oldValue = func(context.Context) (*AssetClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetClass entities.
func (m *AssetClassMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetClassMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetClassMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssetClassMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssetClassMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssetClassMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assetclass.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssetClassMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assetclass.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssetClassMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assetclass.FieldDeletedAt)
}

// SetAssetClass sets the "asset_class" field.
func (m *AssetClassMutation) SetAssetClass(ac assetclass.AssetClass) {
	m.asset_class = &ac
}

// AssetClass returns the value of the "asset_class" field in the mutation.
func (m *AssetClassMutation) AssetClass() (r assetclass.AssetClass, exists bool) {
	v := m.asset_class
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetClass returns the old "asset_class" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldAssetClass(ctx context.Context) (v assetclass.AssetClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetClass: %w", err)
	}
	return oldValue.AssetClass, nil
}

// ResetAssetClass resets all changes to the "asset_class" field.
func (m *AssetClassMutation) ResetAssetClass() {
	m.asset_class = nil
}

// SetDescription sets the "description" field.
func (m *AssetClassMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssetClassMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssetClassMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assetclass.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssetClassMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assetclass.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssetClassMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assetclass.FieldDescription)
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetClassMutation) AddAssetIDs(ids ...pulid.PULID) {
	if m.assets == nil {
		m.assets = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetClassMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetClassMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetClassMutation) RemoveAssetIDs(ids ...pulid.PULID) {
	if m.removedassets == nil {
		m.removedassets = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetClassMutation) RemovedAssetsIDs() (ids []pulid.PULID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetClassMutation) AssetsIDs() (ids []pulid.PULID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetClassMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the AssetClassMutation builder.
func (m *AssetClassMutation) Where(ps ...predicate.AssetClass) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AssetClass).
func (m *AssetClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetClassMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, assetclass.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assetclass.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, assetclass.FieldDeletedAt)
	}
	if m.asset_class != nil {
		fields = append(fields, assetclass.FieldAssetClass)
	}
	if m.description != nil {
		fields = append(fields, assetclass.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetclass.FieldCreatedAt:
		return m.CreatedAt()
	case assetclass.FieldUpdatedAt:
		return m.UpdatedAt()
	case assetclass.FieldDeletedAt:
		return m.DeletedAt()
	case assetclass.FieldAssetClass:
		return m.AssetClass()
	case assetclass.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetclass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assetclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assetclass.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assetclass.FieldAssetClass:
		return m.OldAssetClass(ctx)
	case assetclass.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AssetClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetclass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assetclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assetclass.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assetclass.FieldAssetClass:
		v, ok := value.(assetclass.AssetClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetClass(v)
		return nil
	case assetclass.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AssetClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assetclass.FieldDeletedAt) {
		fields = append(fields, assetclass.FieldDeletedAt)
	}
	if m.FieldCleared(assetclass.FieldDescription) {
		fields = append(fields, assetclass.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetClassMutation) ClearField(name string) error {
	switch name {
	case assetclass.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assetclass.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetClassMutation) ResetField(name string) error {
	switch name {
	case assetclass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assetclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assetclass.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assetclass.FieldAssetClass:
		m.ResetAssetClass()
		return nil
	case assetclass.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assets != nil {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetclass.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedassets != nil {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assetclass.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassets {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetClassMutation) EdgeCleared(name string) bool {
	switch name {
	case assetclass.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetClassMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetClassMutation) ResetEdge(name string) error {
	switch name {
	case assetclass.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown AssetClass edge %s", name)
}

// AuthRoleMutation represents an operation that mutates the AuthRole nodes in the graph.
type AuthRoleMutation struct {
	config
	op                        Op
	typ                       string
	id                        *pulid.PULID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	auth_role                 *authrole.AuthRole
	description               *string
	clearedFields             map[string]struct{}
	accounts                  map[pulid.PULID]struct{}
	removedaccounts           map[pulid.PULID]struct{}
	clearedaccounts           bool
	account_auth_roles        map[pulid.PULID]struct{}
	removedaccount_auth_roles map[pulid.PULID]struct{}
	clearedaccount_auth_roles bool
	done                      bool
	oldValue                  func(context.Context) (*AuthRole, error)
	predicates                []predicate.AuthRole
}

var _ ent.Mutation = (*AuthRoleMutation)(nil)

// authroleOption allows management of the mutation configuration using functional options.
type authroleOption func(*AuthRoleMutation)

// newAuthRoleMutation creates new mutation for the AuthRole entity.
func newAuthRoleMutation(c config, op Op, opts ...authroleOption) *AuthRoleMutation {
	m := &AuthRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRoleID sets the ID field of the mutation.
func withAuthRoleID(id pulid.PULID) authroleOption {
	return func(m *AuthRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRole
		)
		m.oldValue = func(ctx context.Context) (*AuthRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRole sets the old AuthRole of the mutation.
func withAuthRole(node *AuthRole) authroleOption {
	return func(m *AuthRoleMutation) {
		m.oldValue = func(context.Context) (*AuthRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthRole entities.
func (m *AuthRoleMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRoleMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRoleMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[authrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[authrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, authrole.FieldDeletedAt)
}

// SetAuthRole sets the "auth_role" field.
func (m *AuthRoleMutation) SetAuthRole(ar authrole.AuthRole) {
	m.auth_role = &ar
}

// AuthRole returns the value of the "auth_role" field in the mutation.
func (m *AuthRoleMutation) AuthRole() (r authrole.AuthRole, exists bool) {
	v := m.auth_role
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthRole returns the old "auth_role" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldAuthRole(ctx context.Context) (v authrole.AuthRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthRole: %w", err)
	}
	return oldValue.AuthRole, nil
}

// ResetAuthRole resets all changes to the "auth_role" field.
func (m *AuthRoleMutation) ResetAuthRole() {
	m.auth_role = nil
}

// SetDescription sets the "description" field.
func (m *AuthRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuthRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuthRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[authrole.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuthRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[authrole.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuthRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, authrole.FieldDescription)
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *AuthRoleMutation) AddAccountIDs(ids ...pulid.PULID) {
	if m.accounts == nil {
		m.accounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *AuthRoleMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *AuthRoleMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *AuthRoleMutation) RemoveAccountIDs(ids ...pulid.PULID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *AuthRoleMutation) RemovedAccountsIDs() (ids []pulid.PULID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *AuthRoleMutation) AccountsIDs() (ids []pulid.PULID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AuthRoleMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAccountAuthRoleIDs adds the "account_auth_roles" edge to the AccountAuthRole entity by ids.
func (m *AuthRoleMutation) AddAccountAuthRoleIDs(ids ...pulid.PULID) {
	if m.account_auth_roles == nil {
		m.account_auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.account_auth_roles[ids[i]] = struct{}{}
	}
}

// ClearAccountAuthRoles clears the "account_auth_roles" edge to the AccountAuthRole entity.
func (m *AuthRoleMutation) ClearAccountAuthRoles() {
	m.clearedaccount_auth_roles = true
}

// AccountAuthRolesCleared reports if the "account_auth_roles" edge to the AccountAuthRole entity was cleared.
func (m *AuthRoleMutation) AccountAuthRolesCleared() bool {
	return m.clearedaccount_auth_roles
}

// RemoveAccountAuthRoleIDs removes the "account_auth_roles" edge to the AccountAuthRole entity by IDs.
func (m *AuthRoleMutation) RemoveAccountAuthRoleIDs(ids ...pulid.PULID) {
	if m.removedaccount_auth_roles == nil {
		m.removedaccount_auth_roles = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.account_auth_roles, ids[i])
		m.removedaccount_auth_roles[ids[i]] = struct{}{}
	}
}

// RemovedAccountAuthRoles returns the removed IDs of the "account_auth_roles" edge to the AccountAuthRole entity.
func (m *AuthRoleMutation) RemovedAccountAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.removedaccount_auth_roles {
		ids = append(ids, id)
	}
	return
}

// AccountAuthRolesIDs returns the "account_auth_roles" edge IDs in the mutation.
func (m *AuthRoleMutation) AccountAuthRolesIDs() (ids []pulid.PULID) {
	for id := range m.account_auth_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAccountAuthRoles resets all changes to the "account_auth_roles" edge.
func (m *AuthRoleMutation) ResetAccountAuthRoles() {
	m.account_auth_roles = nil
	m.clearedaccount_auth_roles = false
	m.removedaccount_auth_roles = nil
}

// Where appends a list predicates to the AuthRoleMutation builder.
func (m *AuthRoleMutation) Where(ps ...predicate.AuthRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRole).
func (m *AuthRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, authrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authrole.FieldDeletedAt)
	}
	if m.auth_role != nil {
		fields = append(fields, authrole.FieldAuthRole)
	}
	if m.description != nil {
		fields = append(fields, authrole.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrole.FieldCreatedAt:
		return m.CreatedAt()
	case authrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case authrole.FieldDeletedAt:
		return m.DeletedAt()
	case authrole.FieldAuthRole:
		return m.AuthRole()
	case authrole.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authrole.FieldAuthRole:
		return m.OldAuthRole(ctx)
	case authrole.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authrole.FieldAuthRole:
		v, ok := value.(authrole.AuthRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthRole(v)
		return nil
	case authrole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authrole.FieldDeletedAt) {
		fields = append(fields, authrole.FieldDeletedAt)
	}
	if m.FieldCleared(authrole.FieldDescription) {
		fields = append(fields, authrole.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRoleMutation) ClearField(name string) error {
	switch name {
	case authrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case authrole.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRoleMutation) ResetField(name string) error {
	switch name {
	case authrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authrole.FieldAuthRole:
		m.ResetAuthRole()
		return nil
	case authrole.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.accounts != nil {
		edges = append(edges, authrole.EdgeAccounts)
	}
	if m.account_auth_roles != nil {
		edges = append(edges, authrole.EdgeAccountAuthRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authrole.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case authrole.EdgeAccountAuthRoles:
		ids := make([]ent.Value, 0, len(m.account_auth_roles))
		for id := range m.account_auth_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedaccounts != nil {
		edges = append(edges, authrole.EdgeAccounts)
	}
	if m.removedaccount_auth_roles != nil {
		edges = append(edges, authrole.EdgeAccountAuthRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authrole.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case authrole.EdgeAccountAuthRoles:
		ids := make([]ent.Value, 0, len(m.removedaccount_auth_roles))
		for id := range m.removedaccount_auth_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccounts {
		edges = append(edges, authrole.EdgeAccounts)
	}
	if m.clearedaccount_auth_roles {
		edges = append(edges, authrole.EdgeAccountAuthRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case authrole.EdgeAccounts:
		return m.clearedaccounts
	case authrole.EdgeAccountAuthRoles:
		return m.clearedaccount_auth_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRoleMutation) ResetEdge(name string) error {
	switch name {
	case authrole.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case authrole.EdgeAccountAuthRoles:
		m.ResetAccountAuthRoles()
		return nil
	}
	return fmt.Errorf("unknown AuthRole edge %s", name)
}

// BlockchainMutation represents an operation that mutates the Blockchain nodes in the graph.
type BlockchainMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *pulid.PULID
	created_at                         *time.Time
	updated_at                         *time.Time
	deleted_at                         *time.Time
	name                               *string
	symbol                             *string
	icon                               *string
	chain_id                           *int64
	addchain_id                        *int64
	clearedFields                      map[string]struct{}
	cryptocurrencies                   map[pulid.PULID]struct{}
	removedcryptocurrencies            map[pulid.PULID]struct{}
	clearedcryptocurrencies            bool
	blockchain_cryptocurrencies        map[pulid.PULID]struct{}
	removedblockchain_cryptocurrencies map[pulid.PULID]struct{}
	clearedblockchain_cryptocurrencies bool
	done                               bool
	oldValue                           func(context.Context) (*Blockchain, error)
	predicates                         []predicate.Blockchain
}

var _ ent.Mutation = (*BlockchainMutation)(nil)

// blockchainOption allows management of the mutation configuration using functional options.
type blockchainOption func(*BlockchainMutation)

// newBlockchainMutation creates new mutation for the Blockchain entity.
func newBlockchainMutation(c config, op Op, opts ...blockchainOption) *BlockchainMutation {
	m := &BlockchainMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockchain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockchainID sets the ID field of the mutation.
func withBlockchainID(id pulid.PULID) blockchainOption {
	return func(m *BlockchainMutation) {
		var (
			err   error
			once  sync.Once
			value *Blockchain
		)
		m.oldValue = func(ctx context.Context) (*Blockchain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blockchain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockchain sets the old Blockchain of the mutation.
func withBlockchain(node *Blockchain) blockchainOption {
	return func(m *BlockchainMutation) {
		m.oldValue = func(context.Context) (*Blockchain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockchainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockchainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blockchain entities.
func (m *BlockchainMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockchainMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockchainMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blockchain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockchainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockchainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockchainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockchainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockchainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockchainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlockchainMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlockchainMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BlockchainMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[blockchain.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BlockchainMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlockchainMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, blockchain.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *BlockchainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlockchainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlockchainMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *BlockchainMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *BlockchainMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *BlockchainMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIcon sets the "icon" field.
func (m *BlockchainMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *BlockchainMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *BlockchainMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[blockchain.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *BlockchainMutation) IconCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *BlockchainMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, blockchain.FieldIcon)
}

// SetChainID sets the "chain_id" field.
func (m *BlockchainMutation) SetChainID(i int64) {
	m.chain_id = &i
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *BlockchainMutation) ChainID() (r int64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldChainID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds i to the "chain_id" field.
func (m *BlockchainMutation) AddChainID(i int64) {
	if m.addchain_id != nil {
		*m.addchain_id += i
	} else {
		m.addchain_id = &i
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *BlockchainMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearChainID clears the value of the "chain_id" field.
func (m *BlockchainMutation) ClearChainID() {
	m.chain_id = nil
	m.addchain_id = nil
	m.clearedFields[blockchain.FieldChainID] = struct{}{}
}

// ChainIDCleared returns if the "chain_id" field was cleared in this mutation.
func (m *BlockchainMutation) ChainIDCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldChainID]
	return ok
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *BlockchainMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
	delete(m.clearedFields, blockchain.FieldChainID)
}

// AddCryptocurrencyIDs adds the "cryptocurrencies" edge to the Cryptocurrency entity by ids.
func (m *BlockchainMutation) AddCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.cryptocurrencies == nil {
		m.cryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.cryptocurrencies[ids[i]] = struct{}{}
	}
}

// ClearCryptocurrencies clears the "cryptocurrencies" edge to the Cryptocurrency entity.
func (m *BlockchainMutation) ClearCryptocurrencies() {
	m.clearedcryptocurrencies = true
}

// CryptocurrenciesCleared reports if the "cryptocurrencies" edge to the Cryptocurrency entity was cleared.
func (m *BlockchainMutation) CryptocurrenciesCleared() bool {
	return m.clearedcryptocurrencies
}

// RemoveCryptocurrencyIDs removes the "cryptocurrencies" edge to the Cryptocurrency entity by IDs.
func (m *BlockchainMutation) RemoveCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.removedcryptocurrencies == nil {
		m.removedcryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.cryptocurrencies, ids[i])
		m.removedcryptocurrencies[ids[i]] = struct{}{}
	}
}

// RemovedCryptocurrencies returns the removed IDs of the "cryptocurrencies" edge to the Cryptocurrency entity.
func (m *BlockchainMutation) RemovedCryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.removedcryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// CryptocurrenciesIDs returns the "cryptocurrencies" edge IDs in the mutation.
func (m *BlockchainMutation) CryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// ResetCryptocurrencies resets all changes to the "cryptocurrencies" edge.
func (m *BlockchainMutation) ResetCryptocurrencies() {
	m.cryptocurrencies = nil
	m.clearedcryptocurrencies = false
	m.removedcryptocurrencies = nil
}

// AddBlockchainCryptocurrencyIDs adds the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity by ids.
func (m *BlockchainMutation) AddBlockchainCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.blockchain_cryptocurrencies == nil {
		m.blockchain_cryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.blockchain_cryptocurrencies[ids[i]] = struct{}{}
	}
}

// ClearBlockchainCryptocurrencies clears the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity.
func (m *BlockchainMutation) ClearBlockchainCryptocurrencies() {
	m.clearedblockchain_cryptocurrencies = true
}

// BlockchainCryptocurrenciesCleared reports if the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity was cleared.
func (m *BlockchainMutation) BlockchainCryptocurrenciesCleared() bool {
	return m.clearedblockchain_cryptocurrencies
}

// RemoveBlockchainCryptocurrencyIDs removes the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity by IDs.
func (m *BlockchainMutation) RemoveBlockchainCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.removedblockchain_cryptocurrencies == nil {
		m.removedblockchain_cryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.blockchain_cryptocurrencies, ids[i])
		m.removedblockchain_cryptocurrencies[ids[i]] = struct{}{}
	}
}

// RemovedBlockchainCryptocurrencies returns the removed IDs of the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity.
func (m *BlockchainMutation) RemovedBlockchainCryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.removedblockchain_cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// BlockchainCryptocurrenciesIDs returns the "blockchain_cryptocurrencies" edge IDs in the mutation.
func (m *BlockchainMutation) BlockchainCryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.blockchain_cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// ResetBlockchainCryptocurrencies resets all changes to the "blockchain_cryptocurrencies" edge.
func (m *BlockchainMutation) ResetBlockchainCryptocurrencies() {
	m.blockchain_cryptocurrencies = nil
	m.clearedblockchain_cryptocurrencies = false
	m.removedblockchain_cryptocurrencies = nil
}

// Where appends a list predicates to the BlockchainMutation builder.
func (m *BlockchainMutation) Where(ps ...predicate.Blockchain) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BlockchainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Blockchain).
func (m *BlockchainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockchainMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, blockchain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockchain.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, blockchain.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, blockchain.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, blockchain.FieldSymbol)
	}
	if m.icon != nil {
		fields = append(fields, blockchain.FieldIcon)
	}
	if m.chain_id != nil {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockchainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.CreatedAt()
	case blockchain.FieldUpdatedAt:
		return m.UpdatedAt()
	case blockchain.FieldDeletedAt:
		return m.DeletedAt()
	case blockchain.FieldName:
		return m.Name()
	case blockchain.FieldSymbol:
		return m.Symbol()
	case blockchain.FieldIcon:
		return m.Icon()
	case blockchain.FieldChainID:
		return m.ChainID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockchainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockchain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blockchain.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blockchain.FieldName:
		return m.OldName(ctx)
	case blockchain.FieldSymbol:
		return m.OldSymbol(ctx)
	case blockchain.FieldIcon:
		return m.OldIcon(ctx)
	case blockchain.FieldChainID:
		return m.OldChainID(ctx)
	}
	return nil, fmt.Errorf("unknown Blockchain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockchain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blockchain.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blockchain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blockchain.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case blockchain.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case blockchain.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockchainMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockchainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldChainID:
		return m.AddedChainID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockchainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockchain.FieldDeletedAt) {
		fields = append(fields, blockchain.FieldDeletedAt)
	}
	if m.FieldCleared(blockchain.FieldIcon) {
		fields = append(fields, blockchain.FieldIcon)
	}
	if m.FieldCleared(blockchain.FieldChainID) {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockchainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockchainMutation) ClearField(name string) error {
	switch name {
	case blockchain.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case blockchain.FieldIcon:
		m.ClearIcon()
		return nil
	case blockchain.FieldChainID:
		m.ClearChainID()
		return nil
	}
	return fmt.Errorf("unknown Blockchain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockchainMutation) ResetField(name string) error {
	switch name {
	case blockchain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockchain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blockchain.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blockchain.FieldName:
		m.ResetName()
		return nil
	case blockchain.FieldSymbol:
		m.ResetSymbol()
		return nil
	case blockchain.FieldIcon:
		m.ResetIcon()
		return nil
	case blockchain.FieldChainID:
		m.ResetChainID()
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockchainMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	if m.blockchain_cryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeBlockchainCryptocurrencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockchainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.cryptocurrencies))
		for id := range m.cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	case blockchain.EdgeBlockchainCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.blockchain_cryptocurrencies))
		for id := range m.blockchain_cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockchainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	if m.removedblockchain_cryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeBlockchainCryptocurrencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockchainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.removedcryptocurrencies))
		for id := range m.removedcryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	case blockchain.EdgeBlockchainCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.removedblockchain_cryptocurrencies))
		for id := range m.removedblockchain_cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockchainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcryptocurrencies {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	if m.clearedblockchain_cryptocurrencies {
		edges = append(edges, blockchain.EdgeBlockchainCryptocurrencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockchainMutation) EdgeCleared(name string) bool {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		return m.clearedcryptocurrencies
	case blockchain.EdgeBlockchainCryptocurrencies:
		return m.clearedblockchain_cryptocurrencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockchainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Blockchain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockchainMutation) ResetEdge(name string) error {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		m.ResetCryptocurrencies()
		return nil
	case blockchain.EdgeBlockchainCryptocurrencies:
		m.ResetBlockchainCryptocurrencies()
		return nil
	}
	return fmt.Errorf("unknown Blockchain edge %s", name)
}

// BlockchainCryptocurrencyMutation represents an operation that mutates the BlockchainCryptocurrency nodes in the graph.
type BlockchainCryptocurrencyMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.PULID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	blockchain            *pulid.PULID
	clearedblockchain     bool
	cryptocurrency        *pulid.PULID
	clearedcryptocurrency bool
	done                  bool
	oldValue              func(context.Context) (*BlockchainCryptocurrency, error)
	predicates            []predicate.BlockchainCryptocurrency
}

var _ ent.Mutation = (*BlockchainCryptocurrencyMutation)(nil)

// blockchaincryptocurrencyOption allows management of the mutation configuration using functional options.
type blockchaincryptocurrencyOption func(*BlockchainCryptocurrencyMutation)

// newBlockchainCryptocurrencyMutation creates new mutation for the BlockchainCryptocurrency entity.
func newBlockchainCryptocurrencyMutation(c config, op Op, opts ...blockchaincryptocurrencyOption) *BlockchainCryptocurrencyMutation {
	m := &BlockchainCryptocurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockchainCryptocurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockchainCryptocurrencyID sets the ID field of the mutation.
func withBlockchainCryptocurrencyID(id pulid.PULID) blockchaincryptocurrencyOption {
	return func(m *BlockchainCryptocurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockchainCryptocurrency
		)
		m.oldValue = func(ctx context.Context) (*BlockchainCryptocurrency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockchainCryptocurrency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockchainCryptocurrency sets the old BlockchainCryptocurrency of the mutation.
func withBlockchainCryptocurrency(node *BlockchainCryptocurrency) blockchaincryptocurrencyOption {
	return func(m *BlockchainCryptocurrencyMutation) {
		m.oldValue = func(context.Context) (*BlockchainCryptocurrency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockchainCryptocurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockchainCryptocurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlockchainCryptocurrency entities.
func (m *BlockchainCryptocurrencyMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockchainCryptocurrencyMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockchainCryptocurrencyMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockchainCryptocurrency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockchainCryptocurrencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockchainCryptocurrencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockchainCryptocurrency entity.
// If the BlockchainCryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainCryptocurrencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockchainCryptocurrencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockchainCryptocurrencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockchainCryptocurrencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockchainCryptocurrency entity.
// If the BlockchainCryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainCryptocurrencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockchainCryptocurrencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BlockchainCryptocurrencyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BlockchainCryptocurrencyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BlockchainCryptocurrency entity.
// If the BlockchainCryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainCryptocurrencyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BlockchainCryptocurrencyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[blockchaincryptocurrency.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BlockchainCryptocurrencyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[blockchaincryptocurrency.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BlockchainCryptocurrencyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, blockchaincryptocurrency.FieldDeletedAt)
}

// SetBlockchainID sets the "blockchain_id" field.
func (m *BlockchainCryptocurrencyMutation) SetBlockchainID(pu pulid.PULID) {
	m.blockchain = &pu
}

// BlockchainID returns the value of the "blockchain_id" field in the mutation.
func (m *BlockchainCryptocurrencyMutation) BlockchainID() (r pulid.PULID, exists bool) {
	v := m.blockchain
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockchainID returns the old "blockchain_id" field's value of the BlockchainCryptocurrency entity.
// If the BlockchainCryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainCryptocurrencyMutation) OldBlockchainID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockchainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockchainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockchainID: %w", err)
	}
	return oldValue.BlockchainID, nil
}

// ResetBlockchainID resets all changes to the "blockchain_id" field.
func (m *BlockchainCryptocurrencyMutation) ResetBlockchainID() {
	m.blockchain = nil
}

// SetCryptocurrencyID sets the "cryptocurrency_id" field.
func (m *BlockchainCryptocurrencyMutation) SetCryptocurrencyID(pu pulid.PULID) {
	m.cryptocurrency = &pu
}

// CryptocurrencyID returns the value of the "cryptocurrency_id" field in the mutation.
func (m *BlockchainCryptocurrencyMutation) CryptocurrencyID() (r pulid.PULID, exists bool) {
	v := m.cryptocurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldCryptocurrencyID returns the old "cryptocurrency_id" field's value of the BlockchainCryptocurrency entity.
// If the BlockchainCryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainCryptocurrencyMutation) OldCryptocurrencyID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCryptocurrencyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCryptocurrencyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCryptocurrencyID: %w", err)
	}
	return oldValue.CryptocurrencyID, nil
}

// ResetCryptocurrencyID resets all changes to the "cryptocurrency_id" field.
func (m *BlockchainCryptocurrencyMutation) ResetCryptocurrencyID() {
	m.cryptocurrency = nil
}

// ClearBlockchain clears the "blockchain" edge to the Blockchain entity.
func (m *BlockchainCryptocurrencyMutation) ClearBlockchain() {
	m.clearedblockchain = true
}

// BlockchainCleared reports if the "blockchain" edge to the Blockchain entity was cleared.
func (m *BlockchainCryptocurrencyMutation) BlockchainCleared() bool {
	return m.clearedblockchain
}

// BlockchainIDs returns the "blockchain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockchainID instead. It exists only for internal usage by the builders.
func (m *BlockchainCryptocurrencyMutation) BlockchainIDs() (ids []pulid.PULID) {
	if id := m.blockchain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockchain resets all changes to the "blockchain" edge.
func (m *BlockchainCryptocurrencyMutation) ResetBlockchain() {
	m.blockchain = nil
	m.clearedblockchain = false
}

// ClearCryptocurrency clears the "cryptocurrency" edge to the Cryptocurrency entity.
func (m *BlockchainCryptocurrencyMutation) ClearCryptocurrency() {
	m.clearedcryptocurrency = true
}

// CryptocurrencyCleared reports if the "cryptocurrency" edge to the Cryptocurrency entity was cleared.
func (m *BlockchainCryptocurrencyMutation) CryptocurrencyCleared() bool {
	return m.clearedcryptocurrency
}

// CryptocurrencyIDs returns the "cryptocurrency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CryptocurrencyID instead. It exists only for internal usage by the builders.
func (m *BlockchainCryptocurrencyMutation) CryptocurrencyIDs() (ids []pulid.PULID) {
	if id := m.cryptocurrency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCryptocurrency resets all changes to the "cryptocurrency" edge.
func (m *BlockchainCryptocurrencyMutation) ResetCryptocurrency() {
	m.cryptocurrency = nil
	m.clearedcryptocurrency = false
}

// Where appends a list predicates to the BlockchainCryptocurrencyMutation builder.
func (m *BlockchainCryptocurrencyMutation) Where(ps ...predicate.BlockchainCryptocurrency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BlockchainCryptocurrencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BlockchainCryptocurrency).
func (m *BlockchainCryptocurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockchainCryptocurrencyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, blockchaincryptocurrency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockchaincryptocurrency.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, blockchaincryptocurrency.FieldDeletedAt)
	}
	if m.blockchain != nil {
		fields = append(fields, blockchaincryptocurrency.FieldBlockchainID)
	}
	if m.cryptocurrency != nil {
		fields = append(fields, blockchaincryptocurrency.FieldCryptocurrencyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockchainCryptocurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockchaincryptocurrency.FieldCreatedAt:
		return m.CreatedAt()
	case blockchaincryptocurrency.FieldUpdatedAt:
		return m.UpdatedAt()
	case blockchaincryptocurrency.FieldDeletedAt:
		return m.DeletedAt()
	case blockchaincryptocurrency.FieldBlockchainID:
		return m.BlockchainID()
	case blockchaincryptocurrency.FieldCryptocurrencyID:
		return m.CryptocurrencyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockchainCryptocurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockchaincryptocurrency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockchaincryptocurrency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blockchaincryptocurrency.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case blockchaincryptocurrency.FieldBlockchainID:
		return m.OldBlockchainID(ctx)
	case blockchaincryptocurrency.FieldCryptocurrencyID:
		return m.OldCryptocurrencyID(ctx)
	}
	return nil, fmt.Errorf("unknown BlockchainCryptocurrency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainCryptocurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockchaincryptocurrency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockchaincryptocurrency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blockchaincryptocurrency.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case blockchaincryptocurrency.FieldBlockchainID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockchainID(v)
		return nil
	case blockchaincryptocurrency.FieldCryptocurrencyID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCryptocurrencyID(v)
		return nil
	}
	return fmt.Errorf("unknown BlockchainCryptocurrency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockchainCryptocurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockchainCryptocurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainCryptocurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockchainCryptocurrency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockchainCryptocurrencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockchaincryptocurrency.FieldDeletedAt) {
		fields = append(fields, blockchaincryptocurrency.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockchainCryptocurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockchainCryptocurrencyMutation) ClearField(name string) error {
	switch name {
	case blockchaincryptocurrency.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BlockchainCryptocurrency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockchainCryptocurrencyMutation) ResetField(name string) error {
	switch name {
	case blockchaincryptocurrency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockchaincryptocurrency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blockchaincryptocurrency.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case blockchaincryptocurrency.FieldBlockchainID:
		m.ResetBlockchainID()
		return nil
	case blockchaincryptocurrency.FieldCryptocurrencyID:
		m.ResetCryptocurrencyID()
		return nil
	}
	return fmt.Errorf("unknown BlockchainCryptocurrency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockchainCryptocurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blockchain != nil {
		edges = append(edges, blockchaincryptocurrency.EdgeBlockchain)
	}
	if m.cryptocurrency != nil {
		edges = append(edges, blockchaincryptocurrency.EdgeCryptocurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockchainCryptocurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockchaincryptocurrency.EdgeBlockchain:
		if id := m.blockchain; id != nil {
			return []ent.Value{*id}
		}
	case blockchaincryptocurrency.EdgeCryptocurrency:
		if id := m.cryptocurrency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockchainCryptocurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockchainCryptocurrencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockchainCryptocurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblockchain {
		edges = append(edges, blockchaincryptocurrency.EdgeBlockchain)
	}
	if m.clearedcryptocurrency {
		edges = append(edges, blockchaincryptocurrency.EdgeCryptocurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockchainCryptocurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case blockchaincryptocurrency.EdgeBlockchain:
		return m.clearedblockchain
	case blockchaincryptocurrency.EdgeCryptocurrency:
		return m.clearedcryptocurrency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockchainCryptocurrencyMutation) ClearEdge(name string) error {
	switch name {
	case blockchaincryptocurrency.EdgeBlockchain:
		m.ClearBlockchain()
		return nil
	case blockchaincryptocurrency.EdgeCryptocurrency:
		m.ClearCryptocurrency()
		return nil
	}
	return fmt.Errorf("unknown BlockchainCryptocurrency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockchainCryptocurrencyMutation) ResetEdge(name string) error {
	switch name {
	case blockchaincryptocurrency.EdgeBlockchain:
		m.ResetBlockchain()
		return nil
	case blockchaincryptocurrency.EdgeCryptocurrency:
		m.ResetCryptocurrency()
		return nil
	}
	return fmt.Errorf("unknown BlockchainCryptocurrency edge %s", name)
}

// CryptocurrencyMutation represents an operation that mutates the Cryptocurrency nodes in the graph.
type CryptocurrencyMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *pulid.PULID
	created_at                         *time.Time
	updated_at                         *time.Time
	deleted_at                         *time.Time
	symbol                             *string
	icon                               *string
	name                               *string
	clearedFields                      map[string]struct{}
	asset                              *pulid.PULID
	clearedasset                       bool
	blockchains                        map[pulid.PULID]struct{}
	removedblockchains                 map[pulid.PULID]struct{}
	clearedblockchains                 bool
	blockchain_cryptocurrencies        map[pulid.PULID]struct{}
	removedblockchain_cryptocurrencies map[pulid.PULID]struct{}
	clearedblockchain_cryptocurrencies bool
	done                               bool
	oldValue                           func(context.Context) (*Cryptocurrency, error)
	predicates                         []predicate.Cryptocurrency
}

var _ ent.Mutation = (*CryptocurrencyMutation)(nil)

// cryptocurrencyOption allows management of the mutation configuration using functional options.
type cryptocurrencyOption func(*CryptocurrencyMutation)

// newCryptocurrencyMutation creates new mutation for the Cryptocurrency entity.
func newCryptocurrencyMutation(c config, op Op, opts ...cryptocurrencyOption) *CryptocurrencyMutation {
	m := &CryptocurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCryptocurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCryptocurrencyID sets the ID field of the mutation.
func withCryptocurrencyID(id pulid.PULID) cryptocurrencyOption {
	return func(m *CryptocurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Cryptocurrency
		)
		m.oldValue = func(ctx context.Context) (*Cryptocurrency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cryptocurrency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCryptocurrency sets the old Cryptocurrency of the mutation.
func withCryptocurrency(node *Cryptocurrency) cryptocurrencyOption {
	return func(m *CryptocurrencyMutation) {
		m.oldValue = func(context.Context) (*Cryptocurrency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CryptocurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CryptocurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cryptocurrency entities.
func (m *CryptocurrencyMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CryptocurrencyMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CryptocurrencyMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cryptocurrency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CryptocurrencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CryptocurrencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CryptocurrencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CryptocurrencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CryptocurrencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CryptocurrencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CryptocurrencyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CryptocurrencyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CryptocurrencyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cryptocurrency.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CryptocurrencyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cryptocurrency.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CryptocurrencyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cryptocurrency.FieldDeletedAt)
}

// SetSymbol sets the "symbol" field.
func (m *CryptocurrencyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *CryptocurrencyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *CryptocurrencyMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIcon sets the "icon" field.
func (m *CryptocurrencyMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CryptocurrencyMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CryptocurrencyMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[cryptocurrency.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CryptocurrencyMutation) IconCleared() bool {
	_, ok := m.clearedFields[cryptocurrency.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CryptocurrencyMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, cryptocurrency.FieldIcon)
}

// SetName sets the "name" field.
func (m *CryptocurrencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CryptocurrencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CryptocurrencyMutation) ResetName() {
	m.name = nil
}

// SetAssetID sets the "asset_id" field.
func (m *CryptocurrencyMutation) SetAssetID(pu pulid.PULID) {
	m.asset = &pu
}

// AssetID returns the value of the "asset_id" field in the mutation.
func (m *CryptocurrencyMutation) AssetID() (r pulid.PULID, exists bool) {
	v := m.asset
	if v == nil {
		return
	}
	return *v, true
}

// OldAssetID returns the old "asset_id" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldAssetID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssetID: %w", err)
	}
	return oldValue.AssetID, nil
}

// ResetAssetID resets all changes to the "asset_id" field.
func (m *CryptocurrencyMutation) ResetAssetID() {
	m.asset = nil
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *CryptocurrencyMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *CryptocurrencyMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *CryptocurrencyMutation) AssetIDs() (ids []pulid.PULID) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *CryptocurrencyMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddBlockchainIDs adds the "blockchains" edge to the Blockchain entity by ids.
func (m *CryptocurrencyMutation) AddBlockchainIDs(ids ...pulid.PULID) {
	if m.blockchains == nil {
		m.blockchains = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.blockchains[ids[i]] = struct{}{}
	}
}

// ClearBlockchains clears the "blockchains" edge to the Blockchain entity.
func (m *CryptocurrencyMutation) ClearBlockchains() {
	m.clearedblockchains = true
}

// BlockchainsCleared reports if the "blockchains" edge to the Blockchain entity was cleared.
func (m *CryptocurrencyMutation) BlockchainsCleared() bool {
	return m.clearedblockchains
}

// RemoveBlockchainIDs removes the "blockchains" edge to the Blockchain entity by IDs.
func (m *CryptocurrencyMutation) RemoveBlockchainIDs(ids ...pulid.PULID) {
	if m.removedblockchains == nil {
		m.removedblockchains = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.blockchains, ids[i])
		m.removedblockchains[ids[i]] = struct{}{}
	}
}

// RemovedBlockchains returns the removed IDs of the "blockchains" edge to the Blockchain entity.
func (m *CryptocurrencyMutation) RemovedBlockchainsIDs() (ids []pulid.PULID) {
	for id := range m.removedblockchains {
		ids = append(ids, id)
	}
	return
}

// BlockchainsIDs returns the "blockchains" edge IDs in the mutation.
func (m *CryptocurrencyMutation) BlockchainsIDs() (ids []pulid.PULID) {
	for id := range m.blockchains {
		ids = append(ids, id)
	}
	return
}

// ResetBlockchains resets all changes to the "blockchains" edge.
func (m *CryptocurrencyMutation) ResetBlockchains() {
	m.blockchains = nil
	m.clearedblockchains = false
	m.removedblockchains = nil
}

// AddBlockchainCryptocurrencyIDs adds the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity by ids.
func (m *CryptocurrencyMutation) AddBlockchainCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.blockchain_cryptocurrencies == nil {
		m.blockchain_cryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.blockchain_cryptocurrencies[ids[i]] = struct{}{}
	}
}

// ClearBlockchainCryptocurrencies clears the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity.
func (m *CryptocurrencyMutation) ClearBlockchainCryptocurrencies() {
	m.clearedblockchain_cryptocurrencies = true
}

// BlockchainCryptocurrenciesCleared reports if the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity was cleared.
func (m *CryptocurrencyMutation) BlockchainCryptocurrenciesCleared() bool {
	return m.clearedblockchain_cryptocurrencies
}

// RemoveBlockchainCryptocurrencyIDs removes the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity by IDs.
func (m *CryptocurrencyMutation) RemoveBlockchainCryptocurrencyIDs(ids ...pulid.PULID) {
	if m.removedblockchain_cryptocurrencies == nil {
		m.removedblockchain_cryptocurrencies = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.blockchain_cryptocurrencies, ids[i])
		m.removedblockchain_cryptocurrencies[ids[i]] = struct{}{}
	}
}

// RemovedBlockchainCryptocurrencies returns the removed IDs of the "blockchain_cryptocurrencies" edge to the BlockchainCryptocurrency entity.
func (m *CryptocurrencyMutation) RemovedBlockchainCryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.removedblockchain_cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// BlockchainCryptocurrenciesIDs returns the "blockchain_cryptocurrencies" edge IDs in the mutation.
func (m *CryptocurrencyMutation) BlockchainCryptocurrenciesIDs() (ids []pulid.PULID) {
	for id := range m.blockchain_cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// ResetBlockchainCryptocurrencies resets all changes to the "blockchain_cryptocurrencies" edge.
func (m *CryptocurrencyMutation) ResetBlockchainCryptocurrencies() {
	m.blockchain_cryptocurrencies = nil
	m.clearedblockchain_cryptocurrencies = false
	m.removedblockchain_cryptocurrencies = nil
}

// Where appends a list predicates to the CryptocurrencyMutation builder.
func (m *CryptocurrencyMutation) Where(ps ...predicate.Cryptocurrency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CryptocurrencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cryptocurrency).
func (m *CryptocurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CryptocurrencyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, cryptocurrency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cryptocurrency.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cryptocurrency.FieldDeletedAt)
	}
	if m.symbol != nil {
		fields = append(fields, cryptocurrency.FieldSymbol)
	}
	if m.icon != nil {
		fields = append(fields, cryptocurrency.FieldIcon)
	}
	if m.name != nil {
		fields = append(fields, cryptocurrency.FieldName)
	}
	if m.asset != nil {
		fields = append(fields, cryptocurrency.FieldAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CryptocurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		return m.CreatedAt()
	case cryptocurrency.FieldUpdatedAt:
		return m.UpdatedAt()
	case cryptocurrency.FieldDeletedAt:
		return m.DeletedAt()
	case cryptocurrency.FieldSymbol:
		return m.Symbol()
	case cryptocurrency.FieldIcon:
		return m.Icon()
	case cryptocurrency.FieldName:
		return m.Name()
	case cryptocurrency.FieldAssetID:
		return m.AssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CryptocurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cryptocurrency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cryptocurrency.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cryptocurrency.FieldSymbol:
		return m.OldSymbol(ctx)
	case cryptocurrency.FieldIcon:
		return m.OldIcon(ctx)
	case cryptocurrency.FieldName:
		return m.OldName(ctx)
	case cryptocurrency.FieldAssetID:
		return m.OldAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptocurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cryptocurrency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cryptocurrency.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cryptocurrency.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case cryptocurrency.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case cryptocurrency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cryptocurrency.FieldAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CryptocurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CryptocurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptocurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cryptocurrency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CryptocurrencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cryptocurrency.FieldDeletedAt) {
		fields = append(fields, cryptocurrency.FieldDeletedAt)
	}
	if m.FieldCleared(cryptocurrency.FieldIcon) {
		fields = append(fields, cryptocurrency.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CryptocurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CryptocurrencyMutation) ClearField(name string) error {
	switch name {
	case cryptocurrency.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cryptocurrency.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CryptocurrencyMutation) ResetField(name string) error {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cryptocurrency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cryptocurrency.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cryptocurrency.FieldSymbol:
		m.ResetSymbol()
		return nil
	case cryptocurrency.FieldIcon:
		m.ResetIcon()
		return nil
	case cryptocurrency.FieldName:
		m.ResetName()
		return nil
	case cryptocurrency.FieldAssetID:
		m.ResetAssetID()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CryptocurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.asset != nil {
		edges = append(edges, cryptocurrency.EdgeAsset)
	}
	if m.blockchains != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	if m.blockchain_cryptocurrencies != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchainCryptocurrencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CryptocurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cryptocurrency.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case cryptocurrency.EdgeBlockchains:
		ids := make([]ent.Value, 0, len(m.blockchains))
		for id := range m.blockchains {
			ids = append(ids, id)
		}
		return ids
	case cryptocurrency.EdgeBlockchainCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.blockchain_cryptocurrencies))
		for id := range m.blockchain_cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CryptocurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedblockchains != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	if m.removedblockchain_cryptocurrencies != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchainCryptocurrencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CryptocurrencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cryptocurrency.EdgeBlockchains:
		ids := make([]ent.Value, 0, len(m.removedblockchains))
		for id := range m.removedblockchains {
			ids = append(ids, id)
		}
		return ids
	case cryptocurrency.EdgeBlockchainCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.removedblockchain_cryptocurrencies))
		for id := range m.removedblockchain_cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CryptocurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedasset {
		edges = append(edges, cryptocurrency.EdgeAsset)
	}
	if m.clearedblockchains {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	if m.clearedblockchain_cryptocurrencies {
		edges = append(edges, cryptocurrency.EdgeBlockchainCryptocurrencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CryptocurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case cryptocurrency.EdgeAsset:
		return m.clearedasset
	case cryptocurrency.EdgeBlockchains:
		return m.clearedblockchains
	case cryptocurrency.EdgeBlockchainCryptocurrencies:
		return m.clearedblockchain_cryptocurrencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CryptocurrencyMutation) ClearEdge(name string) error {
	switch name {
	case cryptocurrency.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CryptocurrencyMutation) ResetEdge(name string) error {
	switch name {
	case cryptocurrency.EdgeAsset:
		m.ResetAsset()
		return nil
	case cryptocurrency.EdgeBlockchains:
		m.ResetBlockchains()
		return nil
	case cryptocurrency.EdgeBlockchainCryptocurrencies:
		m.ResetBlockchainCryptocurrencies()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency edge %s", name)
}

// DailyAssetPriceMutation represents an operation that mutates the DailyAssetPrice nodes in the graph.
type DailyAssetPriceMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.PULID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	time              *time.Time
	open              *float64
	addopen           *float64
	high              *float64
	addhigh           *float64
	low               *float64
	addlow            *float64
	close             *float64
	addclose          *float64
	adjusted_close    *float64
	addadjusted_close *float64
	clearedFields     map[string]struct{}
	base_asset        *pulid.PULID
	clearedbase_asset bool
	done              bool
	oldValue          func(context.Context) (*DailyAssetPrice, error)
	predicates        []predicate.DailyAssetPrice
}

var _ ent.Mutation = (*DailyAssetPriceMutation)(nil)

// dailyassetpriceOption allows management of the mutation configuration using functional options.
type dailyassetpriceOption func(*DailyAssetPriceMutation)

// newDailyAssetPriceMutation creates new mutation for the DailyAssetPrice entity.
func newDailyAssetPriceMutation(c config, op Op, opts ...dailyassetpriceOption) *DailyAssetPriceMutation {
	m := &DailyAssetPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeDailyAssetPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDailyAssetPriceID sets the ID field of the mutation.
func withDailyAssetPriceID(id pulid.PULID) dailyassetpriceOption {
	return func(m *DailyAssetPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *DailyAssetPrice
		)
		m.oldValue = func(ctx context.Context) (*DailyAssetPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DailyAssetPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDailyAssetPrice sets the old DailyAssetPrice of the mutation.
func withDailyAssetPrice(node *DailyAssetPrice) dailyassetpriceOption {
	return func(m *DailyAssetPriceMutation) {
		m.oldValue = func(context.Context) (*DailyAssetPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DailyAssetPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DailyAssetPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DailyAssetPrice entities.
func (m *DailyAssetPriceMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DailyAssetPriceMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DailyAssetPriceMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DailyAssetPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DailyAssetPriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DailyAssetPriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DailyAssetPriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DailyAssetPriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DailyAssetPriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DailyAssetPriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DailyAssetPriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DailyAssetPriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DailyAssetPriceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dailyassetprice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DailyAssetPriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dailyassetprice.FieldDeletedAt)
}

// SetTime sets the "time" field.
func (m *DailyAssetPriceMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *DailyAssetPriceMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *DailyAssetPriceMutation) ResetTime() {
	m.time = nil
}

// SetOpen sets the "open" field.
func (m *DailyAssetPriceMutation) SetOpen(f float64) {
	m.open = &f
	m.addopen = nil
}

// Open returns the value of the "open" field in the mutation.
func (m *DailyAssetPriceMutation) Open() (r float64, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldOpen(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// AddOpen adds f to the "open" field.
func (m *DailyAssetPriceMutation) AddOpen(f float64) {
	if m.addopen != nil {
		*m.addopen += f
	} else {
		m.addopen = &f
	}
}

// AddedOpen returns the value that was added to the "open" field in this mutation.
func (m *DailyAssetPriceMutation) AddedOpen() (r float64, exists bool) {
	v := m.addopen
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpen clears the value of the "open" field.
func (m *DailyAssetPriceMutation) ClearOpen() {
	m.open = nil
	m.addopen = nil
	m.clearedFields[dailyassetprice.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) OpenCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *DailyAssetPriceMutation) ResetOpen() {
	m.open = nil
	m.addopen = nil
	delete(m.clearedFields, dailyassetprice.FieldOpen)
}

// SetHigh sets the "high" field.
func (m *DailyAssetPriceMutation) SetHigh(f float64) {
	m.high = &f
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *DailyAssetPriceMutation) High() (r float64, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldHigh(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds f to the "high" field.
func (m *DailyAssetPriceMutation) AddHigh(f float64) {
	if m.addhigh != nil {
		*m.addhigh += f
	} else {
		m.addhigh = &f
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *DailyAssetPriceMutation) AddedHigh() (r float64, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ClearHigh clears the value of the "high" field.
func (m *DailyAssetPriceMutation) ClearHigh() {
	m.high = nil
	m.addhigh = nil
	m.clearedFields[dailyassetprice.FieldHigh] = struct{}{}
}

// HighCleared returns if the "high" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) HighCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldHigh]
	return ok
}

// ResetHigh resets all changes to the "high" field.
func (m *DailyAssetPriceMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
	delete(m.clearedFields, dailyassetprice.FieldHigh)
}

// SetLow sets the "low" field.
func (m *DailyAssetPriceMutation) SetLow(f float64) {
	m.low = &f
	m.addlow = nil
}

// Low returns the value of the "low" field in the mutation.
func (m *DailyAssetPriceMutation) Low() (r float64, exists bool) {
	v := m.low
	if v == nil {
		return
	}
	return *v, true
}

// OldLow returns the old "low" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldLow(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLow: %w", err)
	}
	return oldValue.Low, nil
}

// AddLow adds f to the "low" field.
func (m *DailyAssetPriceMutation) AddLow(f float64) {
	if m.addlow != nil {
		*m.addlow += f
	} else {
		m.addlow = &f
	}
}

// AddedLow returns the value that was added to the "low" field in this mutation.
func (m *DailyAssetPriceMutation) AddedLow() (r float64, exists bool) {
	v := m.addlow
	if v == nil {
		return
	}
	return *v, true
}

// ClearLow clears the value of the "low" field.
func (m *DailyAssetPriceMutation) ClearLow() {
	m.low = nil
	m.addlow = nil
	m.clearedFields[dailyassetprice.FieldLow] = struct{}{}
}

// LowCleared returns if the "low" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) LowCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldLow]
	return ok
}

// ResetLow resets all changes to the "low" field.
func (m *DailyAssetPriceMutation) ResetLow() {
	m.low = nil
	m.addlow = nil
	delete(m.clearedFields, dailyassetprice.FieldLow)
}

// SetClose sets the "close" field.
func (m *DailyAssetPriceMutation) SetClose(f float64) {
	m.close = &f
	m.addclose = nil
}

// Close returns the value of the "close" field in the mutation.
func (m *DailyAssetPriceMutation) Close() (r float64, exists bool) {
	v := m.close
	if v == nil {
		return
	}
	return *v, true
}

// OldClose returns the old "close" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldClose(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClose: %w", err)
	}
	return oldValue.Close, nil
}

// AddClose adds f to the "close" field.
func (m *DailyAssetPriceMutation) AddClose(f float64) {
	if m.addclose != nil {
		*m.addclose += f
	} else {
		m.addclose = &f
	}
}

// AddedClose returns the value that was added to the "close" field in this mutation.
func (m *DailyAssetPriceMutation) AddedClose() (r float64, exists bool) {
	v := m.addclose
	if v == nil {
		return
	}
	return *v, true
}

// ClearClose clears the value of the "close" field.
func (m *DailyAssetPriceMutation) ClearClose() {
	m.close = nil
	m.addclose = nil
	m.clearedFields[dailyassetprice.FieldClose] = struct{}{}
}

// CloseCleared returns if the "close" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) CloseCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldClose]
	return ok
}

// ResetClose resets all changes to the "close" field.
func (m *DailyAssetPriceMutation) ResetClose() {
	m.close = nil
	m.addclose = nil
	delete(m.clearedFields, dailyassetprice.FieldClose)
}

// SetAdjustedClose sets the "adjusted_close" field.
func (m *DailyAssetPriceMutation) SetAdjustedClose(f float64) {
	m.adjusted_close = &f
	m.addadjusted_close = nil
}

// AdjustedClose returns the value of the "adjusted_close" field in the mutation.
func (m *DailyAssetPriceMutation) AdjustedClose() (r float64, exists bool) {
	v := m.adjusted_close
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustedClose returns the old "adjusted_close" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldAdjustedClose(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdjustedClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdjustedClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustedClose: %w", err)
	}
	return oldValue.AdjustedClose, nil
}

// AddAdjustedClose adds f to the "adjusted_close" field.
func (m *DailyAssetPriceMutation) AddAdjustedClose(f float64) {
	if m.addadjusted_close != nil {
		*m.addadjusted_close += f
	} else {
		m.addadjusted_close = &f
	}
}

// AddedAdjustedClose returns the value that was added to the "adjusted_close" field in this mutation.
func (m *DailyAssetPriceMutation) AddedAdjustedClose() (r float64, exists bool) {
	v := m.addadjusted_close
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdjustedClose resets all changes to the "adjusted_close" field.
func (m *DailyAssetPriceMutation) ResetAdjustedClose() {
	m.adjusted_close = nil
	m.addadjusted_close = nil
}

// SetBaseAssetID sets the "base_asset_id" field.
func (m *DailyAssetPriceMutation) SetBaseAssetID(pu pulid.PULID) {
	m.base_asset = &pu
}

// BaseAssetID returns the value of the "base_asset_id" field in the mutation.
func (m *DailyAssetPriceMutation) BaseAssetID() (r pulid.PULID, exists bool) {
	v := m.base_asset
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseAssetID returns the old "base_asset_id" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldBaseAssetID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseAssetID: %w", err)
	}
	return oldValue.BaseAssetID, nil
}

// ResetBaseAssetID resets all changes to the "base_asset_id" field.
func (m *DailyAssetPriceMutation) ResetBaseAssetID() {
	m.base_asset = nil
}

// ClearBaseAsset clears the "base_asset" edge to the Asset entity.
func (m *DailyAssetPriceMutation) ClearBaseAsset() {
	m.clearedbase_asset = true
}

// BaseAssetCleared reports if the "base_asset" edge to the Asset entity was cleared.
func (m *DailyAssetPriceMutation) BaseAssetCleared() bool {
	return m.clearedbase_asset
}

// BaseAssetIDs returns the "base_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseAssetID instead. It exists only for internal usage by the builders.
func (m *DailyAssetPriceMutation) BaseAssetIDs() (ids []pulid.PULID) {
	if id := m.base_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBaseAsset resets all changes to the "base_asset" edge.
func (m *DailyAssetPriceMutation) ResetBaseAsset() {
	m.base_asset = nil
	m.clearedbase_asset = false
}

// Where appends a list predicates to the DailyAssetPriceMutation builder.
func (m *DailyAssetPriceMutation) Where(ps ...predicate.DailyAssetPrice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DailyAssetPriceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DailyAssetPrice).
func (m *DailyAssetPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DailyAssetPriceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, dailyassetprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dailyassetprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dailyassetprice.FieldDeletedAt)
	}
	if m.time != nil {
		fields = append(fields, dailyassetprice.FieldTime)
	}
	if m.open != nil {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.high != nil {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.low != nil {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.close != nil {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	if m.adjusted_close != nil {
		fields = append(fields, dailyassetprice.FieldAdjustedClose)
	}
	if m.base_asset != nil {
		fields = append(fields, dailyassetprice.FieldBaseAssetID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DailyAssetPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		return m.CreatedAt()
	case dailyassetprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case dailyassetprice.FieldDeletedAt:
		return m.DeletedAt()
	case dailyassetprice.FieldTime:
		return m.Time()
	case dailyassetprice.FieldOpen:
		return m.Open()
	case dailyassetprice.FieldHigh:
		return m.High()
	case dailyassetprice.FieldLow:
		return m.Low()
	case dailyassetprice.FieldClose:
		return m.Close()
	case dailyassetprice.FieldAdjustedClose:
		return m.AdjustedClose()
	case dailyassetprice.FieldBaseAssetID:
		return m.BaseAssetID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DailyAssetPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dailyassetprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dailyassetprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dailyassetprice.FieldTime:
		return m.OldTime(ctx)
	case dailyassetprice.FieldOpen:
		return m.OldOpen(ctx)
	case dailyassetprice.FieldHigh:
		return m.OldHigh(ctx)
	case dailyassetprice.FieldLow:
		return m.OldLow(ctx)
	case dailyassetprice.FieldClose:
		return m.OldClose(ctx)
	case dailyassetprice.FieldAdjustedClose:
		return m.OldAdjustedClose(ctx)
	case dailyassetprice.FieldBaseAssetID:
		return m.OldBaseAssetID(ctx)
	}
	return nil, fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyAssetPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dailyassetprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dailyassetprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dailyassetprice.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case dailyassetprice.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case dailyassetprice.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case dailyassetprice.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLow(v)
		return nil
	case dailyassetprice.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClose(v)
		return nil
	case dailyassetprice.FieldAdjustedClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustedClose(v)
		return nil
	case dailyassetprice.FieldBaseAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseAssetID(v)
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DailyAssetPriceMutation) AddedFields() []string {
	var fields []string
	if m.addopen != nil {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.addhigh != nil {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.addlow != nil {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.addclose != nil {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	if m.addadjusted_close != nil {
		fields = append(fields, dailyassetprice.FieldAdjustedClose)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DailyAssetPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dailyassetprice.FieldOpen:
		return m.AddedOpen()
	case dailyassetprice.FieldHigh:
		return m.AddedHigh()
	case dailyassetprice.FieldLow:
		return m.AddedLow()
	case dailyassetprice.FieldClose:
		return m.AddedClose()
	case dailyassetprice.FieldAdjustedClose:
		return m.AddedAdjustedClose()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyAssetPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dailyassetprice.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpen(v)
		return nil
	case dailyassetprice.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case dailyassetprice.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLow(v)
		return nil
	case dailyassetprice.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClose(v)
		return nil
	case dailyassetprice.FieldAdjustedClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdjustedClose(v)
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DailyAssetPriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dailyassetprice.FieldDeletedAt) {
		fields = append(fields, dailyassetprice.FieldDeletedAt)
	}
	if m.FieldCleared(dailyassetprice.FieldOpen) {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.FieldCleared(dailyassetprice.FieldHigh) {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.FieldCleared(dailyassetprice.FieldLow) {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.FieldCleared(dailyassetprice.FieldClose) {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DailyAssetPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DailyAssetPriceMutation) ClearField(name string) error {
	switch name {
	case dailyassetprice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dailyassetprice.FieldOpen:
		m.ClearOpen()
		return nil
	case dailyassetprice.FieldHigh:
		m.ClearHigh()
		return nil
	case dailyassetprice.FieldLow:
		m.ClearLow()
		return nil
	case dailyassetprice.FieldClose:
		m.ClearClose()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DailyAssetPriceMutation) ResetField(name string) error {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dailyassetprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dailyassetprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dailyassetprice.FieldTime:
		m.ResetTime()
		return nil
	case dailyassetprice.FieldOpen:
		m.ResetOpen()
		return nil
	case dailyassetprice.FieldHigh:
		m.ResetHigh()
		return nil
	case dailyassetprice.FieldLow:
		m.ResetLow()
		return nil
	case dailyassetprice.FieldClose:
		m.ResetClose()
		return nil
	case dailyassetprice.FieldAdjustedClose:
		m.ResetAdjustedClose()
		return nil
	case dailyassetprice.FieldBaseAssetID:
		m.ResetBaseAssetID()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DailyAssetPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.base_asset != nil {
		edges = append(edges, dailyassetprice.EdgeBaseAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DailyAssetPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		if id := m.base_asset; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DailyAssetPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DailyAssetPriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DailyAssetPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbase_asset {
		edges = append(edges, dailyassetprice.EdgeBaseAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DailyAssetPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		return m.clearedbase_asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DailyAssetPriceMutation) ClearEdge(name string) error {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		m.ClearBaseAsset()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DailyAssetPriceMutation) ResetEdge(name string) error {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		m.ResetBaseAsset()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	icon                *string
	url                 *string
	clearedFields       map[string]struct{}
	transactions        map[pulid.PULID]struct{}
	removedtransactions map[pulid.PULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Exchange, error)
	predicates          []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id pulid.PULID) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExchangeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExchangeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExchangeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exchange.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExchangeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExchangeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exchange.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *ExchangeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *ExchangeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *ExchangeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[exchange.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *ExchangeMutation) IconCleared() bool {
	_, ok := m.clearedFields[exchange.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *ExchangeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, exchange.FieldIcon)
}

// SetURL sets the "url" field.
func (m *ExchangeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ExchangeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ExchangeMutation) ClearURL() {
	m.url = nil
	m.clearedFields[exchange.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ExchangeMutation) URLCleared() bool {
	_, ok := m.clearedFields[exchange.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ExchangeMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, exchange.FieldURL)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *ExchangeMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *ExchangeMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *ExchangeMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *ExchangeMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *ExchangeMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *ExchangeMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *ExchangeMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, exchange.FieldIcon)
	}
	if m.url != nil {
		fields = append(fields, exchange.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	case exchange.FieldDeletedAt:
		return m.DeletedAt()
	case exchange.FieldName:
		return m.Name()
	case exchange.FieldIcon:
		return m.Icon()
	case exchange.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exchange.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exchange.FieldName:
		return m.OldName(ctx)
	case exchange.FieldIcon:
		return m.OldIcon(ctx)
	case exchange.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exchange.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exchange.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchange.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case exchange.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldDeletedAt) {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.FieldCleared(exchange.FieldIcon) {
		fields = append(fields, exchange.FieldIcon)
	}
	if m.FieldCleared(exchange.FieldURL) {
		fields = append(fields, exchange.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exchange.FieldIcon:
		m.ClearIcon()
		return nil
	case exchange.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exchange.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exchange.FieldName:
		m.ResetName()
		return nil
	case exchange.FieldIcon:
		m.ResetIcon()
		return nil
	case exchange.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	is_public           *bool
	is_visible          *bool
	clearedFields       map[string]struct{}
	account             *pulid.PULID
	clearedaccount      bool
	transactions        map[pulid.PULID]struct{}
	removedtransactions map[pulid.PULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Portfolio, error)
	predicates          []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id pulid.PULID) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Portfolio entities.
func (m *PortfolioMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PortfolioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortfolioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortfolioMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortfolioMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortfolioMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortfolioMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PortfolioMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PortfolioMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PortfolioMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[portfolio.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PortfolioMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[portfolio.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PortfolioMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, portfolio.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PortfolioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortfolioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortfolioMutation) ResetName() {
	m.name = nil
}

// SetIsPublic sets the "is_public" field.
func (m *PortfolioMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *PortfolioMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *PortfolioMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetIsVisible sets the "is_visible" field.
func (m *PortfolioMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *PortfolioMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *PortfolioMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetAccountID sets the "account_id" field.
func (m *PortfolioMutation) SetAccountID(pu pulid.PULID) {
	m.account = &pu
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PortfolioMutation) AccountID() (r pulid.PULID, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldAccountID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PortfolioMutation) ResetAccountID() {
	m.account = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *PortfolioMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *PortfolioMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) AccountIDs() (ids []pulid.PULID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *PortfolioMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *PortfolioMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *PortfolioMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *PortfolioMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *PortfolioMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *PortfolioMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PortfolioMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PortfolioMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, portfolio.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, portfolio.FieldName)
	}
	if m.is_public != nil {
		fields = append(fields, portfolio.FieldIsPublic)
	}
	if m.is_visible != nil {
		fields = append(fields, portfolio.FieldIsVisible)
	}
	if m.account != nil {
		fields = append(fields, portfolio.FieldAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.CreatedAt()
	case portfolio.FieldUpdatedAt:
		return m.UpdatedAt()
	case portfolio.FieldDeletedAt:
		return m.DeletedAt()
	case portfolio.FieldName:
		return m.Name()
	case portfolio.FieldIsPublic:
		return m.IsPublic()
	case portfolio.FieldIsVisible:
		return m.IsVisible()
	case portfolio.FieldAccountID:
		return m.AccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portfolio.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case portfolio.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case portfolio.FieldName:
		return m.OldName(ctx)
	case portfolio.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case portfolio.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case portfolio.FieldAccountID:
		return m.OldAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portfolio.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case portfolio.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case portfolio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portfolio.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case portfolio.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case portfolio.FieldAccountID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(portfolio.FieldDeletedAt) {
		fields = append(fields, portfolio.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	switch name {
	case portfolio.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case portfolio.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case portfolio.FieldName:
		m.ResetName()
		return nil
	case portfolio.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case portfolio.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case portfolio.FieldAccountID:
		m.ResetAccountID()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, portfolio.EdgeAccount)
	}
	if m.transactions != nil {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case portfolio.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, portfolio.EdgeAccount)
	}
	if m.clearedtransactions {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	switch name {
	case portfolio.EdgeAccount:
		return m.clearedaccount
	case portfolio.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	switch name {
	case portfolio.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	switch name {
	case portfolio.EdgeAccount:
		m.ResetAccount()
		return nil
	case portfolio.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.PULID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	time                    *time.Time
	units                   *int
	addunits                *int
	price_per_unit          *float64
	addprice_per_unit       *float64
	clearedFields           map[string]struct{}
	transaction_type        *pulid.PULID
	clearedtransaction_type bool
	base_asset              *pulid.PULID
	clearedbase_asset       bool
	quote_asset             *pulid.PULID
	clearedquote_asset      bool
	portfolio               *pulid.PULID
	clearedportfolio        bool
	exchange                *pulid.PULID
	clearedexchange         bool
	done                    bool
	oldValue                func(context.Context) (*Transaction, error)
	predicates              []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id pulid.PULID) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransactionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransactionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransactionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transaction.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransactionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transaction.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransactionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transaction.FieldDeletedAt)
}

// SetTime sets the "time" field.
func (m *TransactionMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TransactionMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TransactionMutation) ResetTime() {
	m.time = nil
}

// SetUnits sets the "units" field.
func (m *TransactionMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *TransactionMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *TransactionMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *TransactionMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *TransactionMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetPricePerUnit sets the "price_per_unit" field.
func (m *TransactionMutation) SetPricePerUnit(f float64) {
	m.price_per_unit = &f
	m.addprice_per_unit = nil
}

// PricePerUnit returns the value of the "price_per_unit" field in the mutation.
func (m *TransactionMutation) PricePerUnit() (r float64, exists bool) {
	v := m.price_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerUnit returns the old "price_per_unit" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPricePerUnit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerUnit: %w", err)
	}
	return oldValue.PricePerUnit, nil
}

// AddPricePerUnit adds f to the "price_per_unit" field.
func (m *TransactionMutation) AddPricePerUnit(f float64) {
	if m.addprice_per_unit != nil {
		*m.addprice_per_unit += f
	} else {
		m.addprice_per_unit = &f
	}
}

// AddedPricePerUnit returns the value that was added to the "price_per_unit" field in this mutation.
func (m *TransactionMutation) AddedPricePerUnit() (r float64, exists bool) {
	v := m.addprice_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerUnit resets all changes to the "price_per_unit" field.
func (m *TransactionMutation) ResetPricePerUnit() {
	m.price_per_unit = nil
	m.addprice_per_unit = nil
}

// SetTransactionTypeID sets the "transaction_type_id" field.
func (m *TransactionMutation) SetTransactionTypeID(pu pulid.PULID) {
	m.transaction_type = &pu
}

// TransactionTypeID returns the value of the "transaction_type_id" field in the mutation.
func (m *TransactionMutation) TransactionTypeID() (r pulid.PULID, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionTypeID returns the old "transaction_type_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionTypeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionTypeID: %w", err)
	}
	return oldValue.TransactionTypeID, nil
}

// ResetTransactionTypeID resets all changes to the "transaction_type_id" field.
func (m *TransactionMutation) ResetTransactionTypeID() {
	m.transaction_type = nil
}

// SetBaseAssetID sets the "base_asset_id" field.
func (m *TransactionMutation) SetBaseAssetID(pu pulid.PULID) {
	m.base_asset = &pu
}

// BaseAssetID returns the value of the "base_asset_id" field in the mutation.
func (m *TransactionMutation) BaseAssetID() (r pulid.PULID, exists bool) {
	v := m.base_asset
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseAssetID returns the old "base_asset_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldBaseAssetID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseAssetID: %w", err)
	}
	return oldValue.BaseAssetID, nil
}

// ResetBaseAssetID resets all changes to the "base_asset_id" field.
func (m *TransactionMutation) ResetBaseAssetID() {
	m.base_asset = nil
}

// SetQuoteAssetID sets the "quote_asset_id" field.
func (m *TransactionMutation) SetQuoteAssetID(pu pulid.PULID) {
	m.quote_asset = &pu
}

// QuoteAssetID returns the value of the "quote_asset_id" field in the mutation.
func (m *TransactionMutation) QuoteAssetID() (r pulid.PULID, exists bool) {
	v := m.quote_asset
	if v == nil {
		return
	}
	return *v, true
}

// OldQuoteAssetID returns the old "quote_asset_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldQuoteAssetID(ctx context.Context) (v *pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuoteAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuoteAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuoteAssetID: %w", err)
	}
	return oldValue.QuoteAssetID, nil
}

// ClearQuoteAssetID clears the value of the "quote_asset_id" field.
func (m *TransactionMutation) ClearQuoteAssetID() {
	m.quote_asset = nil
	m.clearedFields[transaction.FieldQuoteAssetID] = struct{}{}
}

// QuoteAssetIDCleared returns if the "quote_asset_id" field was cleared in this mutation.
func (m *TransactionMutation) QuoteAssetIDCleared() bool {
	_, ok := m.clearedFields[transaction.FieldQuoteAssetID]
	return ok
}

// ResetQuoteAssetID resets all changes to the "quote_asset_id" field.
func (m *TransactionMutation) ResetQuoteAssetID() {
	m.quote_asset = nil
	delete(m.clearedFields, transaction.FieldQuoteAssetID)
}

// SetPortfolioID sets the "portfolio_id" field.
func (m *TransactionMutation) SetPortfolioID(pu pulid.PULID) {
	m.portfolio = &pu
}

// PortfolioID returns the value of the "portfolio_id" field in the mutation.
func (m *TransactionMutation) PortfolioID() (r pulid.PULID, exists bool) {
	v := m.portfolio
	if v == nil {
		return
	}
	return *v, true
}

// OldPortfolioID returns the old "portfolio_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPortfolioID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPortfolioID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPortfolioID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPortfolioID: %w", err)
	}
	return oldValue.PortfolioID, nil
}

// ResetPortfolioID resets all changes to the "portfolio_id" field.
func (m *TransactionMutation) ResetPortfolioID() {
	m.portfolio = nil
}

// SetExchangeID sets the "exchange_id" field.
func (m *TransactionMutation) SetExchangeID(pu pulid.PULID) {
	m.exchange = &pu
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *TransactionMutation) ExchangeID() (r pulid.PULID, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldExchangeID(ctx context.Context) (v pulid.PULID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *TransactionMutation) ResetExchangeID() {
	m.exchange = nil
}

// ClearTransactionType clears the "transaction_type" edge to the TransactionType entity.
func (m *TransactionMutation) ClearTransactionType() {
	m.clearedtransaction_type = true
}

// TransactionTypeCleared reports if the "transaction_type" edge to the TransactionType entity was cleared.
func (m *TransactionMutation) TransactionTypeCleared() bool {
	return m.clearedtransaction_type
}

// TransactionTypeIDs returns the "transaction_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionTypeID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) TransactionTypeIDs() (ids []pulid.PULID) {
	if id := m.transaction_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransactionType resets all changes to the "transaction_type" edge.
func (m *TransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
	m.clearedtransaction_type = false
}

// ClearBaseAsset clears the "base_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearBaseAsset() {
	m.clearedbase_asset = true
}

// BaseAssetCleared reports if the "base_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) BaseAssetCleared() bool {
	return m.clearedbase_asset
}

// BaseAssetIDs returns the "base_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseAssetID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) BaseAssetIDs() (ids []pulid.PULID) {
	if id := m.base_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBaseAsset resets all changes to the "base_asset" edge.
func (m *TransactionMutation) ResetBaseAsset() {
	m.base_asset = nil
	m.clearedbase_asset = false
}

// ClearQuoteAsset clears the "quote_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearQuoteAsset() {
	m.clearedquote_asset = true
}

// QuoteAssetCleared reports if the "quote_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) QuoteAssetCleared() bool {
	return m.QuoteAssetIDCleared() || m.clearedquote_asset
}

// QuoteAssetIDs returns the "quote_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuoteAssetID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) QuoteAssetIDs() (ids []pulid.PULID) {
	if id := m.quote_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuoteAsset resets all changes to the "quote_asset" edge.
func (m *TransactionMutation) ResetQuoteAsset() {
	m.quote_asset = nil
	m.clearedquote_asset = false
}

// ClearPortfolio clears the "portfolio" edge to the Portfolio entity.
func (m *TransactionMutation) ClearPortfolio() {
	m.clearedportfolio = true
}

// PortfolioCleared reports if the "portfolio" edge to the Portfolio entity was cleared.
func (m *TransactionMutation) PortfolioCleared() bool {
	return m.clearedportfolio
}

// PortfolioIDs returns the "portfolio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PortfolioID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) PortfolioIDs() (ids []pulid.PULID) {
	if id := m.portfolio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPortfolio resets all changes to the "portfolio" edge.
func (m *TransactionMutation) ResetPortfolio() {
	m.portfolio = nil
	m.clearedportfolio = false
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *TransactionMutation) ClearExchange() {
	m.clearedexchange = true
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *TransactionMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ExchangeIDs() (ids []pulid.PULID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *TransactionMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transaction.FieldDeletedAt)
	}
	if m.time != nil {
		fields = append(fields, transaction.FieldTime)
	}
	if m.units != nil {
		fields = append(fields, transaction.FieldUnits)
	}
	if m.price_per_unit != nil {
		fields = append(fields, transaction.FieldPricePerUnit)
	}
	if m.transaction_type != nil {
		fields = append(fields, transaction.FieldTransactionTypeID)
	}
	if m.base_asset != nil {
		fields = append(fields, transaction.FieldBaseAssetID)
	}
	if m.quote_asset != nil {
		fields = append(fields, transaction.FieldQuoteAssetID)
	}
	if m.portfolio != nil {
		fields = append(fields, transaction.FieldPortfolioID)
	}
	if m.exchange != nil {
		fields = append(fields, transaction.FieldExchangeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case transaction.FieldDeletedAt:
		return m.DeletedAt()
	case transaction.FieldTime:
		return m.Time()
	case transaction.FieldUnits:
		return m.Units()
	case transaction.FieldPricePerUnit:
		return m.PricePerUnit()
	case transaction.FieldTransactionTypeID:
		return m.TransactionTypeID()
	case transaction.FieldBaseAssetID:
		return m.BaseAssetID()
	case transaction.FieldQuoteAssetID:
		return m.QuoteAssetID()
	case transaction.FieldPortfolioID:
		return m.PortfolioID()
	case transaction.FieldExchangeID:
		return m.ExchangeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transaction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transaction.FieldTime:
		return m.OldTime(ctx)
	case transaction.FieldUnits:
		return m.OldUnits(ctx)
	case transaction.FieldPricePerUnit:
		return m.OldPricePerUnit(ctx)
	case transaction.FieldTransactionTypeID:
		return m.OldTransactionTypeID(ctx)
	case transaction.FieldBaseAssetID:
		return m.OldBaseAssetID(ctx)
	case transaction.FieldQuoteAssetID:
		return m.OldQuoteAssetID(ctx)
	case transaction.FieldPortfolioID:
		return m.OldPortfolioID(ctx)
	case transaction.FieldExchangeID:
		return m.OldExchangeID(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transaction.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transaction.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case transaction.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case transaction.FieldPricePerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerUnit(v)
		return nil
	case transaction.FieldTransactionTypeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionTypeID(v)
		return nil
	case transaction.FieldBaseAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseAssetID(v)
		return nil
	case transaction.FieldQuoteAssetID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuoteAssetID(v)
		return nil
	case transaction.FieldPortfolioID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPortfolioID(v)
		return nil
	case transaction.FieldExchangeID:
		v, ok := value.(pulid.PULID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addunits != nil {
		fields = append(fields, transaction.FieldUnits)
	}
	if m.addprice_per_unit != nil {
		fields = append(fields, transaction.FieldPricePerUnit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldUnits:
		return m.AddedUnits()
	case transaction.FieldPricePerUnit:
		return m.AddedPricePerUnit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	case transaction.FieldPricePerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transaction.FieldDeletedAt) {
		fields = append(fields, transaction.FieldDeletedAt)
	}
	if m.FieldCleared(transaction.FieldQuoteAssetID) {
		fields = append(fields, transaction.FieldQuoteAssetID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	switch name {
	case transaction.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case transaction.FieldQuoteAssetID:
		m.ClearQuoteAssetID()
		return nil
	}
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transaction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transaction.FieldTime:
		m.ResetTime()
		return nil
	case transaction.FieldUnits:
		m.ResetUnits()
		return nil
	case transaction.FieldPricePerUnit:
		m.ResetPricePerUnit()
		return nil
	case transaction.FieldTransactionTypeID:
		m.ResetTransactionTypeID()
		return nil
	case transaction.FieldBaseAssetID:
		m.ResetBaseAssetID()
		return nil
	case transaction.FieldQuoteAssetID:
		m.ResetQuoteAssetID()
		return nil
	case transaction.FieldPortfolioID:
		m.ResetPortfolioID()
		return nil
	case transaction.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.transaction_type != nil {
		edges = append(edges, transaction.EdgeTransactionType)
	}
	if m.base_asset != nil {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.quote_asset != nil {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	if m.portfolio != nil {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.exchange != nil {
		edges = append(edges, transaction.EdgeExchange)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionType:
		if id := m.transaction_type; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeBaseAsset:
		if id := m.base_asset; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeQuoteAsset:
		if id := m.quote_asset; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgePortfolio:
		if id := m.portfolio; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtransaction_type {
		edges = append(edges, transaction.EdgeTransactionType)
	}
	if m.clearedbase_asset {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.clearedquote_asset {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	if m.clearedportfolio {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.clearedexchange {
		edges = append(edges, transaction.EdgeExchange)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeTransactionType:
		return m.clearedtransaction_type
	case transaction.EdgeBaseAsset:
		return m.clearedbase_asset
	case transaction.EdgeQuoteAsset:
		return m.clearedquote_asset
	case transaction.EdgePortfolio:
		return m.clearedportfolio
	case transaction.EdgeExchange:
		return m.clearedexchange
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeTransactionType:
		m.ClearTransactionType()
		return nil
	case transaction.EdgeBaseAsset:
		m.ClearBaseAsset()
		return nil
	case transaction.EdgeQuoteAsset:
		m.ClearQuoteAsset()
		return nil
	case transaction.EdgePortfolio:
		m.ClearPortfolio()
		return nil
	case transaction.EdgeExchange:
		m.ClearExchange()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeTransactionType:
		m.ResetTransactionType()
		return nil
	case transaction.EdgeBaseAsset:
		m.ResetBaseAsset()
		return nil
	case transaction.EdgeQuoteAsset:
		m.ResetQuoteAsset()
		return nil
	case transaction.EdgePortfolio:
		m.ResetPortfolio()
		return nil
	case transaction.EdgeExchange:
		m.ResetExchange()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionTypeMutation represents an operation that mutates the TransactionType nodes in the graph.
type TransactionTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.PULID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	transaction_type    *transactiontype.TransactionType
	description         *string
	clearedFields       map[string]struct{}
	transactions        map[pulid.PULID]struct{}
	removedtransactions map[pulid.PULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*TransactionType, error)
	predicates          []predicate.TransactionType
}

var _ ent.Mutation = (*TransactionTypeMutation)(nil)

// transactiontypeOption allows management of the mutation configuration using functional options.
type transactiontypeOption func(*TransactionTypeMutation)

// newTransactionTypeMutation creates new mutation for the TransactionType entity.
func newTransactionTypeMutation(c config, op Op, opts ...transactiontypeOption) *TransactionTypeMutation {
	m := &TransactionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionTypeID sets the ID field of the mutation.
func withTransactionTypeID(id pulid.PULID) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionType
		)
		m.oldValue = func(ctx context.Context) (*TransactionType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionType sets the old TransactionType of the mutation.
func withTransactionType(node *TransactionType) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		m.oldValue = func(context.Context) (*TransactionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransactionType entities.
func (m *TransactionTypeMutation) SetID(id pulid.PULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionTypeMutation) ID() (id pulid.PULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionTypeMutation) IDs(ctx context.Context) ([]pulid.PULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.PULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TransactionTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TransactionTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TransactionTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[transactiontype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TransactionTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[transactiontype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TransactionTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, transactiontype.FieldDeletedAt)
}

// SetTransactionType sets the "transaction_type" field.
func (m *TransactionTypeMutation) SetTransactionType(tt transactiontype.TransactionType) {
	m.transaction_type = &tt
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *TransactionTypeMutation) TransactionType() (r transactiontype.TransactionType, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldTransactionType(ctx context.Context) (v transactiontype.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *TransactionTypeMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetDescription sets the "description" field.
func (m *TransactionTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transactiontype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transactiontype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transactiontype.FieldDescription)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *TransactionTypeMutation) AddTransactionIDs(ids ...pulid.PULID) {
	if m.transactions == nil {
		m.transactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *TransactionTypeMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *TransactionTypeMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *TransactionTypeMutation) RemoveTransactionIDs(ids ...pulid.PULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[pulid.PULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *TransactionTypeMutation) RemovedTransactionsIDs() (ids []pulid.PULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *TransactionTypeMutation) TransactionsIDs() (ids []pulid.PULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *TransactionTypeMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the TransactionTypeMutation builder.
func (m *TransactionTypeMutation) Where(ps ...predicate.TransactionType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransactionType).
func (m *TransactionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, transactiontype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transactiontype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, transactiontype.FieldDeletedAt)
	}
	if m.transaction_type != nil {
		fields = append(fields, transactiontype.FieldTransactionType)
	}
	if m.description != nil {
		fields = append(fields, transactiontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.CreatedAt()
	case transactiontype.FieldUpdatedAt:
		return m.UpdatedAt()
	case transactiontype.FieldDeletedAt:
		return m.DeletedAt()
	case transactiontype.FieldTransactionType:
		return m.TransactionType()
	case transactiontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transactiontype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transactiontype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case transactiontype.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transactiontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transactiontype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transactiontype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case transactiontype.FieldTransactionType:
		v, ok := value.(transactiontype.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transactiontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactiontype.FieldDeletedAt) {
		fields = append(fields, transactiontype.FieldDeletedAt)
	}
	if m.FieldCleared(transactiontype.FieldDescription) {
		fields = append(fields, transactiontype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ClearField(name string) error {
	switch name {
	case transactiontype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case transactiontype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TransactionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ResetField(name string) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transactiontype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transactiontype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case transactiontype.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transactiontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactiontype.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transactiontype.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case transactiontype.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionTypeMutation) ResetEdge(name string) error {
	switch name {
	case transactiontype.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown TransactionType edge %s", name)
}
