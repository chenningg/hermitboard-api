// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/chenningg/hermitboard-api/auth"
	"github.com/chenningg/hermitboard-api/ent/account"
	"github.com/chenningg/hermitboard-api/ent/asset"
	"github.com/chenningg/hermitboard-api/ent/assetclass"
	"github.com/chenningg/hermitboard-api/ent/authrole"
	"github.com/chenningg/hermitboard-api/ent/blockchain"
	"github.com/chenningg/hermitboard-api/ent/cryptocurrency"
	"github.com/chenningg/hermitboard-api/ent/dailyassetprice"
	"github.com/chenningg/hermitboard-api/ent/exchange"
	"github.com/chenningg/hermitboard-api/ent/portfolio"
	"github.com/chenningg/hermitboard-api/ent/predicate"
	"github.com/chenningg/hermitboard-api/ent/transaction"
	"github.com/chenningg/hermitboard-api/ent/transactiontype"
	"github.com/chenningg/hermitboard-api/hbtype"
	ulid "github.com/oklog/ulid/v2"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount         = "Account"
	TypeAsset           = "Asset"
	TypeAssetClass      = "AssetClass"
	TypeAuthRole        = "AuthRole"
	TypeBlockchain      = "Blockchain"
	TypeCryptocurrency  = "Cryptocurrency"
	TypeDailyAssetPrice = "DailyAssetPrice"
	TypeExchange        = "Exchange"
	TypePortfolio       = "Portfolio"
	TypeTransaction     = "Transaction"
	TypeTransactionType = "TransactionType"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	auth_id             *string
	nickname            *string
	email               *string
	password            *string
	password_updated_at *time.Time
	clearedFields       map[string]struct{}
	auth_roles          map[ulid.ULID]struct{}
	removedauth_roles   map[ulid.ULID]struct{}
	clearedauth_roles   bool
	portfolios          map[ulid.ULID]struct{}
	removedportfolios   map[ulid.ULID]struct{}
	clearedportfolios   bool
	done                bool
	oldValue            func(context.Context) (*Account, error)
	predicates          []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id ulid.ULID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAuthID sets the "auth_id" field.
func (m *AccountMutation) SetAuthID(s string) {
	m.auth_id = &s
}

// AuthID returns the value of the "auth_id" field in the mutation.
func (m *AccountMutation) AuthID() (r string, exists bool) {
	v := m.auth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthID returns the old "auth_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAuthID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthID: %w", err)
	}
	return oldValue.AuthID, nil
}

// ClearAuthID clears the value of the "auth_id" field.
func (m *AccountMutation) ClearAuthID() {
	m.auth_id = nil
	m.clearedFields[account.FieldAuthID] = struct{}{}
}

// AuthIDCleared returns if the "auth_id" field was cleared in this mutation.
func (m *AccountMutation) AuthIDCleared() bool {
	_, ok := m.clearedFields[account.FieldAuthID]
	return ok
}

// ResetAuthID resets all changes to the "auth_id" field.
func (m *AccountMutation) ResetAuthID() {
	m.auth_id = nil
	delete(m.clearedFields, account.FieldAuthID)
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *AccountMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[account.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *AccountMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[account.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, account.FieldPassword)
}

// SetPasswordUpdatedAt sets the "password_updated_at" field.
func (m *AccountMutation) SetPasswordUpdatedAt(t time.Time) {
	m.password_updated_at = &t
}

// PasswordUpdatedAt returns the value of the "password_updated_at" field in the mutation.
func (m *AccountMutation) PasswordUpdatedAt() (r time.Time, exists bool) {
	v := m.password_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordUpdatedAt returns the old "password_updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordUpdatedAt: %w", err)
	}
	return oldValue.PasswordUpdatedAt, nil
}

// ResetPasswordUpdatedAt resets all changes to the "password_updated_at" field.
func (m *AccountMutation) ResetPasswordUpdatedAt() {
	m.password_updated_at = nil
}

// AddAuthRoleIDs adds the "auth_roles" edge to the AuthRole entity by ids.
func (m *AccountMutation) AddAuthRoleIDs(ids ...ulid.ULID) {
	if m.auth_roles == nil {
		m.auth_roles = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.auth_roles[ids[i]] = struct{}{}
	}
}

// ClearAuthRoles clears the "auth_roles" edge to the AuthRole entity.
func (m *AccountMutation) ClearAuthRoles() {
	m.clearedauth_roles = true
}

// AuthRolesCleared reports if the "auth_roles" edge to the AuthRole entity was cleared.
func (m *AccountMutation) AuthRolesCleared() bool {
	return m.clearedauth_roles
}

// RemoveAuthRoleIDs removes the "auth_roles" edge to the AuthRole entity by IDs.
func (m *AccountMutation) RemoveAuthRoleIDs(ids ...ulid.ULID) {
	if m.removedauth_roles == nil {
		m.removedauth_roles = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.auth_roles, ids[i])
		m.removedauth_roles[ids[i]] = struct{}{}
	}
}

// RemovedAuthRoles returns the removed IDs of the "auth_roles" edge to the AuthRole entity.
func (m *AccountMutation) RemovedAuthRolesIDs() (ids []ulid.ULID) {
	for id := range m.removedauth_roles {
		ids = append(ids, id)
	}
	return
}

// AuthRolesIDs returns the "auth_roles" edge IDs in the mutation.
func (m *AccountMutation) AuthRolesIDs() (ids []ulid.ULID) {
	for id := range m.auth_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAuthRoles resets all changes to the "auth_roles" edge.
func (m *AccountMutation) ResetAuthRoles() {
	m.auth_roles = nil
	m.clearedauth_roles = false
	m.removedauth_roles = nil
}

// AddPortfolioIDs adds the "portfolios" edge to the Portfolio entity by ids.
func (m *AccountMutation) AddPortfolioIDs(ids ...ulid.ULID) {
	if m.portfolios == nil {
		m.portfolios = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.portfolios[ids[i]] = struct{}{}
	}
}

// ClearPortfolios clears the "portfolios" edge to the Portfolio entity.
func (m *AccountMutation) ClearPortfolios() {
	m.clearedportfolios = true
}

// PortfoliosCleared reports if the "portfolios" edge to the Portfolio entity was cleared.
func (m *AccountMutation) PortfoliosCleared() bool {
	return m.clearedportfolios
}

// RemovePortfolioIDs removes the "portfolios" edge to the Portfolio entity by IDs.
func (m *AccountMutation) RemovePortfolioIDs(ids ...ulid.ULID) {
	if m.removedportfolios == nil {
		m.removedportfolios = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.portfolios, ids[i])
		m.removedportfolios[ids[i]] = struct{}{}
	}
}

// RemovedPortfolios returns the removed IDs of the "portfolios" edge to the Portfolio entity.
func (m *AccountMutation) RemovedPortfoliosIDs() (ids []ulid.ULID) {
	for id := range m.removedportfolios {
		ids = append(ids, id)
	}
	return
}

// PortfoliosIDs returns the "portfolios" edge IDs in the mutation.
func (m *AccountMutation) PortfoliosIDs() (ids []ulid.ULID) {
	for id := range m.portfolios {
		ids = append(ids, id)
	}
	return
}

// ResetPortfolios resets all changes to the "portfolios" edge.
func (m *AccountMutation) ResetPortfolios() {
	m.portfolios = nil
	m.clearedportfolios = false
	m.removedportfolios = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.auth_id != nil {
		fields = append(fields, account.FieldAuthID)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.password_updated_at != nil {
		fields = append(fields, account.FieldPasswordUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldAuthID:
		return m.AuthID()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldEmail:
		return m.Email()
	case account.FieldPassword:
		return m.Password()
	case account.FieldPasswordUpdatedAt:
		return m.PasswordUpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldAuthID:
		return m.OldAuthID(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldPasswordUpdatedAt:
		return m.OldPasswordUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthID(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldPasswordUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldAuthID) {
		fields = append(fields, account.FieldAuthID)
	}
	if m.FieldCleared(account.FieldPassword) {
		fields = append(fields, account.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldAuthID:
		m.ClearAuthID()
		return nil
	case account.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldAuthID:
		m.ResetAuthID()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldPasswordUpdatedAt:
		m.ResetPasswordUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.auth_roles != nil {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.portfolios != nil {
		edges = append(edges, account.EdgePortfolios)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.auth_roles))
		for id := range m.auth_roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.portfolios))
		for id := range m.portfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedauth_roles != nil {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.removedportfolios != nil {
		edges = append(edges, account.EdgePortfolios)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeAuthRoles:
		ids := make([]ent.Value, 0, len(m.removedauth_roles))
		for id := range m.removedauth_roles {
			ids = append(ids, id)
		}
		return ids
	case account.EdgePortfolios:
		ids := make([]ent.Value, 0, len(m.removedportfolios))
		for id := range m.removedportfolios {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauth_roles {
		edges = append(edges, account.EdgeAuthRoles)
	}
	if m.clearedportfolios {
		edges = append(edges, account.EdgePortfolios)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeAuthRoles:
		return m.clearedauth_roles
	case account.EdgePortfolios:
		return m.clearedportfolios
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeAuthRoles:
		m.ResetAuthRoles()
		return nil
	case account.EdgePortfolios:
		m.ResetPortfolios()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op                       Op
	typ                      string
	id                       *ulid.ULID
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	asset_class              *ulid.ULID
	clearedasset_class       bool
	cryptocurrency           *ulid.ULID
	clearedcryptocurrency    bool
	transaction_base         map[ulid.ULID]struct{}
	removedtransaction_base  map[ulid.ULID]struct{}
	clearedtransaction_base  bool
	transaction_quote        map[ulid.ULID]struct{}
	removedtransaction_quote map[ulid.ULID]struct{}
	clearedtransaction_quote bool
	daily_asset_price        map[ulid.ULID]struct{}
	removeddaily_asset_price map[ulid.ULID]struct{}
	cleareddaily_asset_price bool
	done                     bool
	oldValue                 func(context.Context) (*Asset, error)
	predicates               []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id ulid.ULID) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAssetClassID sets the "asset_class" edge to the AssetClass entity by id.
func (m *AssetMutation) SetAssetClassID(id ulid.ULID) {
	m.asset_class = &id
}

// ClearAssetClass clears the "asset_class" edge to the AssetClass entity.
func (m *AssetMutation) ClearAssetClass() {
	m.clearedasset_class = true
}

// AssetClassCleared reports if the "asset_class" edge to the AssetClass entity was cleared.
func (m *AssetMutation) AssetClassCleared() bool {
	return m.clearedasset_class
}

// AssetClassID returns the "asset_class" edge ID in the mutation.
func (m *AssetMutation) AssetClassID() (id ulid.ULID, exists bool) {
	if m.asset_class != nil {
		return *m.asset_class, true
	}
	return
}

// AssetClassIDs returns the "asset_class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetClassID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) AssetClassIDs() (ids []ulid.ULID) {
	if id := m.asset_class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssetClass resets all changes to the "asset_class" edge.
func (m *AssetMutation) ResetAssetClass() {
	m.asset_class = nil
	m.clearedasset_class = false
}

// SetCryptocurrencyID sets the "cryptocurrency" edge to the Cryptocurrency entity by id.
func (m *AssetMutation) SetCryptocurrencyID(id ulid.ULID) {
	m.cryptocurrency = &id
}

// ClearCryptocurrency clears the "cryptocurrency" edge to the Cryptocurrency entity.
func (m *AssetMutation) ClearCryptocurrency() {
	m.clearedcryptocurrency = true
}

// CryptocurrencyCleared reports if the "cryptocurrency" edge to the Cryptocurrency entity was cleared.
func (m *AssetMutation) CryptocurrencyCleared() bool {
	return m.clearedcryptocurrency
}

// CryptocurrencyID returns the "cryptocurrency" edge ID in the mutation.
func (m *AssetMutation) CryptocurrencyID() (id ulid.ULID, exists bool) {
	if m.cryptocurrency != nil {
		return *m.cryptocurrency, true
	}
	return
}

// CryptocurrencyIDs returns the "cryptocurrency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CryptocurrencyID instead. It exists only for internal usage by the builders.
func (m *AssetMutation) CryptocurrencyIDs() (ids []ulid.ULID) {
	if id := m.cryptocurrency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCryptocurrency resets all changes to the "cryptocurrency" edge.
func (m *AssetMutation) ResetCryptocurrency() {
	m.cryptocurrency = nil
	m.clearedcryptocurrency = false
}

// AddTransactionBaseIDs adds the "transaction_base" edge to the Transaction entity by ids.
func (m *AssetMutation) AddTransactionBaseIDs(ids ...ulid.ULID) {
	if m.transaction_base == nil {
		m.transaction_base = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.transaction_base[ids[i]] = struct{}{}
	}
}

// ClearTransactionBase clears the "transaction_base" edge to the Transaction entity.
func (m *AssetMutation) ClearTransactionBase() {
	m.clearedtransaction_base = true
}

// TransactionBaseCleared reports if the "transaction_base" edge to the Transaction entity was cleared.
func (m *AssetMutation) TransactionBaseCleared() bool {
	return m.clearedtransaction_base
}

// RemoveTransactionBaseIDs removes the "transaction_base" edge to the Transaction entity by IDs.
func (m *AssetMutation) RemoveTransactionBaseIDs(ids ...ulid.ULID) {
	if m.removedtransaction_base == nil {
		m.removedtransaction_base = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.transaction_base, ids[i])
		m.removedtransaction_base[ids[i]] = struct{}{}
	}
}

// RemovedTransactionBase returns the removed IDs of the "transaction_base" edge to the Transaction entity.
func (m *AssetMutation) RemovedTransactionBaseIDs() (ids []ulid.ULID) {
	for id := range m.removedtransaction_base {
		ids = append(ids, id)
	}
	return
}

// TransactionBaseIDs returns the "transaction_base" edge IDs in the mutation.
func (m *AssetMutation) TransactionBaseIDs() (ids []ulid.ULID) {
	for id := range m.transaction_base {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionBase resets all changes to the "transaction_base" edge.
func (m *AssetMutation) ResetTransactionBase() {
	m.transaction_base = nil
	m.clearedtransaction_base = false
	m.removedtransaction_base = nil
}

// AddTransactionQuoteIDs adds the "transaction_quote" edge to the Transaction entity by ids.
func (m *AssetMutation) AddTransactionQuoteIDs(ids ...ulid.ULID) {
	if m.transaction_quote == nil {
		m.transaction_quote = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.transaction_quote[ids[i]] = struct{}{}
	}
}

// ClearTransactionQuote clears the "transaction_quote" edge to the Transaction entity.
func (m *AssetMutation) ClearTransactionQuote() {
	m.clearedtransaction_quote = true
}

// TransactionQuoteCleared reports if the "transaction_quote" edge to the Transaction entity was cleared.
func (m *AssetMutation) TransactionQuoteCleared() bool {
	return m.clearedtransaction_quote
}

// RemoveTransactionQuoteIDs removes the "transaction_quote" edge to the Transaction entity by IDs.
func (m *AssetMutation) RemoveTransactionQuoteIDs(ids ...ulid.ULID) {
	if m.removedtransaction_quote == nil {
		m.removedtransaction_quote = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.transaction_quote, ids[i])
		m.removedtransaction_quote[ids[i]] = struct{}{}
	}
}

// RemovedTransactionQuote returns the removed IDs of the "transaction_quote" edge to the Transaction entity.
func (m *AssetMutation) RemovedTransactionQuoteIDs() (ids []ulid.ULID) {
	for id := range m.removedtransaction_quote {
		ids = append(ids, id)
	}
	return
}

// TransactionQuoteIDs returns the "transaction_quote" edge IDs in the mutation.
func (m *AssetMutation) TransactionQuoteIDs() (ids []ulid.ULID) {
	for id := range m.transaction_quote {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionQuote resets all changes to the "transaction_quote" edge.
func (m *AssetMutation) ResetTransactionQuote() {
	m.transaction_quote = nil
	m.clearedtransaction_quote = false
	m.removedtransaction_quote = nil
}

// AddDailyAssetPriceIDs adds the "daily_asset_price" edge to the DailyAssetPrice entity by ids.
func (m *AssetMutation) AddDailyAssetPriceIDs(ids ...ulid.ULID) {
	if m.daily_asset_price == nil {
		m.daily_asset_price = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.daily_asset_price[ids[i]] = struct{}{}
	}
}

// ClearDailyAssetPrice clears the "daily_asset_price" edge to the DailyAssetPrice entity.
func (m *AssetMutation) ClearDailyAssetPrice() {
	m.cleareddaily_asset_price = true
}

// DailyAssetPriceCleared reports if the "daily_asset_price" edge to the DailyAssetPrice entity was cleared.
func (m *AssetMutation) DailyAssetPriceCleared() bool {
	return m.cleareddaily_asset_price
}

// RemoveDailyAssetPriceIDs removes the "daily_asset_price" edge to the DailyAssetPrice entity by IDs.
func (m *AssetMutation) RemoveDailyAssetPriceIDs(ids ...ulid.ULID) {
	if m.removeddaily_asset_price == nil {
		m.removeddaily_asset_price = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.daily_asset_price, ids[i])
		m.removeddaily_asset_price[ids[i]] = struct{}{}
	}
}

// RemovedDailyAssetPrice returns the removed IDs of the "daily_asset_price" edge to the DailyAssetPrice entity.
func (m *AssetMutation) RemovedDailyAssetPriceIDs() (ids []ulid.ULID) {
	for id := range m.removeddaily_asset_price {
		ids = append(ids, id)
	}
	return
}

// DailyAssetPriceIDs returns the "daily_asset_price" edge IDs in the mutation.
func (m *AssetMutation) DailyAssetPriceIDs() (ids []ulid.ULID) {
	for id := range m.daily_asset_price {
		ids = append(ids, id)
	}
	return
}

// ResetDailyAssetPrice resets all changes to the "daily_asset_price" edge.
func (m *AssetMutation) ResetDailyAssetPrice() {
	m.daily_asset_price = nil
	m.cleareddaily_asset_price = false
	m.removeddaily_asset_price = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.asset_class != nil {
		edges = append(edges, asset.EdgeAssetClass)
	}
	if m.cryptocurrency != nil {
		edges = append(edges, asset.EdgeCryptocurrency)
	}
	if m.transaction_base != nil {
		edges = append(edges, asset.EdgeTransactionBase)
	}
	if m.transaction_quote != nil {
		edges = append(edges, asset.EdgeTransactionQuote)
	}
	if m.daily_asset_price != nil {
		edges = append(edges, asset.EdgeDailyAssetPrice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeAssetClass:
		if id := m.asset_class; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeCryptocurrency:
		if id := m.cryptocurrency; id != nil {
			return []ent.Value{*id}
		}
	case asset.EdgeTransactionBase:
		ids := make([]ent.Value, 0, len(m.transaction_base))
		for id := range m.transaction_base {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTransactionQuote:
		ids := make([]ent.Value, 0, len(m.transaction_quote))
		for id := range m.transaction_quote {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDailyAssetPrice:
		ids := make([]ent.Value, 0, len(m.daily_asset_price))
		for id := range m.daily_asset_price {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtransaction_base != nil {
		edges = append(edges, asset.EdgeTransactionBase)
	}
	if m.removedtransaction_quote != nil {
		edges = append(edges, asset.EdgeTransactionQuote)
	}
	if m.removeddaily_asset_price != nil {
		edges = append(edges, asset.EdgeDailyAssetPrice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case asset.EdgeTransactionBase:
		ids := make([]ent.Value, 0, len(m.removedtransaction_base))
		for id := range m.removedtransaction_base {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeTransactionQuote:
		ids := make([]ent.Value, 0, len(m.removedtransaction_quote))
		for id := range m.removedtransaction_quote {
			ids = append(ids, id)
		}
		return ids
	case asset.EdgeDailyAssetPrice:
		ids := make([]ent.Value, 0, len(m.removeddaily_asset_price))
		for id := range m.removeddaily_asset_price {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedasset_class {
		edges = append(edges, asset.EdgeAssetClass)
	}
	if m.clearedcryptocurrency {
		edges = append(edges, asset.EdgeCryptocurrency)
	}
	if m.clearedtransaction_base {
		edges = append(edges, asset.EdgeTransactionBase)
	}
	if m.clearedtransaction_quote {
		edges = append(edges, asset.EdgeTransactionQuote)
	}
	if m.cleareddaily_asset_price {
		edges = append(edges, asset.EdgeDailyAssetPrice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	switch name {
	case asset.EdgeAssetClass:
		return m.clearedasset_class
	case asset.EdgeCryptocurrency:
		return m.clearedcryptocurrency
	case asset.EdgeTransactionBase:
		return m.clearedtransaction_base
	case asset.EdgeTransactionQuote:
		return m.clearedtransaction_quote
	case asset.EdgeDailyAssetPrice:
		return m.cleareddaily_asset_price
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	switch name {
	case asset.EdgeAssetClass:
		m.ClearAssetClass()
		return nil
	case asset.EdgeCryptocurrency:
		m.ClearCryptocurrency()
		return nil
	}
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	switch name {
	case asset.EdgeAssetClass:
		m.ResetAssetClass()
		return nil
	case asset.EdgeCryptocurrency:
		m.ResetCryptocurrency()
		return nil
	case asset.EdgeTransactionBase:
		m.ResetTransactionBase()
		return nil
	case asset.EdgeTransactionQuote:
		m.ResetTransactionQuote()
		return nil
	case asset.EdgeDailyAssetPrice:
		m.ResetDailyAssetPrice()
		return nil
	}
	return fmt.Errorf("unknown Asset edge %s", name)
}

// AssetClassMutation represents an operation that mutates the AssetClass nodes in the graph.
type AssetClassMutation struct {
	config
	op            Op
	typ           string
	id            *ulid.ULID
	created_at    *time.Time
	updated_at    *time.Time
	class         *hbtype.AssetClass
	description   *string
	clearedFields map[string]struct{}
	assets        map[ulid.ULID]struct{}
	removedassets map[ulid.ULID]struct{}
	clearedassets bool
	done          bool
	oldValue      func(context.Context) (*AssetClass, error)
	predicates    []predicate.AssetClass
}

var _ ent.Mutation = (*AssetClassMutation)(nil)

// assetclassOption allows management of the mutation configuration using functional options.
type assetclassOption func(*AssetClassMutation)

// newAssetClassMutation creates new mutation for the AssetClass entity.
func newAssetClassMutation(c config, op Op, opts ...assetclassOption) *AssetClassMutation {
	m := &AssetClassMutation{
		config:        c,
		op:            op,
		typ:           TypeAssetClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetClassID sets the ID field of the mutation.
func withAssetClassID(id ulid.ULID) assetclassOption {
	return func(m *AssetClassMutation) {
		var (
			err   error
			once  sync.Once
			value *AssetClass
		)
		m.oldValue = func(ctx context.Context) (*AssetClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssetClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssetClass sets the old AssetClass of the mutation.
func withAssetClass(node *AssetClass) assetclassOption {
	return func(m *AssetClassMutation) {
		m.oldValue = func(context.Context) (*AssetClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssetClass entities.
func (m *AssetClassMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetClassMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetClassMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssetClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClass sets the "class" field.
func (m *AssetClassMutation) SetClass(hc hbtype.AssetClass) {
	m.class = &hc
}

// Class returns the value of the "class" field in the mutation.
func (m *AssetClassMutation) Class() (r hbtype.AssetClass, exists bool) {
	v := m.class
	if v == nil {
		return
	}
	return *v, true
}

// OldClass returns the old "class" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldClass(ctx context.Context) (v hbtype.AssetClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClass: %w", err)
	}
	return oldValue.Class, nil
}

// ResetClass resets all changes to the "class" field.
func (m *AssetClassMutation) ResetClass() {
	m.class = nil
}

// SetDescription sets the "description" field.
func (m *AssetClassMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssetClassMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AssetClass entity.
// If the AssetClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetClassMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssetClassMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assetclass.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssetClassMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assetclass.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssetClassMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assetclass.FieldDescription)
}

// AddAssetIDs adds the "assets" edge to the Asset entity by ids.
func (m *AssetClassMutation) AddAssetIDs(ids ...ulid.ULID) {
	if m.assets == nil {
		m.assets = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.assets[ids[i]] = struct{}{}
	}
}

// ClearAssets clears the "assets" edge to the Asset entity.
func (m *AssetClassMutation) ClearAssets() {
	m.clearedassets = true
}

// AssetsCleared reports if the "assets" edge to the Asset entity was cleared.
func (m *AssetClassMutation) AssetsCleared() bool {
	return m.clearedassets
}

// RemoveAssetIDs removes the "assets" edge to the Asset entity by IDs.
func (m *AssetClassMutation) RemoveAssetIDs(ids ...ulid.ULID) {
	if m.removedassets == nil {
		m.removedassets = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.assets, ids[i])
		m.removedassets[ids[i]] = struct{}{}
	}
}

// RemovedAssets returns the removed IDs of the "assets" edge to the Asset entity.
func (m *AssetClassMutation) RemovedAssetsIDs() (ids []ulid.ULID) {
	for id := range m.removedassets {
		ids = append(ids, id)
	}
	return
}

// AssetsIDs returns the "assets" edge IDs in the mutation.
func (m *AssetClassMutation) AssetsIDs() (ids []ulid.ULID) {
	for id := range m.assets {
		ids = append(ids, id)
	}
	return
}

// ResetAssets resets all changes to the "assets" edge.
func (m *AssetClassMutation) ResetAssets() {
	m.assets = nil
	m.clearedassets = false
	m.removedassets = nil
}

// Where appends a list predicates to the AssetClassMutation builder.
func (m *AssetClassMutation) Where(ps ...predicate.AssetClass) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AssetClass).
func (m *AssetClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, assetclass.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assetclass.FieldUpdatedAt)
	}
	if m.class != nil {
		fields = append(fields, assetclass.FieldClass)
	}
	if m.description != nil {
		fields = append(fields, assetclass.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assetclass.FieldCreatedAt:
		return m.CreatedAt()
	case assetclass.FieldUpdatedAt:
		return m.UpdatedAt()
	case assetclass.FieldClass:
		return m.Class()
	case assetclass.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assetclass.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assetclass.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assetclass.FieldClass:
		return m.OldClass(ctx)
	case assetclass.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AssetClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assetclass.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assetclass.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assetclass.FieldClass:
		v, ok := value.(hbtype.AssetClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClass(v)
		return nil
	case assetclass.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AssetClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetClassMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assetclass.FieldDescription) {
		fields = append(fields, assetclass.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetClassMutation) ClearField(name string) error {
	switch name {
	case assetclass.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetClassMutation) ResetField(name string) error {
	switch name {
	case assetclass.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assetclass.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assetclass.FieldClass:
		m.ResetClass()
		return nil
	case assetclass.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AssetClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.assets != nil {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assetclass.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.assets))
		for id := range m.assets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedassets != nil {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assetclass.EdgeAssets:
		ids := make([]ent.Value, 0, len(m.removedassets))
		for id := range m.removedassets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedassets {
		edges = append(edges, assetclass.EdgeAssets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetClassMutation) EdgeCleared(name string) bool {
	switch name {
	case assetclass.EdgeAssets:
		return m.clearedassets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetClassMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AssetClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetClassMutation) ResetEdge(name string) error {
	switch name {
	case assetclass.EdgeAssets:
		m.ResetAssets()
		return nil
	}
	return fmt.Errorf("unknown AssetClass edge %s", name)
}

// AuthRoleMutation represents an operation that mutates the AuthRole nodes in the graph.
type AuthRoleMutation struct {
	config
	op              Op
	typ             string
	id              *ulid.ULID
	created_at      *time.Time
	updated_at      *time.Time
	role            *auth.AuthRole
	description     *string
	clearedFields   map[string]struct{}
	accounts        map[ulid.ULID]struct{}
	removedaccounts map[ulid.ULID]struct{}
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*AuthRole, error)
	predicates      []predicate.AuthRole
}

var _ ent.Mutation = (*AuthRoleMutation)(nil)

// authroleOption allows management of the mutation configuration using functional options.
type authroleOption func(*AuthRoleMutation)

// newAuthRoleMutation creates new mutation for the AuthRole entity.
func newAuthRoleMutation(c config, op Op, opts ...authroleOption) *AuthRoleMutation {
	m := &AuthRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRoleID sets the ID field of the mutation.
func withAuthRoleID(id ulid.ULID) authroleOption {
	return func(m *AuthRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRole
		)
		m.oldValue = func(ctx context.Context) (*AuthRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRole sets the old AuthRole of the mutation.
func withAuthRole(node *AuthRole) authroleOption {
	return func(m *AuthRoleMutation) {
		m.oldValue = func(context.Context) (*AuthRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthRole entities.
func (m *AuthRoleMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRoleMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRoleMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRole sets the "role" field.
func (m *AuthRoleMutation) SetRole(ar auth.AuthRole) {
	m.role = &ar
}

// Role returns the value of the "role" field in the mutation.
func (m *AuthRoleMutation) Role() (r auth.AuthRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldRole(ctx context.Context) (v auth.AuthRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AuthRoleMutation) ResetRole() {
	m.role = nil
}

// SetDescription sets the "description" field.
func (m *AuthRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuthRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuthRole entity.
// If the AuthRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuthRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[authrole.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuthRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[authrole.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuthRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, authrole.FieldDescription)
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *AuthRoleMutation) AddAccountIDs(ids ...ulid.ULID) {
	if m.accounts == nil {
		m.accounts = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *AuthRoleMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *AuthRoleMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *AuthRoleMutation) RemoveAccountIDs(ids ...ulid.ULID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *AuthRoleMutation) RemovedAccountsIDs() (ids []ulid.ULID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *AuthRoleMutation) AccountsIDs() (ids []ulid.ULID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *AuthRoleMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the AuthRoleMutation builder.
func (m *AuthRoleMutation) Where(ps ...predicate.AuthRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRole).
func (m *AuthRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, authrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authrole.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, authrole.FieldRole)
	}
	if m.description != nil {
		fields = append(fields, authrole.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrole.FieldCreatedAt:
		return m.CreatedAt()
	case authrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case authrole.FieldRole:
		return m.Role()
	case authrole.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authrole.FieldRole:
		return m.OldRole(ctx)
	case authrole.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authrole.FieldRole:
		v, ok := value.(auth.AuthRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case authrole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authrole.FieldDescription) {
		fields = append(fields, authrole.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRoleMutation) ClearField(name string) error {
	switch name {
	case authrole.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRoleMutation) ResetField(name string) error {
	switch name {
	case authrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authrole.FieldRole:
		m.ResetRole()
		return nil
	case authrole.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, authrole.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authrole.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedaccounts != nil {
		edges = append(edges, authrole.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authrole.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, authrole.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case authrole.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRoleMutation) ResetEdge(name string) error {
	switch name {
	case authrole.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown AuthRole edge %s", name)
}

// BlockchainMutation represents an operation that mutates the Blockchain nodes in the graph.
type BlockchainMutation struct {
	config
	op                      Op
	typ                     string
	id                      *ulid.ULID
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	symbol                  *string
	icon                    *string
	chain_id                *int64
	addchain_id             *int64
	clearedFields           map[string]struct{}
	cryptocurrencies        map[ulid.ULID]struct{}
	removedcryptocurrencies map[ulid.ULID]struct{}
	clearedcryptocurrencies bool
	done                    bool
	oldValue                func(context.Context) (*Blockchain, error)
	predicates              []predicate.Blockchain
}

var _ ent.Mutation = (*BlockchainMutation)(nil)

// blockchainOption allows management of the mutation configuration using functional options.
type blockchainOption func(*BlockchainMutation)

// newBlockchainMutation creates new mutation for the Blockchain entity.
func newBlockchainMutation(c config, op Op, opts ...blockchainOption) *BlockchainMutation {
	m := &BlockchainMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockchain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockchainID sets the ID field of the mutation.
func withBlockchainID(id ulid.ULID) blockchainOption {
	return func(m *BlockchainMutation) {
		var (
			err   error
			once  sync.Once
			value *Blockchain
		)
		m.oldValue = func(ctx context.Context) (*Blockchain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blockchain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockchain sets the old Blockchain of the mutation.
func withBlockchain(node *Blockchain) blockchainOption {
	return func(m *BlockchainMutation) {
		m.oldValue = func(context.Context) (*Blockchain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockchainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockchainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Blockchain entities.
func (m *BlockchainMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockchainMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockchainMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blockchain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockchainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockchainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockchainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockchainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockchainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockchainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *BlockchainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlockchainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlockchainMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *BlockchainMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *BlockchainMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *BlockchainMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIcon sets the "icon" field.
func (m *BlockchainMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *BlockchainMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *BlockchainMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[blockchain.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *BlockchainMutation) IconCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *BlockchainMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, blockchain.FieldIcon)
}

// SetChainID sets the "chain_id" field.
func (m *BlockchainMutation) SetChainID(i int64) {
	m.chain_id = &i
	m.addchain_id = nil
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *BlockchainMutation) ChainID() (r int64, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Blockchain entity.
// If the Blockchain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockchainMutation) OldChainID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// AddChainID adds i to the "chain_id" field.
func (m *BlockchainMutation) AddChainID(i int64) {
	if m.addchain_id != nil {
		*m.addchain_id += i
	} else {
		m.addchain_id = &i
	}
}

// AddedChainID returns the value that was added to the "chain_id" field in this mutation.
func (m *BlockchainMutation) AddedChainID() (r int64, exists bool) {
	v := m.addchain_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearChainID clears the value of the "chain_id" field.
func (m *BlockchainMutation) ClearChainID() {
	m.chain_id = nil
	m.addchain_id = nil
	m.clearedFields[blockchain.FieldChainID] = struct{}{}
}

// ChainIDCleared returns if the "chain_id" field was cleared in this mutation.
func (m *BlockchainMutation) ChainIDCleared() bool {
	_, ok := m.clearedFields[blockchain.FieldChainID]
	return ok
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *BlockchainMutation) ResetChainID() {
	m.chain_id = nil
	m.addchain_id = nil
	delete(m.clearedFields, blockchain.FieldChainID)
}

// AddCryptocurrencyIDs adds the "cryptocurrencies" edge to the Cryptocurrency entity by ids.
func (m *BlockchainMutation) AddCryptocurrencyIDs(ids ...ulid.ULID) {
	if m.cryptocurrencies == nil {
		m.cryptocurrencies = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.cryptocurrencies[ids[i]] = struct{}{}
	}
}

// ClearCryptocurrencies clears the "cryptocurrencies" edge to the Cryptocurrency entity.
func (m *BlockchainMutation) ClearCryptocurrencies() {
	m.clearedcryptocurrencies = true
}

// CryptocurrenciesCleared reports if the "cryptocurrencies" edge to the Cryptocurrency entity was cleared.
func (m *BlockchainMutation) CryptocurrenciesCleared() bool {
	return m.clearedcryptocurrencies
}

// RemoveCryptocurrencyIDs removes the "cryptocurrencies" edge to the Cryptocurrency entity by IDs.
func (m *BlockchainMutation) RemoveCryptocurrencyIDs(ids ...ulid.ULID) {
	if m.removedcryptocurrencies == nil {
		m.removedcryptocurrencies = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.cryptocurrencies, ids[i])
		m.removedcryptocurrencies[ids[i]] = struct{}{}
	}
}

// RemovedCryptocurrencies returns the removed IDs of the "cryptocurrencies" edge to the Cryptocurrency entity.
func (m *BlockchainMutation) RemovedCryptocurrenciesIDs() (ids []ulid.ULID) {
	for id := range m.removedcryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// CryptocurrenciesIDs returns the "cryptocurrencies" edge IDs in the mutation.
func (m *BlockchainMutation) CryptocurrenciesIDs() (ids []ulid.ULID) {
	for id := range m.cryptocurrencies {
		ids = append(ids, id)
	}
	return
}

// ResetCryptocurrencies resets all changes to the "cryptocurrencies" edge.
func (m *BlockchainMutation) ResetCryptocurrencies() {
	m.cryptocurrencies = nil
	m.clearedcryptocurrencies = false
	m.removedcryptocurrencies = nil
}

// Where appends a list predicates to the BlockchainMutation builder.
func (m *BlockchainMutation) Where(ps ...predicate.Blockchain) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BlockchainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Blockchain).
func (m *BlockchainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockchainMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, blockchain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockchain.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, blockchain.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, blockchain.FieldSymbol)
	}
	if m.icon != nil {
		fields = append(fields, blockchain.FieldIcon)
	}
	if m.chain_id != nil {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockchainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.CreatedAt()
	case blockchain.FieldUpdatedAt:
		return m.UpdatedAt()
	case blockchain.FieldName:
		return m.Name()
	case blockchain.FieldSymbol:
		return m.Symbol()
	case blockchain.FieldIcon:
		return m.Icon()
	case blockchain.FieldChainID:
		return m.ChainID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockchainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockchain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockchain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blockchain.FieldName:
		return m.OldName(ctx)
	case blockchain.FieldSymbol:
		return m.OldSymbol(ctx)
	case blockchain.FieldIcon:
		return m.OldIcon(ctx)
	case blockchain.FieldChainID:
		return m.OldChainID(ctx)
	}
	return nil, fmt.Errorf("unknown Blockchain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockchain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blockchain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blockchain.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case blockchain.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case blockchain.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockchainMutation) AddedFields() []string {
	var fields []string
	if m.addchain_id != nil {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockchainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockchain.FieldChainID:
		return m.AddedChainID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockchainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockchain.FieldChainID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChainID(v)
		return nil
	}
	return fmt.Errorf("unknown Blockchain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockchainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockchain.FieldIcon) {
		fields = append(fields, blockchain.FieldIcon)
	}
	if m.FieldCleared(blockchain.FieldChainID) {
		fields = append(fields, blockchain.FieldChainID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockchainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockchainMutation) ClearField(name string) error {
	switch name {
	case blockchain.FieldIcon:
		m.ClearIcon()
		return nil
	case blockchain.FieldChainID:
		m.ClearChainID()
		return nil
	}
	return fmt.Errorf("unknown Blockchain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockchainMutation) ResetField(name string) error {
	switch name {
	case blockchain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockchain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blockchain.FieldName:
		m.ResetName()
		return nil
	case blockchain.FieldSymbol:
		m.ResetSymbol()
		return nil
	case blockchain.FieldIcon:
		m.ResetIcon()
		return nil
	case blockchain.FieldChainID:
		m.ResetChainID()
		return nil
	}
	return fmt.Errorf("unknown Blockchain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockchainMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockchainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.cryptocurrencies))
		for id := range m.cryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockchainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcryptocurrencies != nil {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockchainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		ids := make([]ent.Value, 0, len(m.removedcryptocurrencies))
		for id := range m.removedcryptocurrencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockchainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcryptocurrencies {
		edges = append(edges, blockchain.EdgeCryptocurrencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockchainMutation) EdgeCleared(name string) bool {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		return m.clearedcryptocurrencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockchainMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Blockchain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockchainMutation) ResetEdge(name string) error {
	switch name {
	case blockchain.EdgeCryptocurrencies:
		m.ResetCryptocurrencies()
		return nil
	}
	return fmt.Errorf("unknown Blockchain edge %s", name)
}

// CryptocurrencyMutation represents an operation that mutates the Cryptocurrency nodes in the graph.
type CryptocurrencyMutation struct {
	config
	op                 Op
	typ                string
	id                 *ulid.ULID
	created_at         *time.Time
	updated_at         *time.Time
	symbol             *string
	icon               *string
	name               *string
	clearedFields      map[string]struct{}
	asset              *ulid.ULID
	clearedasset       bool
	blockchains        map[ulid.ULID]struct{}
	removedblockchains map[ulid.ULID]struct{}
	clearedblockchains bool
	done               bool
	oldValue           func(context.Context) (*Cryptocurrency, error)
	predicates         []predicate.Cryptocurrency
}

var _ ent.Mutation = (*CryptocurrencyMutation)(nil)

// cryptocurrencyOption allows management of the mutation configuration using functional options.
type cryptocurrencyOption func(*CryptocurrencyMutation)

// newCryptocurrencyMutation creates new mutation for the Cryptocurrency entity.
func newCryptocurrencyMutation(c config, op Op, opts ...cryptocurrencyOption) *CryptocurrencyMutation {
	m := &CryptocurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCryptocurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCryptocurrencyID sets the ID field of the mutation.
func withCryptocurrencyID(id ulid.ULID) cryptocurrencyOption {
	return func(m *CryptocurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Cryptocurrency
		)
		m.oldValue = func(ctx context.Context) (*Cryptocurrency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cryptocurrency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCryptocurrency sets the old Cryptocurrency of the mutation.
func withCryptocurrency(node *Cryptocurrency) cryptocurrencyOption {
	return func(m *CryptocurrencyMutation) {
		m.oldValue = func(context.Context) (*Cryptocurrency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CryptocurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CryptocurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cryptocurrency entities.
func (m *CryptocurrencyMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CryptocurrencyMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CryptocurrencyMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cryptocurrency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CryptocurrencyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CryptocurrencyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CryptocurrencyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CryptocurrencyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CryptocurrencyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CryptocurrencyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSymbol sets the "symbol" field.
func (m *CryptocurrencyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *CryptocurrencyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *CryptocurrencyMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIcon sets the "icon" field.
func (m *CryptocurrencyMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *CryptocurrencyMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *CryptocurrencyMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[cryptocurrency.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *CryptocurrencyMutation) IconCleared() bool {
	_, ok := m.clearedFields[cryptocurrency.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *CryptocurrencyMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, cryptocurrency.FieldIcon)
}

// SetName sets the "name" field.
func (m *CryptocurrencyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CryptocurrencyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cryptocurrency entity.
// If the Cryptocurrency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CryptocurrencyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CryptocurrencyMutation) ResetName() {
	m.name = nil
}

// SetAssetID sets the "asset" edge to the Asset entity by id.
func (m *CryptocurrencyMutation) SetAssetID(id ulid.ULID) {
	m.asset = &id
}

// ClearAsset clears the "asset" edge to the Asset entity.
func (m *CryptocurrencyMutation) ClearAsset() {
	m.clearedasset = true
}

// AssetCleared reports if the "asset" edge to the Asset entity was cleared.
func (m *CryptocurrencyMutation) AssetCleared() bool {
	return m.clearedasset
}

// AssetID returns the "asset" edge ID in the mutation.
func (m *CryptocurrencyMutation) AssetID() (id ulid.ULID, exists bool) {
	if m.asset != nil {
		return *m.asset, true
	}
	return
}

// AssetIDs returns the "asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssetID instead. It exists only for internal usage by the builders.
func (m *CryptocurrencyMutation) AssetIDs() (ids []ulid.ULID) {
	if id := m.asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAsset resets all changes to the "asset" edge.
func (m *CryptocurrencyMutation) ResetAsset() {
	m.asset = nil
	m.clearedasset = false
}

// AddBlockchainIDs adds the "blockchains" edge to the Blockchain entity by ids.
func (m *CryptocurrencyMutation) AddBlockchainIDs(ids ...ulid.ULID) {
	if m.blockchains == nil {
		m.blockchains = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.blockchains[ids[i]] = struct{}{}
	}
}

// ClearBlockchains clears the "blockchains" edge to the Blockchain entity.
func (m *CryptocurrencyMutation) ClearBlockchains() {
	m.clearedblockchains = true
}

// BlockchainsCleared reports if the "blockchains" edge to the Blockchain entity was cleared.
func (m *CryptocurrencyMutation) BlockchainsCleared() bool {
	return m.clearedblockchains
}

// RemoveBlockchainIDs removes the "blockchains" edge to the Blockchain entity by IDs.
func (m *CryptocurrencyMutation) RemoveBlockchainIDs(ids ...ulid.ULID) {
	if m.removedblockchains == nil {
		m.removedblockchains = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.blockchains, ids[i])
		m.removedblockchains[ids[i]] = struct{}{}
	}
}

// RemovedBlockchains returns the removed IDs of the "blockchains" edge to the Blockchain entity.
func (m *CryptocurrencyMutation) RemovedBlockchainsIDs() (ids []ulid.ULID) {
	for id := range m.removedblockchains {
		ids = append(ids, id)
	}
	return
}

// BlockchainsIDs returns the "blockchains" edge IDs in the mutation.
func (m *CryptocurrencyMutation) BlockchainsIDs() (ids []ulid.ULID) {
	for id := range m.blockchains {
		ids = append(ids, id)
	}
	return
}

// ResetBlockchains resets all changes to the "blockchains" edge.
func (m *CryptocurrencyMutation) ResetBlockchains() {
	m.blockchains = nil
	m.clearedblockchains = false
	m.removedblockchains = nil
}

// Where appends a list predicates to the CryptocurrencyMutation builder.
func (m *CryptocurrencyMutation) Where(ps ...predicate.Cryptocurrency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CryptocurrencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cryptocurrency).
func (m *CryptocurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CryptocurrencyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, cryptocurrency.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cryptocurrency.FieldUpdatedAt)
	}
	if m.symbol != nil {
		fields = append(fields, cryptocurrency.FieldSymbol)
	}
	if m.icon != nil {
		fields = append(fields, cryptocurrency.FieldIcon)
	}
	if m.name != nil {
		fields = append(fields, cryptocurrency.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CryptocurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		return m.CreatedAt()
	case cryptocurrency.FieldUpdatedAt:
		return m.UpdatedAt()
	case cryptocurrency.FieldSymbol:
		return m.Symbol()
	case cryptocurrency.FieldIcon:
		return m.Icon()
	case cryptocurrency.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CryptocurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cryptocurrency.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cryptocurrency.FieldSymbol:
		return m.OldSymbol(ctx)
	case cryptocurrency.FieldIcon:
		return m.OldIcon(ctx)
	case cryptocurrency.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptocurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cryptocurrency.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cryptocurrency.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case cryptocurrency.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case cryptocurrency.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CryptocurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CryptocurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CryptocurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cryptocurrency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CryptocurrencyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cryptocurrency.FieldIcon) {
		fields = append(fields, cryptocurrency.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CryptocurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CryptocurrencyMutation) ClearField(name string) error {
	switch name {
	case cryptocurrency.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CryptocurrencyMutation) ResetField(name string) error {
	switch name {
	case cryptocurrency.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cryptocurrency.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cryptocurrency.FieldSymbol:
		m.ResetSymbol()
		return nil
	case cryptocurrency.FieldIcon:
		m.ResetIcon()
		return nil
	case cryptocurrency.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CryptocurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.asset != nil {
		edges = append(edges, cryptocurrency.EdgeAsset)
	}
	if m.blockchains != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CryptocurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cryptocurrency.EdgeAsset:
		if id := m.asset; id != nil {
			return []ent.Value{*id}
		}
	case cryptocurrency.EdgeBlockchains:
		ids := make([]ent.Value, 0, len(m.blockchains))
		for id := range m.blockchains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CryptocurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblockchains != nil {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CryptocurrencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cryptocurrency.EdgeBlockchains:
		ids := make([]ent.Value, 0, len(m.removedblockchains))
		for id := range m.removedblockchains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CryptocurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedasset {
		edges = append(edges, cryptocurrency.EdgeAsset)
	}
	if m.clearedblockchains {
		edges = append(edges, cryptocurrency.EdgeBlockchains)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CryptocurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case cryptocurrency.EdgeAsset:
		return m.clearedasset
	case cryptocurrency.EdgeBlockchains:
		return m.clearedblockchains
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CryptocurrencyMutation) ClearEdge(name string) error {
	switch name {
	case cryptocurrency.EdgeAsset:
		m.ClearAsset()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CryptocurrencyMutation) ResetEdge(name string) error {
	switch name {
	case cryptocurrency.EdgeAsset:
		m.ResetAsset()
		return nil
	case cryptocurrency.EdgeBlockchains:
		m.ResetBlockchains()
		return nil
	}
	return fmt.Errorf("unknown Cryptocurrency edge %s", name)
}

// DailyAssetPriceMutation represents an operation that mutates the DailyAssetPrice nodes in the graph.
type DailyAssetPriceMutation struct {
	config
	op                Op
	typ               string
	id                *ulid.ULID
	created_at        *time.Time
	updated_at        *time.Time
	time              *time.Time
	open              *float64
	addopen           *float64
	high              *float64
	addhigh           *float64
	low               *float64
	addlow            *float64
	close             *float64
	addclose          *float64
	adjusted_close    *float64
	addadjusted_close *float64
	clearedFields     map[string]struct{}
	base_asset        *ulid.ULID
	clearedbase_asset bool
	done              bool
	oldValue          func(context.Context) (*DailyAssetPrice, error)
	predicates        []predicate.DailyAssetPrice
}

var _ ent.Mutation = (*DailyAssetPriceMutation)(nil)

// dailyassetpriceOption allows management of the mutation configuration using functional options.
type dailyassetpriceOption func(*DailyAssetPriceMutation)

// newDailyAssetPriceMutation creates new mutation for the DailyAssetPrice entity.
func newDailyAssetPriceMutation(c config, op Op, opts ...dailyassetpriceOption) *DailyAssetPriceMutation {
	m := &DailyAssetPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeDailyAssetPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDailyAssetPriceID sets the ID field of the mutation.
func withDailyAssetPriceID(id ulid.ULID) dailyassetpriceOption {
	return func(m *DailyAssetPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *DailyAssetPrice
		)
		m.oldValue = func(ctx context.Context) (*DailyAssetPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DailyAssetPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDailyAssetPrice sets the old DailyAssetPrice of the mutation.
func withDailyAssetPrice(node *DailyAssetPrice) dailyassetpriceOption {
	return func(m *DailyAssetPriceMutation) {
		m.oldValue = func(context.Context) (*DailyAssetPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DailyAssetPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DailyAssetPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DailyAssetPrice entities.
func (m *DailyAssetPriceMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DailyAssetPriceMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DailyAssetPriceMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DailyAssetPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DailyAssetPriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DailyAssetPriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DailyAssetPriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DailyAssetPriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DailyAssetPriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DailyAssetPriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTime sets the "time" field.
func (m *DailyAssetPriceMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *DailyAssetPriceMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *DailyAssetPriceMutation) ResetTime() {
	m.time = nil
}

// SetOpen sets the "open" field.
func (m *DailyAssetPriceMutation) SetOpen(f float64) {
	m.open = &f
	m.addopen = nil
}

// Open returns the value of the "open" field in the mutation.
func (m *DailyAssetPriceMutation) Open() (r float64, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldOpen(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// AddOpen adds f to the "open" field.
func (m *DailyAssetPriceMutation) AddOpen(f float64) {
	if m.addopen != nil {
		*m.addopen += f
	} else {
		m.addopen = &f
	}
}

// AddedOpen returns the value that was added to the "open" field in this mutation.
func (m *DailyAssetPriceMutation) AddedOpen() (r float64, exists bool) {
	v := m.addopen
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpen clears the value of the "open" field.
func (m *DailyAssetPriceMutation) ClearOpen() {
	m.open = nil
	m.addopen = nil
	m.clearedFields[dailyassetprice.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) OpenCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *DailyAssetPriceMutation) ResetOpen() {
	m.open = nil
	m.addopen = nil
	delete(m.clearedFields, dailyassetprice.FieldOpen)
}

// SetHigh sets the "high" field.
func (m *DailyAssetPriceMutation) SetHigh(f float64) {
	m.high = &f
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *DailyAssetPriceMutation) High() (r float64, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldHigh(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds f to the "high" field.
func (m *DailyAssetPriceMutation) AddHigh(f float64) {
	if m.addhigh != nil {
		*m.addhigh += f
	} else {
		m.addhigh = &f
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *DailyAssetPriceMutation) AddedHigh() (r float64, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ClearHigh clears the value of the "high" field.
func (m *DailyAssetPriceMutation) ClearHigh() {
	m.high = nil
	m.addhigh = nil
	m.clearedFields[dailyassetprice.FieldHigh] = struct{}{}
}

// HighCleared returns if the "high" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) HighCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldHigh]
	return ok
}

// ResetHigh resets all changes to the "high" field.
func (m *DailyAssetPriceMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
	delete(m.clearedFields, dailyassetprice.FieldHigh)
}

// SetLow sets the "low" field.
func (m *DailyAssetPriceMutation) SetLow(f float64) {
	m.low = &f
	m.addlow = nil
}

// Low returns the value of the "low" field in the mutation.
func (m *DailyAssetPriceMutation) Low() (r float64, exists bool) {
	v := m.low
	if v == nil {
		return
	}
	return *v, true
}

// OldLow returns the old "low" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldLow(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLow: %w", err)
	}
	return oldValue.Low, nil
}

// AddLow adds f to the "low" field.
func (m *DailyAssetPriceMutation) AddLow(f float64) {
	if m.addlow != nil {
		*m.addlow += f
	} else {
		m.addlow = &f
	}
}

// AddedLow returns the value that was added to the "low" field in this mutation.
func (m *DailyAssetPriceMutation) AddedLow() (r float64, exists bool) {
	v := m.addlow
	if v == nil {
		return
	}
	return *v, true
}

// ClearLow clears the value of the "low" field.
func (m *DailyAssetPriceMutation) ClearLow() {
	m.low = nil
	m.addlow = nil
	m.clearedFields[dailyassetprice.FieldLow] = struct{}{}
}

// LowCleared returns if the "low" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) LowCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldLow]
	return ok
}

// ResetLow resets all changes to the "low" field.
func (m *DailyAssetPriceMutation) ResetLow() {
	m.low = nil
	m.addlow = nil
	delete(m.clearedFields, dailyassetprice.FieldLow)
}

// SetClose sets the "close" field.
func (m *DailyAssetPriceMutation) SetClose(f float64) {
	m.close = &f
	m.addclose = nil
}

// Close returns the value of the "close" field in the mutation.
func (m *DailyAssetPriceMutation) Close() (r float64, exists bool) {
	v := m.close
	if v == nil {
		return
	}
	return *v, true
}

// OldClose returns the old "close" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldClose(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClose: %w", err)
	}
	return oldValue.Close, nil
}

// AddClose adds f to the "close" field.
func (m *DailyAssetPriceMutation) AddClose(f float64) {
	if m.addclose != nil {
		*m.addclose += f
	} else {
		m.addclose = &f
	}
}

// AddedClose returns the value that was added to the "close" field in this mutation.
func (m *DailyAssetPriceMutation) AddedClose() (r float64, exists bool) {
	v := m.addclose
	if v == nil {
		return
	}
	return *v, true
}

// ClearClose clears the value of the "close" field.
func (m *DailyAssetPriceMutation) ClearClose() {
	m.close = nil
	m.addclose = nil
	m.clearedFields[dailyassetprice.FieldClose] = struct{}{}
}

// CloseCleared returns if the "close" field was cleared in this mutation.
func (m *DailyAssetPriceMutation) CloseCleared() bool {
	_, ok := m.clearedFields[dailyassetprice.FieldClose]
	return ok
}

// ResetClose resets all changes to the "close" field.
func (m *DailyAssetPriceMutation) ResetClose() {
	m.close = nil
	m.addclose = nil
	delete(m.clearedFields, dailyassetprice.FieldClose)
}

// SetAdjustedClose sets the "adjusted_close" field.
func (m *DailyAssetPriceMutation) SetAdjustedClose(f float64) {
	m.adjusted_close = &f
	m.addadjusted_close = nil
}

// AdjustedClose returns the value of the "adjusted_close" field in the mutation.
func (m *DailyAssetPriceMutation) AdjustedClose() (r float64, exists bool) {
	v := m.adjusted_close
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustedClose returns the old "adjusted_close" field's value of the DailyAssetPrice entity.
// If the DailyAssetPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DailyAssetPriceMutation) OldAdjustedClose(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdjustedClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdjustedClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustedClose: %w", err)
	}
	return oldValue.AdjustedClose, nil
}

// AddAdjustedClose adds f to the "adjusted_close" field.
func (m *DailyAssetPriceMutation) AddAdjustedClose(f float64) {
	if m.addadjusted_close != nil {
		*m.addadjusted_close += f
	} else {
		m.addadjusted_close = &f
	}
}

// AddedAdjustedClose returns the value that was added to the "adjusted_close" field in this mutation.
func (m *DailyAssetPriceMutation) AddedAdjustedClose() (r float64, exists bool) {
	v := m.addadjusted_close
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdjustedClose resets all changes to the "adjusted_close" field.
func (m *DailyAssetPriceMutation) ResetAdjustedClose() {
	m.adjusted_close = nil
	m.addadjusted_close = nil
}

// SetBaseAssetID sets the "base_asset" edge to the Asset entity by id.
func (m *DailyAssetPriceMutation) SetBaseAssetID(id ulid.ULID) {
	m.base_asset = &id
}

// ClearBaseAsset clears the "base_asset" edge to the Asset entity.
func (m *DailyAssetPriceMutation) ClearBaseAsset() {
	m.clearedbase_asset = true
}

// BaseAssetCleared reports if the "base_asset" edge to the Asset entity was cleared.
func (m *DailyAssetPriceMutation) BaseAssetCleared() bool {
	return m.clearedbase_asset
}

// BaseAssetID returns the "base_asset" edge ID in the mutation.
func (m *DailyAssetPriceMutation) BaseAssetID() (id ulid.ULID, exists bool) {
	if m.base_asset != nil {
		return *m.base_asset, true
	}
	return
}

// BaseAssetIDs returns the "base_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaseAssetID instead. It exists only for internal usage by the builders.
func (m *DailyAssetPriceMutation) BaseAssetIDs() (ids []ulid.ULID) {
	if id := m.base_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBaseAsset resets all changes to the "base_asset" edge.
func (m *DailyAssetPriceMutation) ResetBaseAsset() {
	m.base_asset = nil
	m.clearedbase_asset = false
}

// Where appends a list predicates to the DailyAssetPriceMutation builder.
func (m *DailyAssetPriceMutation) Where(ps ...predicate.DailyAssetPrice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DailyAssetPriceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DailyAssetPrice).
func (m *DailyAssetPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DailyAssetPriceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dailyassetprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dailyassetprice.FieldUpdatedAt)
	}
	if m.time != nil {
		fields = append(fields, dailyassetprice.FieldTime)
	}
	if m.open != nil {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.high != nil {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.low != nil {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.close != nil {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	if m.adjusted_close != nil {
		fields = append(fields, dailyassetprice.FieldAdjustedClose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DailyAssetPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		return m.CreatedAt()
	case dailyassetprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case dailyassetprice.FieldTime:
		return m.Time()
	case dailyassetprice.FieldOpen:
		return m.Open()
	case dailyassetprice.FieldHigh:
		return m.High()
	case dailyassetprice.FieldLow:
		return m.Low()
	case dailyassetprice.FieldClose:
		return m.Close()
	case dailyassetprice.FieldAdjustedClose:
		return m.AdjustedClose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DailyAssetPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dailyassetprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dailyassetprice.FieldTime:
		return m.OldTime(ctx)
	case dailyassetprice.FieldOpen:
		return m.OldOpen(ctx)
	case dailyassetprice.FieldHigh:
		return m.OldHigh(ctx)
	case dailyassetprice.FieldLow:
		return m.OldLow(ctx)
	case dailyassetprice.FieldClose:
		return m.OldClose(ctx)
	case dailyassetprice.FieldAdjustedClose:
		return m.OldAdjustedClose(ctx)
	}
	return nil, fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyAssetPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dailyassetprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dailyassetprice.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case dailyassetprice.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case dailyassetprice.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case dailyassetprice.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLow(v)
		return nil
	case dailyassetprice.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClose(v)
		return nil
	case dailyassetprice.FieldAdjustedClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustedClose(v)
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DailyAssetPriceMutation) AddedFields() []string {
	var fields []string
	if m.addopen != nil {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.addhigh != nil {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.addlow != nil {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.addclose != nil {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	if m.addadjusted_close != nil {
		fields = append(fields, dailyassetprice.FieldAdjustedClose)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DailyAssetPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dailyassetprice.FieldOpen:
		return m.AddedOpen()
	case dailyassetprice.FieldHigh:
		return m.AddedHigh()
	case dailyassetprice.FieldLow:
		return m.AddedLow()
	case dailyassetprice.FieldClose:
		return m.AddedClose()
	case dailyassetprice.FieldAdjustedClose:
		return m.AddedAdjustedClose()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DailyAssetPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dailyassetprice.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpen(v)
		return nil
	case dailyassetprice.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case dailyassetprice.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLow(v)
		return nil
	case dailyassetprice.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClose(v)
		return nil
	case dailyassetprice.FieldAdjustedClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdjustedClose(v)
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DailyAssetPriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dailyassetprice.FieldOpen) {
		fields = append(fields, dailyassetprice.FieldOpen)
	}
	if m.FieldCleared(dailyassetprice.FieldHigh) {
		fields = append(fields, dailyassetprice.FieldHigh)
	}
	if m.FieldCleared(dailyassetprice.FieldLow) {
		fields = append(fields, dailyassetprice.FieldLow)
	}
	if m.FieldCleared(dailyassetprice.FieldClose) {
		fields = append(fields, dailyassetprice.FieldClose)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DailyAssetPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DailyAssetPriceMutation) ClearField(name string) error {
	switch name {
	case dailyassetprice.FieldOpen:
		m.ClearOpen()
		return nil
	case dailyassetprice.FieldHigh:
		m.ClearHigh()
		return nil
	case dailyassetprice.FieldLow:
		m.ClearLow()
		return nil
	case dailyassetprice.FieldClose:
		m.ClearClose()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DailyAssetPriceMutation) ResetField(name string) error {
	switch name {
	case dailyassetprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dailyassetprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dailyassetprice.FieldTime:
		m.ResetTime()
		return nil
	case dailyassetprice.FieldOpen:
		m.ResetOpen()
		return nil
	case dailyassetprice.FieldHigh:
		m.ResetHigh()
		return nil
	case dailyassetprice.FieldLow:
		m.ResetLow()
		return nil
	case dailyassetprice.FieldClose:
		m.ResetClose()
		return nil
	case dailyassetprice.FieldAdjustedClose:
		m.ResetAdjustedClose()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DailyAssetPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.base_asset != nil {
		edges = append(edges, dailyassetprice.EdgeBaseAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DailyAssetPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		if id := m.base_asset; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DailyAssetPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DailyAssetPriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DailyAssetPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbase_asset {
		edges = append(edges, dailyassetprice.EdgeBaseAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DailyAssetPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		return m.clearedbase_asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DailyAssetPriceMutation) ClearEdge(name string) error {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		m.ClearBaseAsset()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DailyAssetPriceMutation) ResetEdge(name string) error {
	switch name {
	case dailyassetprice.EdgeBaseAsset:
		m.ResetBaseAsset()
		return nil
	}
	return fmt.Errorf("unknown DailyAssetPrice edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	icon                *string
	url                 *string
	clearedFields       map[string]struct{}
	transactions        map[ulid.ULID]struct{}
	removedtransactions map[ulid.ULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Exchange, error)
	predicates          []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id ulid.ULID) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exchange entities.
func (m *ExchangeMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *ExchangeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *ExchangeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *ExchangeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[exchange.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *ExchangeMutation) IconCleared() bool {
	_, ok := m.clearedFields[exchange.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *ExchangeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, exchange.FieldIcon)
}

// SetURL sets the "url" field.
func (m *ExchangeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ExchangeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ExchangeMutation) ClearURL() {
	m.url = nil
	m.clearedFields[exchange.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ExchangeMutation) URLCleared() bool {
	_, ok := m.clearedFields[exchange.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ExchangeMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, exchange.FieldURL)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *ExchangeMutation) AddTransactionIDs(ids ...ulid.ULID) {
	if m.transactions == nil {
		m.transactions = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *ExchangeMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *ExchangeMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *ExchangeMutation) RemoveTransactionIDs(ids ...ulid.ULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *ExchangeMutation) RemovedTransactionsIDs() (ids []ulid.ULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *ExchangeMutation) TransactionsIDs() (ids []ulid.ULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *ExchangeMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, exchange.FieldIcon)
	}
	if m.url != nil {
		fields = append(fields, exchange.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	case exchange.FieldName:
		return m.Name()
	case exchange.FieldIcon:
		return m.Icon()
	case exchange.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exchange.FieldName:
		return m.OldName(ctx)
	case exchange.FieldIcon:
		return m.OldIcon(ctx)
	case exchange.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exchange.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exchange.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case exchange.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldIcon) {
		fields = append(fields, exchange.FieldIcon)
	}
	if m.FieldCleared(exchange.FieldURL) {
		fields = append(fields, exchange.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldIcon:
		m.ClearIcon()
		return nil
	case exchange.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exchange.FieldName:
		m.ResetName()
		return nil
	case exchange.FieldIcon:
		m.ResetIcon()
		return nil
	case exchange.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, exchange.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// PortfolioMutation represents an operation that mutates the Portfolio nodes in the graph.
type PortfolioMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	name                *string
	is_public           *bool
	is_visible          *bool
	clearedFields       map[string]struct{}
	account             *ulid.ULID
	clearedaccount      bool
	transactions        map[ulid.ULID]struct{}
	removedtransactions map[ulid.ULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*Portfolio, error)
	predicates          []predicate.Portfolio
}

var _ ent.Mutation = (*PortfolioMutation)(nil)

// portfolioOption allows management of the mutation configuration using functional options.
type portfolioOption func(*PortfolioMutation)

// newPortfolioMutation creates new mutation for the Portfolio entity.
func newPortfolioMutation(c config, op Op, opts ...portfolioOption) *PortfolioMutation {
	m := &PortfolioMutation{
		config:        c,
		op:            op,
		typ:           TypePortfolio,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPortfolioID sets the ID field of the mutation.
func withPortfolioID(id ulid.ULID) portfolioOption {
	return func(m *PortfolioMutation) {
		var (
			err   error
			once  sync.Once
			value *Portfolio
		)
		m.oldValue = func(ctx context.Context) (*Portfolio, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Portfolio.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPortfolio sets the old Portfolio of the mutation.
func withPortfolio(node *Portfolio) portfolioOption {
	return func(m *PortfolioMutation) {
		m.oldValue = func(context.Context) (*Portfolio, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PortfolioMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PortfolioMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Portfolio entities.
func (m *PortfolioMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PortfolioMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PortfolioMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Portfolio.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PortfolioMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PortfolioMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PortfolioMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PortfolioMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PortfolioMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PortfolioMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PortfolioMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PortfolioMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PortfolioMutation) ResetName() {
	m.name = nil
}

// SetIsPublic sets the "is_public" field.
func (m *PortfolioMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *PortfolioMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *PortfolioMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetIsVisible sets the "is_visible" field.
func (m *PortfolioMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *PortfolioMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the Portfolio entity.
// If the Portfolio object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PortfolioMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *PortfolioMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *PortfolioMutation) SetAccountID(id ulid.ULID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *PortfolioMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *PortfolioMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *PortfolioMutation) AccountID() (id ulid.ULID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *PortfolioMutation) AccountIDs() (ids []ulid.ULID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *PortfolioMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *PortfolioMutation) AddTransactionIDs(ids ...ulid.ULID) {
	if m.transactions == nil {
		m.transactions = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *PortfolioMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *PortfolioMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *PortfolioMutation) RemoveTransactionIDs(ids ...ulid.ULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *PortfolioMutation) RemovedTransactionsIDs() (ids []ulid.ULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PortfolioMutation) TransactionsIDs() (ids []ulid.ULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PortfolioMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the PortfolioMutation builder.
func (m *PortfolioMutation) Where(ps ...predicate.Portfolio) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PortfolioMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Portfolio).
func (m *PortfolioMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PortfolioMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, portfolio.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, portfolio.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, portfolio.FieldName)
	}
	if m.is_public != nil {
		fields = append(fields, portfolio.FieldIsPublic)
	}
	if m.is_visible != nil {
		fields = append(fields, portfolio.FieldIsVisible)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PortfolioMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.CreatedAt()
	case portfolio.FieldUpdatedAt:
		return m.UpdatedAt()
	case portfolio.FieldName:
		return m.Name()
	case portfolio.FieldIsPublic:
		return m.IsPublic()
	case portfolio.FieldIsVisible:
		return m.IsVisible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PortfolioMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portfolio.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case portfolio.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case portfolio.FieldName:
		return m.OldName(ctx)
	case portfolio.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case portfolio.FieldIsVisible:
		return m.OldIsVisible(ctx)
	}
	return nil, fmt.Errorf("unknown Portfolio field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portfolio.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case portfolio.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case portfolio.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portfolio.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case portfolio.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PortfolioMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PortfolioMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PortfolioMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Portfolio numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PortfolioMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PortfolioMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PortfolioMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Portfolio nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PortfolioMutation) ResetField(name string) error {
	switch name {
	case portfolio.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case portfolio.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case portfolio.FieldName:
		m.ResetName()
		return nil
	case portfolio.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case portfolio.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	}
	return fmt.Errorf("unknown Portfolio field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PortfolioMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, portfolio.EdgeAccount)
	}
	if m.transactions != nil {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PortfolioMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case portfolio.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PortfolioMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtransactions != nil {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PortfolioMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case portfolio.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PortfolioMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, portfolio.EdgeAccount)
	}
	if m.clearedtransactions {
		edges = append(edges, portfolio.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PortfolioMutation) EdgeCleared(name string) bool {
	switch name {
	case portfolio.EdgeAccount:
		return m.clearedaccount
	case portfolio.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PortfolioMutation) ClearEdge(name string) error {
	switch name {
	case portfolio.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Portfolio unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PortfolioMutation) ResetEdge(name string) error {
	switch name {
	case portfolio.EdgeAccount:
		m.ResetAccount()
		return nil
	case portfolio.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown Portfolio edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *ulid.ULID
	created_at              *time.Time
	updated_at              *time.Time
	time                    *time.Time
	units                   *int
	addunits                *int
	price_per_unit          *float64
	addprice_per_unit       *float64
	clearedFields           map[string]struct{}
	transaction_type        *ulid.ULID
	clearedtransaction_type bool
	base_asset              map[ulid.ULID]struct{}
	removedbase_asset       map[ulid.ULID]struct{}
	clearedbase_asset       bool
	quote_asset             map[ulid.ULID]struct{}
	removedquote_asset      map[ulid.ULID]struct{}
	clearedquote_asset      bool
	portfolio               *ulid.ULID
	clearedportfolio        bool
	exchange                *ulid.ULID
	clearedexchange         bool
	done                    bool
	oldValue                func(context.Context) (*Transaction, error)
	predicates              []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id ulid.ULID) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTime sets the "time" field.
func (m *TransactionMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *TransactionMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *TransactionMutation) ResetTime() {
	m.time = nil
}

// SetUnits sets the "units" field.
func (m *TransactionMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *TransactionMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *TransactionMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *TransactionMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *TransactionMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetPricePerUnit sets the "price_per_unit" field.
func (m *TransactionMutation) SetPricePerUnit(f float64) {
	m.price_per_unit = &f
	m.addprice_per_unit = nil
}

// PricePerUnit returns the value of the "price_per_unit" field in the mutation.
func (m *TransactionMutation) PricePerUnit() (r float64, exists bool) {
	v := m.price_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePerUnit returns the old "price_per_unit" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldPricePerUnit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePerUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePerUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePerUnit: %w", err)
	}
	return oldValue.PricePerUnit, nil
}

// AddPricePerUnit adds f to the "price_per_unit" field.
func (m *TransactionMutation) AddPricePerUnit(f float64) {
	if m.addprice_per_unit != nil {
		*m.addprice_per_unit += f
	} else {
		m.addprice_per_unit = &f
	}
}

// AddedPricePerUnit returns the value that was added to the "price_per_unit" field in this mutation.
func (m *TransactionMutation) AddedPricePerUnit() (r float64, exists bool) {
	v := m.addprice_per_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetPricePerUnit resets all changes to the "price_per_unit" field.
func (m *TransactionMutation) ResetPricePerUnit() {
	m.price_per_unit = nil
	m.addprice_per_unit = nil
}

// SetTransactionTypeID sets the "transaction_type" edge to the TransactionType entity by id.
func (m *TransactionMutation) SetTransactionTypeID(id ulid.ULID) {
	m.transaction_type = &id
}

// ClearTransactionType clears the "transaction_type" edge to the TransactionType entity.
func (m *TransactionMutation) ClearTransactionType() {
	m.clearedtransaction_type = true
}

// TransactionTypeCleared reports if the "transaction_type" edge to the TransactionType entity was cleared.
func (m *TransactionMutation) TransactionTypeCleared() bool {
	return m.clearedtransaction_type
}

// TransactionTypeID returns the "transaction_type" edge ID in the mutation.
func (m *TransactionMutation) TransactionTypeID() (id ulid.ULID, exists bool) {
	if m.transaction_type != nil {
		return *m.transaction_type, true
	}
	return
}

// TransactionTypeIDs returns the "transaction_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionTypeID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) TransactionTypeIDs() (ids []ulid.ULID) {
	if id := m.transaction_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransactionType resets all changes to the "transaction_type" edge.
func (m *TransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
	m.clearedtransaction_type = false
}

// AddBaseAssetIDs adds the "base_asset" edge to the Asset entity by ids.
func (m *TransactionMutation) AddBaseAssetIDs(ids ...ulid.ULID) {
	if m.base_asset == nil {
		m.base_asset = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.base_asset[ids[i]] = struct{}{}
	}
}

// ClearBaseAsset clears the "base_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearBaseAsset() {
	m.clearedbase_asset = true
}

// BaseAssetCleared reports if the "base_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) BaseAssetCleared() bool {
	return m.clearedbase_asset
}

// RemoveBaseAssetIDs removes the "base_asset" edge to the Asset entity by IDs.
func (m *TransactionMutation) RemoveBaseAssetIDs(ids ...ulid.ULID) {
	if m.removedbase_asset == nil {
		m.removedbase_asset = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.base_asset, ids[i])
		m.removedbase_asset[ids[i]] = struct{}{}
	}
}

// RemovedBaseAsset returns the removed IDs of the "base_asset" edge to the Asset entity.
func (m *TransactionMutation) RemovedBaseAssetIDs() (ids []ulid.ULID) {
	for id := range m.removedbase_asset {
		ids = append(ids, id)
	}
	return
}

// BaseAssetIDs returns the "base_asset" edge IDs in the mutation.
func (m *TransactionMutation) BaseAssetIDs() (ids []ulid.ULID) {
	for id := range m.base_asset {
		ids = append(ids, id)
	}
	return
}

// ResetBaseAsset resets all changes to the "base_asset" edge.
func (m *TransactionMutation) ResetBaseAsset() {
	m.base_asset = nil
	m.clearedbase_asset = false
	m.removedbase_asset = nil
}

// AddQuoteAssetIDs adds the "quote_asset" edge to the Asset entity by ids.
func (m *TransactionMutation) AddQuoteAssetIDs(ids ...ulid.ULID) {
	if m.quote_asset == nil {
		m.quote_asset = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.quote_asset[ids[i]] = struct{}{}
	}
}

// ClearQuoteAsset clears the "quote_asset" edge to the Asset entity.
func (m *TransactionMutation) ClearQuoteAsset() {
	m.clearedquote_asset = true
}

// QuoteAssetCleared reports if the "quote_asset" edge to the Asset entity was cleared.
func (m *TransactionMutation) QuoteAssetCleared() bool {
	return m.clearedquote_asset
}

// RemoveQuoteAssetIDs removes the "quote_asset" edge to the Asset entity by IDs.
func (m *TransactionMutation) RemoveQuoteAssetIDs(ids ...ulid.ULID) {
	if m.removedquote_asset == nil {
		m.removedquote_asset = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.quote_asset, ids[i])
		m.removedquote_asset[ids[i]] = struct{}{}
	}
}

// RemovedQuoteAsset returns the removed IDs of the "quote_asset" edge to the Asset entity.
func (m *TransactionMutation) RemovedQuoteAssetIDs() (ids []ulid.ULID) {
	for id := range m.removedquote_asset {
		ids = append(ids, id)
	}
	return
}

// QuoteAssetIDs returns the "quote_asset" edge IDs in the mutation.
func (m *TransactionMutation) QuoteAssetIDs() (ids []ulid.ULID) {
	for id := range m.quote_asset {
		ids = append(ids, id)
	}
	return
}

// ResetQuoteAsset resets all changes to the "quote_asset" edge.
func (m *TransactionMutation) ResetQuoteAsset() {
	m.quote_asset = nil
	m.clearedquote_asset = false
	m.removedquote_asset = nil
}

// SetPortfolioID sets the "portfolio" edge to the Portfolio entity by id.
func (m *TransactionMutation) SetPortfolioID(id ulid.ULID) {
	m.portfolio = &id
}

// ClearPortfolio clears the "portfolio" edge to the Portfolio entity.
func (m *TransactionMutation) ClearPortfolio() {
	m.clearedportfolio = true
}

// PortfolioCleared reports if the "portfolio" edge to the Portfolio entity was cleared.
func (m *TransactionMutation) PortfolioCleared() bool {
	return m.clearedportfolio
}

// PortfolioID returns the "portfolio" edge ID in the mutation.
func (m *TransactionMutation) PortfolioID() (id ulid.ULID, exists bool) {
	if m.portfolio != nil {
		return *m.portfolio, true
	}
	return
}

// PortfolioIDs returns the "portfolio" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PortfolioID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) PortfolioIDs() (ids []ulid.ULID) {
	if id := m.portfolio; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPortfolio resets all changes to the "portfolio" edge.
func (m *TransactionMutation) ResetPortfolio() {
	m.portfolio = nil
	m.clearedportfolio = false
}

// SetExchangeID sets the "exchange" edge to the Exchange entity by id.
func (m *TransactionMutation) SetExchangeID(id ulid.ULID) {
	m.exchange = &id
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *TransactionMutation) ClearExchange() {
	m.clearedexchange = true
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *TransactionMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeID returns the "exchange" edge ID in the mutation.
func (m *TransactionMutation) ExchangeID() (id ulid.ULID, exists bool) {
	if m.exchange != nil {
		return *m.exchange, true
	}
	return
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) ExchangeIDs() (ids []ulid.ULID) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *TransactionMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	if m.time != nil {
		fields = append(fields, transaction.FieldTime)
	}
	if m.units != nil {
		fields = append(fields, transaction.FieldUnits)
	}
	if m.price_per_unit != nil {
		fields = append(fields, transaction.FieldPricePerUnit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case transaction.FieldTime:
		return m.Time()
	case transaction.FieldUnits:
		return m.Units()
	case transaction.FieldPricePerUnit:
		return m.PricePerUnit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transaction.FieldTime:
		return m.OldTime(ctx)
	case transaction.FieldUnits:
		return m.OldUnits(ctx)
	case transaction.FieldPricePerUnit:
		return m.OldPricePerUnit(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transaction.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case transaction.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case transaction.FieldPricePerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addunits != nil {
		fields = append(fields, transaction.FieldUnits)
	}
	if m.addprice_per_unit != nil {
		fields = append(fields, transaction.FieldPricePerUnit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldUnits:
		return m.AddedUnits()
	case transaction.FieldPricePerUnit:
		return m.AddedPricePerUnit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	case transaction.FieldPricePerUnit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPricePerUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transaction.FieldTime:
		m.ResetTime()
		return nil
	case transaction.FieldUnits:
		m.ResetUnits()
		return nil
	case transaction.FieldPricePerUnit:
		m.ResetPricePerUnit()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.transaction_type != nil {
		edges = append(edges, transaction.EdgeTransactionType)
	}
	if m.base_asset != nil {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.quote_asset != nil {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	if m.portfolio != nil {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.exchange != nil {
		edges = append(edges, transaction.EdgeExchange)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeTransactionType:
		if id := m.transaction_type; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeBaseAsset:
		ids := make([]ent.Value, 0, len(m.base_asset))
		for id := range m.base_asset {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeQuoteAsset:
		ids := make([]ent.Value, 0, len(m.quote_asset))
		for id := range m.quote_asset {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgePortfolio:
		if id := m.portfolio; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedbase_asset != nil {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.removedquote_asset != nil {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeBaseAsset:
		ids := make([]ent.Value, 0, len(m.removedbase_asset))
		for id := range m.removedbase_asset {
			ids = append(ids, id)
		}
		return ids
	case transaction.EdgeQuoteAsset:
		ids := make([]ent.Value, 0, len(m.removedquote_asset))
		for id := range m.removedquote_asset {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtransaction_type {
		edges = append(edges, transaction.EdgeTransactionType)
	}
	if m.clearedbase_asset {
		edges = append(edges, transaction.EdgeBaseAsset)
	}
	if m.clearedquote_asset {
		edges = append(edges, transaction.EdgeQuoteAsset)
	}
	if m.clearedportfolio {
		edges = append(edges, transaction.EdgePortfolio)
	}
	if m.clearedexchange {
		edges = append(edges, transaction.EdgeExchange)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeTransactionType:
		return m.clearedtransaction_type
	case transaction.EdgeBaseAsset:
		return m.clearedbase_asset
	case transaction.EdgeQuoteAsset:
		return m.clearedquote_asset
	case transaction.EdgePortfolio:
		return m.clearedportfolio
	case transaction.EdgeExchange:
		return m.clearedexchange
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeTransactionType:
		m.ClearTransactionType()
		return nil
	case transaction.EdgePortfolio:
		m.ClearPortfolio()
		return nil
	case transaction.EdgeExchange:
		m.ClearExchange()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeTransactionType:
		m.ResetTransactionType()
		return nil
	case transaction.EdgeBaseAsset:
		m.ResetBaseAsset()
		return nil
	case transaction.EdgeQuoteAsset:
		m.ResetQuoteAsset()
		return nil
	case transaction.EdgePortfolio:
		m.ResetPortfolio()
		return nil
	case transaction.EdgeExchange:
		m.ResetExchange()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// TransactionTypeMutation represents an operation that mutates the TransactionType nodes in the graph.
type TransactionTypeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *ulid.ULID
	created_at          *time.Time
	updated_at          *time.Time
	_type               *hbtype.TransactionType
	description         *string
	clearedFields       map[string]struct{}
	transactions        map[ulid.ULID]struct{}
	removedtransactions map[ulid.ULID]struct{}
	clearedtransactions bool
	done                bool
	oldValue            func(context.Context) (*TransactionType, error)
	predicates          []predicate.TransactionType
}

var _ ent.Mutation = (*TransactionTypeMutation)(nil)

// transactiontypeOption allows management of the mutation configuration using functional options.
type transactiontypeOption func(*TransactionTypeMutation)

// newTransactionTypeMutation creates new mutation for the TransactionType entity.
func newTransactionTypeMutation(c config, op Op, opts ...transactiontypeOption) *TransactionTypeMutation {
	m := &TransactionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionTypeID sets the ID field of the mutation.
func withTransactionTypeID(id ulid.ULID) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TransactionType
		)
		m.oldValue = func(ctx context.Context) (*TransactionType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransactionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionType sets the old TransactionType of the mutation.
func withTransactionType(node *TransactionType) transactiontypeOption {
	return func(m *TransactionTypeMutation) {
		m.oldValue = func(context.Context) (*TransactionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransactionType entities.
func (m *TransactionTypeMutation) SetID(id ulid.ULID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionTypeMutation) ID() (id ulid.ULID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionTypeMutation) IDs(ctx context.Context) ([]ulid.ULID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ulid.ULID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransactionType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *TransactionTypeMutation) SetType(ht hbtype.TransactionType) {
	m._type = &ht
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionTypeMutation) GetType() (r hbtype.TransactionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldType(ctx context.Context) (v hbtype.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionTypeMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *TransactionTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TransactionTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TransactionType entity.
// If the TransactionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionTypeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TransactionTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[transactiontype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TransactionTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[transactiontype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TransactionTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, transactiontype.FieldDescription)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *TransactionTypeMutation) AddTransactionIDs(ids ...ulid.ULID) {
	if m.transactions == nil {
		m.transactions = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *TransactionTypeMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *TransactionTypeMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *TransactionTypeMutation) RemoveTransactionIDs(ids ...ulid.ULID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[ulid.ULID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *TransactionTypeMutation) RemovedTransactionsIDs() (ids []ulid.ULID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *TransactionTypeMutation) TransactionsIDs() (ids []ulid.ULID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *TransactionTypeMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// Where appends a list predicates to the TransactionTypeMutation builder.
func (m *TransactionTypeMutation) Where(ps ...predicate.TransactionType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TransactionType).
func (m *TransactionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, transactiontype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transactiontype.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, transactiontype.FieldType)
	}
	if m.description != nil {
		fields = append(fields, transactiontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.CreatedAt()
	case transactiontype.FieldUpdatedAt:
		return m.UpdatedAt()
	case transactiontype.FieldType:
		return m.GetType()
	case transactiontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactiontype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transactiontype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transactiontype.FieldType:
		return m.OldType(ctx)
	case transactiontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown TransactionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transactiontype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transactiontype.FieldType:
		v, ok := value.(hbtype.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transactiontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactiontype.FieldDescription) {
		fields = append(fields, transactiontype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ClearField(name string) error {
	switch name {
	case transactiontype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown TransactionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionTypeMutation) ResetField(name string) error {
	switch name {
	case transactiontype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transactiontype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transactiontype.FieldType:
		m.ResetType()
		return nil
	case transactiontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown TransactionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactions != nil {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactiontype.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactions != nil {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transactiontype.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactions {
		edges = append(edges, transactiontype.EdgeTransactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case transactiontype.EdgeTransactions:
		return m.clearedtransactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TransactionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionTypeMutation) ResetEdge(name string) error {
	switch name {
	case transactiontype.EdgeTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown TransactionType edge %s", name)
}
