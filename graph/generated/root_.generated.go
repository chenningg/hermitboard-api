// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/chenningg/hermitboard-api/ent"
	"github.com/chenningg/hermitboard-api/pulid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		AuthRoles         func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthRoleOrder, where *ent.AuthRoleWhereInput) int
		AuthType          func(childComplexity int) int
		AuthTypeID        func(childComplexity int) int
		Connections       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ConnectionOrder, where *ent.ConnectionWhereInput) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Email             func(childComplexity int) int
		ID                func(childComplexity int) int
		Nickname          func(childComplexity int) int
		Password          func(childComplexity int) int
		PasswordUpdatedAt func(childComplexity int) int
		Portfolios        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PortfolioOrder, where *ent.PortfolioWhereInput) int
		UpdatedAt         func(childComplexity int) int
	}

	AccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Asset struct {
		AssetClass        func(childComplexity int) int
		AssetClassID      func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Cryptocurrency    func(childComplexity int) int
		DailyAssetPrices  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DailyAssetPriceOrder, where *ent.DailyAssetPriceWhereInput) int
		DeletedAt         func(childComplexity int) int
		ID                func(childComplexity int) int
		TransactionBases  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		TransactionQuotes func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt         func(childComplexity int) int
	}

	AssetClass struct {
		Assets      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AssetOrder, where *ent.AssetWhereInput) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	AssetClassConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AssetClassEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AssetConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AssetEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AuthRole struct {
		Accounts      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AccountOrder, where *ent.AccountWhereInput) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		StaffAccounts func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.StaffAccountOrder, where *ent.StaffAccountWhereInput) int
		UpdatedAt     func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	AuthRoleConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AuthRoleEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AuthType struct {
		Accounts      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AccountOrder, where *ent.AccountWhereInput) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		StaffAccounts func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.StaffAccountOrder, where *ent.StaffAccountWhereInput) int
		UpdatedAt     func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	AuthTypeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AuthTypeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Blockchain struct {
		ChainID          func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Cryptocurrencies func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.CryptocurrencyOrder, where *ent.CryptocurrencyWhereInput) int
		DeletedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Icon             func(childComplexity int) int
		Name             func(childComplexity int) int
		Symbol           func(childComplexity int) int
		Transactions     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt        func(childComplexity int) int
	}

	BlockchainConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BlockchainEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Connection struct {
		AccessToken func(childComplexity int) int
		Account     func(childComplexity int) int
		AccountID   func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Portfolios  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PortfolioOrder, where *ent.PortfolioWhereInput) int
		UpdatedAt   func(childComplexity int) int
	}

	ConnectionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConnectionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Cryptocurrency struct {
		Asset       func(childComplexity int) int
		AssetID     func(childComplexity int) int
		Blockchains func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.BlockchainOrder, where *ent.BlockchainWhereInput) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Icon        func(childComplexity int) int
		Name        func(childComplexity int) int
		Symbol      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	CryptocurrencyConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CryptocurrencyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DailyAssetPrice struct {
		AdjustedClose func(childComplexity int) int
		Asset         func(childComplexity int) int
		AssetID       func(childComplexity int) int
		Close         func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		High          func(childComplexity int) int
		ID            func(childComplexity int) int
		Low           func(childComplexity int) int
		Open          func(childComplexity int) int
		Time          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	DailyAssetPriceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DailyAssetPriceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Exchange struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Icon         func(childComplexity int) int
		Name         func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		URL          func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	ExchangeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ExchangeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Portfolio struct {
		Account      func(childComplexity int) int
		AccountID    func(childComplexity int) int
		Connections  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ConnectionOrder, where *ent.ConnectionWhereInput) int
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		IsPublic     func(childComplexity int) int
		IsVisible    func(childComplexity int) int
		Name         func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt    func(childComplexity int) int
	}

	PortfolioConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PortfolioEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		Accounts         func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AccountOrder, where *ent.AccountWhereInput) int
		Assetclasses     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AssetClassOrder, where *ent.AssetClassWhereInput) int
		Assets           func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AssetOrder, where *ent.AssetWhereInput) int
		Authroles        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthRoleOrder, where *ent.AuthRoleWhereInput) int
		Authtypes        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthTypeOrder, where *ent.AuthTypeWhereInput) int
		Blockchains      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.BlockchainOrder, where *ent.BlockchainWhereInput) int
		Connections      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ConnectionOrder, where *ent.ConnectionWhereInput) int
		Cryptocurrencies func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.CryptocurrencyOrder, where *ent.CryptocurrencyWhereInput) int
		Dailyassetprices func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DailyAssetPriceOrder, where *ent.DailyAssetPriceWhereInput) int
		Exchanges        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ExchangeOrder, where *ent.ExchangeWhereInput) int
		Node             func(childComplexity int, id pulid.PULID) int
		Nodes            func(childComplexity int, ids []pulid.PULID) int
		Portfolios       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PortfolioOrder, where *ent.PortfolioWhereInput) int
		Sources          func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SourceOrder, where *ent.SourceWhereInput) int
		Sourcetypes      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SourceTypeOrder, where *ent.SourceTypeWhereInput) int
		Staffaccounts    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.StaffAccountOrder, where *ent.StaffAccountWhereInput) int
		Transactions     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		Transactiontypes func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionTypeOrder, where *ent.TransactionTypeWhereInput) int
	}

	Source struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Icon         func(childComplexity int) int
		Name         func(childComplexity int) int
		SourceType   func(childComplexity int) int
		SourceTypeID func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	SourceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SourceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SourceType struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Sources     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SourceOrder, where *ent.SourceWhereInput) int
		UpdatedAt   func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	SourceTypeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SourceTypeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	StaffAccount struct {
		AuthRoles         func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthRoleOrder, where *ent.AuthRoleWhereInput) int
		AuthType          func(childComplexity int) int
		AuthTypeID        func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Email             func(childComplexity int) int
		ID                func(childComplexity int) int
		Nickname          func(childComplexity int) int
		Password          func(childComplexity int) int
		PasswordUpdatedAt func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	StaffAccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	StaffAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Transaction struct {
		BaseAsset         func(childComplexity int) int
		BaseAssetID       func(childComplexity int) int
		Blockchain        func(childComplexity int) int
		BlockchainID      func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Exchange          func(childComplexity int) int
		ExchangeID        func(childComplexity int) int
		ID                func(childComplexity int) int
		Portfolio         func(childComplexity int) int
		PortfolioID       func(childComplexity int) int
		PricePerUnit      func(childComplexity int) int
		QuoteAsset        func(childComplexity int) int
		QuoteAssetID      func(childComplexity int) int
		Time              func(childComplexity int) int
		TransactionType   func(childComplexity int) int
		TransactionTypeID func(childComplexity int) int
		Units             func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	TransactionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TransactionType struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt    func(childComplexity int) int
		Value        func(childComplexity int) int
	}

	TransactionTypeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionTypeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.authRoles":
		if e.complexity.Account.AuthRoles == nil {
			break
		}

		args, err := ec.field_Account_authRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.AuthRoles(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthRoleOrder), args["where"].(*ent.AuthRoleWhereInput)), true

	case "Account.authType":
		if e.complexity.Account.AuthType == nil {
			break
		}

		return e.complexity.Account.AuthType(childComplexity), true

	case "Account.authTypeID":
		if e.complexity.Account.AuthTypeID == nil {
			break
		}

		return e.complexity.Account.AuthTypeID(childComplexity), true

	case "Account.connections":
		if e.complexity.Account.Connections == nil {
			break
		}

		args, err := ec.field_Account_connections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.Connections(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ConnectionOrder), args["where"].(*ent.ConnectionWhereInput)), true

	case "Account.createdAt":
		if e.complexity.Account.CreatedAt == nil {
			break
		}

		return e.complexity.Account.CreatedAt(childComplexity), true

	case "Account.deletedAt":
		if e.complexity.Account.DeletedAt == nil {
			break
		}

		return e.complexity.Account.DeletedAt(childComplexity), true

	case "Account.email":
		if e.complexity.Account.Email == nil {
			break
		}

		return e.complexity.Account.Email(childComplexity), true

	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true

	case "Account.nickname":
		if e.complexity.Account.Nickname == nil {
			break
		}

		return e.complexity.Account.Nickname(childComplexity), true

	case "Account.password":
		if e.complexity.Account.Password == nil {
			break
		}

		return e.complexity.Account.Password(childComplexity), true

	case "Account.passwordUpdatedAt":
		if e.complexity.Account.PasswordUpdatedAt == nil {
			break
		}

		return e.complexity.Account.PasswordUpdatedAt(childComplexity), true

	case "Account.portfolios":
		if e.complexity.Account.Portfolios == nil {
			break
		}

		args, err := ec.field_Account_portfolios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.Portfolios(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PortfolioOrder), args["where"].(*ent.PortfolioWhereInput)), true

	case "Account.updatedAt":
		if e.complexity.Account.UpdatedAt == nil {
			break
		}

		return e.complexity.Account.UpdatedAt(childComplexity), true

	case "AccountConnection.edges":
		if e.complexity.AccountConnection.Edges == nil {
			break
		}

		return e.complexity.AccountConnection.Edges(childComplexity), true

	case "AccountConnection.pageInfo":
		if e.complexity.AccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.AccountConnection.PageInfo(childComplexity), true

	case "AccountConnection.totalCount":
		if e.complexity.AccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.AccountConnection.TotalCount(childComplexity), true

	case "AccountEdge.cursor":
		if e.complexity.AccountEdge.Cursor == nil {
			break
		}

		return e.complexity.AccountEdge.Cursor(childComplexity), true

	case "AccountEdge.node":
		if e.complexity.AccountEdge.Node == nil {
			break
		}

		return e.complexity.AccountEdge.Node(childComplexity), true

	case "Asset.assetClass":
		if e.complexity.Asset.AssetClass == nil {
			break
		}

		return e.complexity.Asset.AssetClass(childComplexity), true

	case "Asset.assetClassID":
		if e.complexity.Asset.AssetClassID == nil {
			break
		}

		return e.complexity.Asset.AssetClassID(childComplexity), true

	case "Asset.createdAt":
		if e.complexity.Asset.CreatedAt == nil {
			break
		}

		return e.complexity.Asset.CreatedAt(childComplexity), true

	case "Asset.cryptocurrency":
		if e.complexity.Asset.Cryptocurrency == nil {
			break
		}

		return e.complexity.Asset.Cryptocurrency(childComplexity), true

	case "Asset.dailyAssetPrices":
		if e.complexity.Asset.DailyAssetPrices == nil {
			break
		}

		args, err := ec.field_Asset_dailyAssetPrices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.DailyAssetPrices(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DailyAssetPriceOrder), args["where"].(*ent.DailyAssetPriceWhereInput)), true

	case "Asset.deletedAt":
		if e.complexity.Asset.DeletedAt == nil {
			break
		}

		return e.complexity.Asset.DeletedAt(childComplexity), true

	case "Asset.id":
		if e.complexity.Asset.ID == nil {
			break
		}

		return e.complexity.Asset.ID(childComplexity), true

	case "Asset.transactionBases":
		if e.complexity.Asset.TransactionBases == nil {
			break
		}

		args, err := ec.field_Asset_transactionBases_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.TransactionBases(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Asset.transactionQuotes":
		if e.complexity.Asset.TransactionQuotes == nil {
			break
		}

		args, err := ec.field_Asset_transactionQuotes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.TransactionQuotes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Asset.updatedAt":
		if e.complexity.Asset.UpdatedAt == nil {
			break
		}

		return e.complexity.Asset.UpdatedAt(childComplexity), true

	case "AssetClass.assets":
		if e.complexity.AssetClass.Assets == nil {
			break
		}

		args, err := ec.field_AssetClass_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AssetClass.Assets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AssetOrder), args["where"].(*ent.AssetWhereInput)), true

	case "AssetClass.createdAt":
		if e.complexity.AssetClass.CreatedAt == nil {
			break
		}

		return e.complexity.AssetClass.CreatedAt(childComplexity), true

	case "AssetClass.deletedAt":
		if e.complexity.AssetClass.DeletedAt == nil {
			break
		}

		return e.complexity.AssetClass.DeletedAt(childComplexity), true

	case "AssetClass.description":
		if e.complexity.AssetClass.Description == nil {
			break
		}

		return e.complexity.AssetClass.Description(childComplexity), true

	case "AssetClass.id":
		if e.complexity.AssetClass.ID == nil {
			break
		}

		return e.complexity.AssetClass.ID(childComplexity), true

	case "AssetClass.updatedAt":
		if e.complexity.AssetClass.UpdatedAt == nil {
			break
		}

		return e.complexity.AssetClass.UpdatedAt(childComplexity), true

	case "AssetClass.value":
		if e.complexity.AssetClass.Value == nil {
			break
		}

		return e.complexity.AssetClass.Value(childComplexity), true

	case "AssetClassConnection.edges":
		if e.complexity.AssetClassConnection.Edges == nil {
			break
		}

		return e.complexity.AssetClassConnection.Edges(childComplexity), true

	case "AssetClassConnection.pageInfo":
		if e.complexity.AssetClassConnection.PageInfo == nil {
			break
		}

		return e.complexity.AssetClassConnection.PageInfo(childComplexity), true

	case "AssetClassConnection.totalCount":
		if e.complexity.AssetClassConnection.TotalCount == nil {
			break
		}

		return e.complexity.AssetClassConnection.TotalCount(childComplexity), true

	case "AssetClassEdge.cursor":
		if e.complexity.AssetClassEdge.Cursor == nil {
			break
		}

		return e.complexity.AssetClassEdge.Cursor(childComplexity), true

	case "AssetClassEdge.node":
		if e.complexity.AssetClassEdge.Node == nil {
			break
		}

		return e.complexity.AssetClassEdge.Node(childComplexity), true

	case "AssetConnection.edges":
		if e.complexity.AssetConnection.Edges == nil {
			break
		}

		return e.complexity.AssetConnection.Edges(childComplexity), true

	case "AssetConnection.pageInfo":
		if e.complexity.AssetConnection.PageInfo == nil {
			break
		}

		return e.complexity.AssetConnection.PageInfo(childComplexity), true

	case "AssetConnection.totalCount":
		if e.complexity.AssetConnection.TotalCount == nil {
			break
		}

		return e.complexity.AssetConnection.TotalCount(childComplexity), true

	case "AssetEdge.cursor":
		if e.complexity.AssetEdge.Cursor == nil {
			break
		}

		return e.complexity.AssetEdge.Cursor(childComplexity), true

	case "AssetEdge.node":
		if e.complexity.AssetEdge.Node == nil {
			break
		}

		return e.complexity.AssetEdge.Node(childComplexity), true

	case "AuthRole.accounts":
		if e.complexity.AuthRole.Accounts == nil {
			break
		}

		args, err := ec.field_AuthRole_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthRole.Accounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AccountOrder), args["where"].(*ent.AccountWhereInput)), true

	case "AuthRole.createdAt":
		if e.complexity.AuthRole.CreatedAt == nil {
			break
		}

		return e.complexity.AuthRole.CreatedAt(childComplexity), true

	case "AuthRole.deletedAt":
		if e.complexity.AuthRole.DeletedAt == nil {
			break
		}

		return e.complexity.AuthRole.DeletedAt(childComplexity), true

	case "AuthRole.description":
		if e.complexity.AuthRole.Description == nil {
			break
		}

		return e.complexity.AuthRole.Description(childComplexity), true

	case "AuthRole.id":
		if e.complexity.AuthRole.ID == nil {
			break
		}

		return e.complexity.AuthRole.ID(childComplexity), true

	case "AuthRole.staffAccounts":
		if e.complexity.AuthRole.StaffAccounts == nil {
			break
		}

		args, err := ec.field_AuthRole_staffAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthRole.StaffAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.StaffAccountOrder), args["where"].(*ent.StaffAccountWhereInput)), true

	case "AuthRole.updatedAt":
		if e.complexity.AuthRole.UpdatedAt == nil {
			break
		}

		return e.complexity.AuthRole.UpdatedAt(childComplexity), true

	case "AuthRole.value":
		if e.complexity.AuthRole.Value == nil {
			break
		}

		return e.complexity.AuthRole.Value(childComplexity), true

	case "AuthRoleConnection.edges":
		if e.complexity.AuthRoleConnection.Edges == nil {
			break
		}

		return e.complexity.AuthRoleConnection.Edges(childComplexity), true

	case "AuthRoleConnection.pageInfo":
		if e.complexity.AuthRoleConnection.PageInfo == nil {
			break
		}

		return e.complexity.AuthRoleConnection.PageInfo(childComplexity), true

	case "AuthRoleConnection.totalCount":
		if e.complexity.AuthRoleConnection.TotalCount == nil {
			break
		}

		return e.complexity.AuthRoleConnection.TotalCount(childComplexity), true

	case "AuthRoleEdge.cursor":
		if e.complexity.AuthRoleEdge.Cursor == nil {
			break
		}

		return e.complexity.AuthRoleEdge.Cursor(childComplexity), true

	case "AuthRoleEdge.node":
		if e.complexity.AuthRoleEdge.Node == nil {
			break
		}

		return e.complexity.AuthRoleEdge.Node(childComplexity), true

	case "AuthType.accounts":
		if e.complexity.AuthType.Accounts == nil {
			break
		}

		args, err := ec.field_AuthType_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthType.Accounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AccountOrder), args["where"].(*ent.AccountWhereInput)), true

	case "AuthType.createdAt":
		if e.complexity.AuthType.CreatedAt == nil {
			break
		}

		return e.complexity.AuthType.CreatedAt(childComplexity), true

	case "AuthType.deletedAt":
		if e.complexity.AuthType.DeletedAt == nil {
			break
		}

		return e.complexity.AuthType.DeletedAt(childComplexity), true

	case "AuthType.description":
		if e.complexity.AuthType.Description == nil {
			break
		}

		return e.complexity.AuthType.Description(childComplexity), true

	case "AuthType.id":
		if e.complexity.AuthType.ID == nil {
			break
		}

		return e.complexity.AuthType.ID(childComplexity), true

	case "AuthType.staffAccounts":
		if e.complexity.AuthType.StaffAccounts == nil {
			break
		}

		args, err := ec.field_AuthType_staffAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthType.StaffAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.StaffAccountOrder), args["where"].(*ent.StaffAccountWhereInput)), true

	case "AuthType.updatedAt":
		if e.complexity.AuthType.UpdatedAt == nil {
			break
		}

		return e.complexity.AuthType.UpdatedAt(childComplexity), true

	case "AuthType.value":
		if e.complexity.AuthType.Value == nil {
			break
		}

		return e.complexity.AuthType.Value(childComplexity), true

	case "AuthTypeConnection.edges":
		if e.complexity.AuthTypeConnection.Edges == nil {
			break
		}

		return e.complexity.AuthTypeConnection.Edges(childComplexity), true

	case "AuthTypeConnection.pageInfo":
		if e.complexity.AuthTypeConnection.PageInfo == nil {
			break
		}

		return e.complexity.AuthTypeConnection.PageInfo(childComplexity), true

	case "AuthTypeConnection.totalCount":
		if e.complexity.AuthTypeConnection.TotalCount == nil {
			break
		}

		return e.complexity.AuthTypeConnection.TotalCount(childComplexity), true

	case "AuthTypeEdge.cursor":
		if e.complexity.AuthTypeEdge.Cursor == nil {
			break
		}

		return e.complexity.AuthTypeEdge.Cursor(childComplexity), true

	case "AuthTypeEdge.node":
		if e.complexity.AuthTypeEdge.Node == nil {
			break
		}

		return e.complexity.AuthTypeEdge.Node(childComplexity), true

	case "Blockchain.chainID":
		if e.complexity.Blockchain.ChainID == nil {
			break
		}

		return e.complexity.Blockchain.ChainID(childComplexity), true

	case "Blockchain.createdAt":
		if e.complexity.Blockchain.CreatedAt == nil {
			break
		}

		return e.complexity.Blockchain.CreatedAt(childComplexity), true

	case "Blockchain.cryptocurrencies":
		if e.complexity.Blockchain.Cryptocurrencies == nil {
			break
		}

		args, err := ec.field_Blockchain_cryptocurrencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blockchain.Cryptocurrencies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.CryptocurrencyOrder), args["where"].(*ent.CryptocurrencyWhereInput)), true

	case "Blockchain.deletedAt":
		if e.complexity.Blockchain.DeletedAt == nil {
			break
		}

		return e.complexity.Blockchain.DeletedAt(childComplexity), true

	case "Blockchain.id":
		if e.complexity.Blockchain.ID == nil {
			break
		}

		return e.complexity.Blockchain.ID(childComplexity), true

	case "Blockchain.icon":
		if e.complexity.Blockchain.Icon == nil {
			break
		}

		return e.complexity.Blockchain.Icon(childComplexity), true

	case "Blockchain.name":
		if e.complexity.Blockchain.Name == nil {
			break
		}

		return e.complexity.Blockchain.Name(childComplexity), true

	case "Blockchain.symbol":
		if e.complexity.Blockchain.Symbol == nil {
			break
		}

		return e.complexity.Blockchain.Symbol(childComplexity), true

	case "Blockchain.transactions":
		if e.complexity.Blockchain.Transactions == nil {
			break
		}

		args, err := ec.field_Blockchain_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blockchain.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Blockchain.updatedAt":
		if e.complexity.Blockchain.UpdatedAt == nil {
			break
		}

		return e.complexity.Blockchain.UpdatedAt(childComplexity), true

	case "BlockchainConnection.edges":
		if e.complexity.BlockchainConnection.Edges == nil {
			break
		}

		return e.complexity.BlockchainConnection.Edges(childComplexity), true

	case "BlockchainConnection.pageInfo":
		if e.complexity.BlockchainConnection.PageInfo == nil {
			break
		}

		return e.complexity.BlockchainConnection.PageInfo(childComplexity), true

	case "BlockchainConnection.totalCount":
		if e.complexity.BlockchainConnection.TotalCount == nil {
			break
		}

		return e.complexity.BlockchainConnection.TotalCount(childComplexity), true

	case "BlockchainEdge.cursor":
		if e.complexity.BlockchainEdge.Cursor == nil {
			break
		}

		return e.complexity.BlockchainEdge.Cursor(childComplexity), true

	case "BlockchainEdge.node":
		if e.complexity.BlockchainEdge.Node == nil {
			break
		}

		return e.complexity.BlockchainEdge.Node(childComplexity), true

	case "Connection.accessToken":
		if e.complexity.Connection.AccessToken == nil {
			break
		}

		return e.complexity.Connection.AccessToken(childComplexity), true

	case "Connection.account":
		if e.complexity.Connection.Account == nil {
			break
		}

		return e.complexity.Connection.Account(childComplexity), true

	case "Connection.accountID":
		if e.complexity.Connection.AccountID == nil {
			break
		}

		return e.complexity.Connection.AccountID(childComplexity), true

	case "Connection.createdAt":
		if e.complexity.Connection.CreatedAt == nil {
			break
		}

		return e.complexity.Connection.CreatedAt(childComplexity), true

	case "Connection.deletedAt":
		if e.complexity.Connection.DeletedAt == nil {
			break
		}

		return e.complexity.Connection.DeletedAt(childComplexity), true

	case "Connection.id":
		if e.complexity.Connection.ID == nil {
			break
		}

		return e.complexity.Connection.ID(childComplexity), true

	case "Connection.name":
		if e.complexity.Connection.Name == nil {
			break
		}

		return e.complexity.Connection.Name(childComplexity), true

	case "Connection.portfolios":
		if e.complexity.Connection.Portfolios == nil {
			break
		}

		args, err := ec.field_Connection_portfolios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Connection.Portfolios(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PortfolioOrder), args["where"].(*ent.PortfolioWhereInput)), true

	case "Connection.updatedAt":
		if e.complexity.Connection.UpdatedAt == nil {
			break
		}

		return e.complexity.Connection.UpdatedAt(childComplexity), true

	case "ConnectionConnection.edges":
		if e.complexity.ConnectionConnection.Edges == nil {
			break
		}

		return e.complexity.ConnectionConnection.Edges(childComplexity), true

	case "ConnectionConnection.pageInfo":
		if e.complexity.ConnectionConnection.PageInfo == nil {
			break
		}

		return e.complexity.ConnectionConnection.PageInfo(childComplexity), true

	case "ConnectionConnection.totalCount":
		if e.complexity.ConnectionConnection.TotalCount == nil {
			break
		}

		return e.complexity.ConnectionConnection.TotalCount(childComplexity), true

	case "ConnectionEdge.cursor":
		if e.complexity.ConnectionEdge.Cursor == nil {
			break
		}

		return e.complexity.ConnectionEdge.Cursor(childComplexity), true

	case "ConnectionEdge.node":
		if e.complexity.ConnectionEdge.Node == nil {
			break
		}

		return e.complexity.ConnectionEdge.Node(childComplexity), true

	case "Cryptocurrency.asset":
		if e.complexity.Cryptocurrency.Asset == nil {
			break
		}

		return e.complexity.Cryptocurrency.Asset(childComplexity), true

	case "Cryptocurrency.assetID":
		if e.complexity.Cryptocurrency.AssetID == nil {
			break
		}

		return e.complexity.Cryptocurrency.AssetID(childComplexity), true

	case "Cryptocurrency.blockchains":
		if e.complexity.Cryptocurrency.Blockchains == nil {
			break
		}

		args, err := ec.field_Cryptocurrency_blockchains_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Cryptocurrency.Blockchains(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.BlockchainOrder), args["where"].(*ent.BlockchainWhereInput)), true

	case "Cryptocurrency.createdAt":
		if e.complexity.Cryptocurrency.CreatedAt == nil {
			break
		}

		return e.complexity.Cryptocurrency.CreatedAt(childComplexity), true

	case "Cryptocurrency.deletedAt":
		if e.complexity.Cryptocurrency.DeletedAt == nil {
			break
		}

		return e.complexity.Cryptocurrency.DeletedAt(childComplexity), true

	case "Cryptocurrency.id":
		if e.complexity.Cryptocurrency.ID == nil {
			break
		}

		return e.complexity.Cryptocurrency.ID(childComplexity), true

	case "Cryptocurrency.icon":
		if e.complexity.Cryptocurrency.Icon == nil {
			break
		}

		return e.complexity.Cryptocurrency.Icon(childComplexity), true

	case "Cryptocurrency.name":
		if e.complexity.Cryptocurrency.Name == nil {
			break
		}

		return e.complexity.Cryptocurrency.Name(childComplexity), true

	case "Cryptocurrency.symbol":
		if e.complexity.Cryptocurrency.Symbol == nil {
			break
		}

		return e.complexity.Cryptocurrency.Symbol(childComplexity), true

	case "Cryptocurrency.updatedAt":
		if e.complexity.Cryptocurrency.UpdatedAt == nil {
			break
		}

		return e.complexity.Cryptocurrency.UpdatedAt(childComplexity), true

	case "CryptocurrencyConnection.edges":
		if e.complexity.CryptocurrencyConnection.Edges == nil {
			break
		}

		return e.complexity.CryptocurrencyConnection.Edges(childComplexity), true

	case "CryptocurrencyConnection.pageInfo":
		if e.complexity.CryptocurrencyConnection.PageInfo == nil {
			break
		}

		return e.complexity.CryptocurrencyConnection.PageInfo(childComplexity), true

	case "CryptocurrencyConnection.totalCount":
		if e.complexity.CryptocurrencyConnection.TotalCount == nil {
			break
		}

		return e.complexity.CryptocurrencyConnection.TotalCount(childComplexity), true

	case "CryptocurrencyEdge.cursor":
		if e.complexity.CryptocurrencyEdge.Cursor == nil {
			break
		}

		return e.complexity.CryptocurrencyEdge.Cursor(childComplexity), true

	case "CryptocurrencyEdge.node":
		if e.complexity.CryptocurrencyEdge.Node == nil {
			break
		}

		return e.complexity.CryptocurrencyEdge.Node(childComplexity), true

	case "DailyAssetPrice.adjustedClose":
		if e.complexity.DailyAssetPrice.AdjustedClose == nil {
			break
		}

		return e.complexity.DailyAssetPrice.AdjustedClose(childComplexity), true

	case "DailyAssetPrice.asset":
		if e.complexity.DailyAssetPrice.Asset == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Asset(childComplexity), true

	case "DailyAssetPrice.assetID":
		if e.complexity.DailyAssetPrice.AssetID == nil {
			break
		}

		return e.complexity.DailyAssetPrice.AssetID(childComplexity), true

	case "DailyAssetPrice.close":
		if e.complexity.DailyAssetPrice.Close == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Close(childComplexity), true

	case "DailyAssetPrice.createdAt":
		if e.complexity.DailyAssetPrice.CreatedAt == nil {
			break
		}

		return e.complexity.DailyAssetPrice.CreatedAt(childComplexity), true

	case "DailyAssetPrice.deletedAt":
		if e.complexity.DailyAssetPrice.DeletedAt == nil {
			break
		}

		return e.complexity.DailyAssetPrice.DeletedAt(childComplexity), true

	case "DailyAssetPrice.high":
		if e.complexity.DailyAssetPrice.High == nil {
			break
		}

		return e.complexity.DailyAssetPrice.High(childComplexity), true

	case "DailyAssetPrice.id":
		if e.complexity.DailyAssetPrice.ID == nil {
			break
		}

		return e.complexity.DailyAssetPrice.ID(childComplexity), true

	case "DailyAssetPrice.low":
		if e.complexity.DailyAssetPrice.Low == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Low(childComplexity), true

	case "DailyAssetPrice.open":
		if e.complexity.DailyAssetPrice.Open == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Open(childComplexity), true

	case "DailyAssetPrice.time":
		if e.complexity.DailyAssetPrice.Time == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Time(childComplexity), true

	case "DailyAssetPrice.updatedAt":
		if e.complexity.DailyAssetPrice.UpdatedAt == nil {
			break
		}

		return e.complexity.DailyAssetPrice.UpdatedAt(childComplexity), true

	case "DailyAssetPriceConnection.edges":
		if e.complexity.DailyAssetPriceConnection.Edges == nil {
			break
		}

		return e.complexity.DailyAssetPriceConnection.Edges(childComplexity), true

	case "DailyAssetPriceConnection.pageInfo":
		if e.complexity.DailyAssetPriceConnection.PageInfo == nil {
			break
		}

		return e.complexity.DailyAssetPriceConnection.PageInfo(childComplexity), true

	case "DailyAssetPriceConnection.totalCount":
		if e.complexity.DailyAssetPriceConnection.TotalCount == nil {
			break
		}

		return e.complexity.DailyAssetPriceConnection.TotalCount(childComplexity), true

	case "DailyAssetPriceEdge.cursor":
		if e.complexity.DailyAssetPriceEdge.Cursor == nil {
			break
		}

		return e.complexity.DailyAssetPriceEdge.Cursor(childComplexity), true

	case "DailyAssetPriceEdge.node":
		if e.complexity.DailyAssetPriceEdge.Node == nil {
			break
		}

		return e.complexity.DailyAssetPriceEdge.Node(childComplexity), true

	case "Exchange.createdAt":
		if e.complexity.Exchange.CreatedAt == nil {
			break
		}

		return e.complexity.Exchange.CreatedAt(childComplexity), true

	case "Exchange.deletedAt":
		if e.complexity.Exchange.DeletedAt == nil {
			break
		}

		return e.complexity.Exchange.DeletedAt(childComplexity), true

	case "Exchange.id":
		if e.complexity.Exchange.ID == nil {
			break
		}

		return e.complexity.Exchange.ID(childComplexity), true

	case "Exchange.icon":
		if e.complexity.Exchange.Icon == nil {
			break
		}

		return e.complexity.Exchange.Icon(childComplexity), true

	case "Exchange.name":
		if e.complexity.Exchange.Name == nil {
			break
		}

		return e.complexity.Exchange.Name(childComplexity), true

	case "Exchange.transactions":
		if e.complexity.Exchange.Transactions == nil {
			break
		}

		args, err := ec.field_Exchange_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Exchange.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Exchange.url":
		if e.complexity.Exchange.URL == nil {
			break
		}

		return e.complexity.Exchange.URL(childComplexity), true

	case "Exchange.updatedAt":
		if e.complexity.Exchange.UpdatedAt == nil {
			break
		}

		return e.complexity.Exchange.UpdatedAt(childComplexity), true

	case "ExchangeConnection.edges":
		if e.complexity.ExchangeConnection.Edges == nil {
			break
		}

		return e.complexity.ExchangeConnection.Edges(childComplexity), true

	case "ExchangeConnection.pageInfo":
		if e.complexity.ExchangeConnection.PageInfo == nil {
			break
		}

		return e.complexity.ExchangeConnection.PageInfo(childComplexity), true

	case "ExchangeConnection.totalCount":
		if e.complexity.ExchangeConnection.TotalCount == nil {
			break
		}

		return e.complexity.ExchangeConnection.TotalCount(childComplexity), true

	case "ExchangeEdge.cursor":
		if e.complexity.ExchangeEdge.Cursor == nil {
			break
		}

		return e.complexity.ExchangeEdge.Cursor(childComplexity), true

	case "ExchangeEdge.node":
		if e.complexity.ExchangeEdge.Node == nil {
			break
		}

		return e.complexity.ExchangeEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Portfolio.account":
		if e.complexity.Portfolio.Account == nil {
			break
		}

		return e.complexity.Portfolio.Account(childComplexity), true

	case "Portfolio.accountID":
		if e.complexity.Portfolio.AccountID == nil {
			break
		}

		return e.complexity.Portfolio.AccountID(childComplexity), true

	case "Portfolio.connections":
		if e.complexity.Portfolio.Connections == nil {
			break
		}

		args, err := ec.field_Portfolio_connections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Portfolio.Connections(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ConnectionOrder), args["where"].(*ent.ConnectionWhereInput)), true

	case "Portfolio.createdAt":
		if e.complexity.Portfolio.CreatedAt == nil {
			break
		}

		return e.complexity.Portfolio.CreatedAt(childComplexity), true

	case "Portfolio.deletedAt":
		if e.complexity.Portfolio.DeletedAt == nil {
			break
		}

		return e.complexity.Portfolio.DeletedAt(childComplexity), true

	case "Portfolio.id":
		if e.complexity.Portfolio.ID == nil {
			break
		}

		return e.complexity.Portfolio.ID(childComplexity), true

	case "Portfolio.isPublic":
		if e.complexity.Portfolio.IsPublic == nil {
			break
		}

		return e.complexity.Portfolio.IsPublic(childComplexity), true

	case "Portfolio.isVisible":
		if e.complexity.Portfolio.IsVisible == nil {
			break
		}

		return e.complexity.Portfolio.IsVisible(childComplexity), true

	case "Portfolio.name":
		if e.complexity.Portfolio.Name == nil {
			break
		}

		return e.complexity.Portfolio.Name(childComplexity), true

	case "Portfolio.transactions":
		if e.complexity.Portfolio.Transactions == nil {
			break
		}

		args, err := ec.field_Portfolio_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Portfolio.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Portfolio.updatedAt":
		if e.complexity.Portfolio.UpdatedAt == nil {
			break
		}

		return e.complexity.Portfolio.UpdatedAt(childComplexity), true

	case "PortfolioConnection.edges":
		if e.complexity.PortfolioConnection.Edges == nil {
			break
		}

		return e.complexity.PortfolioConnection.Edges(childComplexity), true

	case "PortfolioConnection.pageInfo":
		if e.complexity.PortfolioConnection.PageInfo == nil {
			break
		}

		return e.complexity.PortfolioConnection.PageInfo(childComplexity), true

	case "PortfolioConnection.totalCount":
		if e.complexity.PortfolioConnection.TotalCount == nil {
			break
		}

		return e.complexity.PortfolioConnection.TotalCount(childComplexity), true

	case "PortfolioEdge.cursor":
		if e.complexity.PortfolioEdge.Cursor == nil {
			break
		}

		return e.complexity.PortfolioEdge.Cursor(childComplexity), true

	case "PortfolioEdge.node":
		if e.complexity.PortfolioEdge.Node == nil {
			break
		}

		return e.complexity.PortfolioEdge.Node(childComplexity), true

	case "Query.accounts":
		if e.complexity.Query.Accounts == nil {
			break
		}

		args, err := ec.field_Query_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Accounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AccountOrder), args["where"].(*ent.AccountWhereInput)), true

	case "Query.assetclasses":
		if e.complexity.Query.Assetclasses == nil {
			break
		}

		args, err := ec.field_Query_assetclasses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assetclasses(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AssetClassOrder), args["where"].(*ent.AssetClassWhereInput)), true

	case "Query.assets":
		if e.complexity.Query.Assets == nil {
			break
		}

		args, err := ec.field_Query_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AssetOrder), args["where"].(*ent.AssetWhereInput)), true

	case "Query.authroles":
		if e.complexity.Query.Authroles == nil {
			break
		}

		args, err := ec.field_Query_authroles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Authroles(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthRoleOrder), args["where"].(*ent.AuthRoleWhereInput)), true

	case "Query.authtypes":
		if e.complexity.Query.Authtypes == nil {
			break
		}

		args, err := ec.field_Query_authtypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Authtypes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthTypeOrder), args["where"].(*ent.AuthTypeWhereInput)), true

	case "Query.blockchains":
		if e.complexity.Query.Blockchains == nil {
			break
		}

		args, err := ec.field_Query_blockchains_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blockchains(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.BlockchainOrder), args["where"].(*ent.BlockchainWhereInput)), true

	case "Query.connections":
		if e.complexity.Query.Connections == nil {
			break
		}

		args, err := ec.field_Query_connections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Connections(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ConnectionOrder), args["where"].(*ent.ConnectionWhereInput)), true

	case "Query.cryptocurrencies":
		if e.complexity.Query.Cryptocurrencies == nil {
			break
		}

		args, err := ec.field_Query_cryptocurrencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cryptocurrencies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.CryptocurrencyOrder), args["where"].(*ent.CryptocurrencyWhereInput)), true

	case "Query.dailyassetprices":
		if e.complexity.Query.Dailyassetprices == nil {
			break
		}

		args, err := ec.field_Query_dailyassetprices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Dailyassetprices(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DailyAssetPriceOrder), args["where"].(*ent.DailyAssetPriceWhereInput)), true

	case "Query.exchanges":
		if e.complexity.Query.Exchanges == nil {
			break
		}

		args, err := ec.field_Query_exchanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Exchanges(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ExchangeOrder), args["where"].(*ent.ExchangeWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(pulid.PULID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]pulid.PULID)), true

	case "Query.portfolios":
		if e.complexity.Query.Portfolios == nil {
			break
		}

		args, err := ec.field_Query_portfolios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Portfolios(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PortfolioOrder), args["where"].(*ent.PortfolioWhereInput)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SourceOrder), args["where"].(*ent.SourceWhereInput)), true

	case "Query.sourcetypes":
		if e.complexity.Query.Sourcetypes == nil {
			break
		}

		args, err := ec.field_Query_sourcetypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sourcetypes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SourceTypeOrder), args["where"].(*ent.SourceTypeWhereInput)), true

	case "Query.staffaccounts":
		if e.complexity.Query.Staffaccounts == nil {
			break
		}

		args, err := ec.field_Query_staffaccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Staffaccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.StaffAccountOrder), args["where"].(*ent.StaffAccountWhereInput)), true

	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Query.transactiontypes":
		if e.complexity.Query.Transactiontypes == nil {
			break
		}

		args, err := ec.field_Query_transactiontypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactiontypes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionTypeOrder), args["where"].(*ent.TransactionTypeWhereInput)), true

	case "Source.createdAt":
		if e.complexity.Source.CreatedAt == nil {
			break
		}

		return e.complexity.Source.CreatedAt(childComplexity), true

	case "Source.deletedAt":
		if e.complexity.Source.DeletedAt == nil {
			break
		}

		return e.complexity.Source.DeletedAt(childComplexity), true

	case "Source.id":
		if e.complexity.Source.ID == nil {
			break
		}

		return e.complexity.Source.ID(childComplexity), true

	case "Source.icon":
		if e.complexity.Source.Icon == nil {
			break
		}

		return e.complexity.Source.Icon(childComplexity), true

	case "Source.name":
		if e.complexity.Source.Name == nil {
			break
		}

		return e.complexity.Source.Name(childComplexity), true

	case "Source.sourceType":
		if e.complexity.Source.SourceType == nil {
			break
		}

		return e.complexity.Source.SourceType(childComplexity), true

	case "Source.sourceTypeID":
		if e.complexity.Source.SourceTypeID == nil {
			break
		}

		return e.complexity.Source.SourceTypeID(childComplexity), true

	case "Source.updatedAt":
		if e.complexity.Source.UpdatedAt == nil {
			break
		}

		return e.complexity.Source.UpdatedAt(childComplexity), true

	case "SourceConnection.edges":
		if e.complexity.SourceConnection.Edges == nil {
			break
		}

		return e.complexity.SourceConnection.Edges(childComplexity), true

	case "SourceConnection.pageInfo":
		if e.complexity.SourceConnection.PageInfo == nil {
			break
		}

		return e.complexity.SourceConnection.PageInfo(childComplexity), true

	case "SourceConnection.totalCount":
		if e.complexity.SourceConnection.TotalCount == nil {
			break
		}

		return e.complexity.SourceConnection.TotalCount(childComplexity), true

	case "SourceEdge.cursor":
		if e.complexity.SourceEdge.Cursor == nil {
			break
		}

		return e.complexity.SourceEdge.Cursor(childComplexity), true

	case "SourceEdge.node":
		if e.complexity.SourceEdge.Node == nil {
			break
		}

		return e.complexity.SourceEdge.Node(childComplexity), true

	case "SourceType.createdAt":
		if e.complexity.SourceType.CreatedAt == nil {
			break
		}

		return e.complexity.SourceType.CreatedAt(childComplexity), true

	case "SourceType.deletedAt":
		if e.complexity.SourceType.DeletedAt == nil {
			break
		}

		return e.complexity.SourceType.DeletedAt(childComplexity), true

	case "SourceType.description":
		if e.complexity.SourceType.Description == nil {
			break
		}

		return e.complexity.SourceType.Description(childComplexity), true

	case "SourceType.id":
		if e.complexity.SourceType.ID == nil {
			break
		}

		return e.complexity.SourceType.ID(childComplexity), true

	case "SourceType.sources":
		if e.complexity.SourceType.Sources == nil {
			break
		}

		args, err := ec.field_SourceType_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SourceType.Sources(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SourceOrder), args["where"].(*ent.SourceWhereInput)), true

	case "SourceType.updatedAt":
		if e.complexity.SourceType.UpdatedAt == nil {
			break
		}

		return e.complexity.SourceType.UpdatedAt(childComplexity), true

	case "SourceType.value":
		if e.complexity.SourceType.Value == nil {
			break
		}

		return e.complexity.SourceType.Value(childComplexity), true

	case "SourceTypeConnection.edges":
		if e.complexity.SourceTypeConnection.Edges == nil {
			break
		}

		return e.complexity.SourceTypeConnection.Edges(childComplexity), true

	case "SourceTypeConnection.pageInfo":
		if e.complexity.SourceTypeConnection.PageInfo == nil {
			break
		}

		return e.complexity.SourceTypeConnection.PageInfo(childComplexity), true

	case "SourceTypeConnection.totalCount":
		if e.complexity.SourceTypeConnection.TotalCount == nil {
			break
		}

		return e.complexity.SourceTypeConnection.TotalCount(childComplexity), true

	case "SourceTypeEdge.cursor":
		if e.complexity.SourceTypeEdge.Cursor == nil {
			break
		}

		return e.complexity.SourceTypeEdge.Cursor(childComplexity), true

	case "SourceTypeEdge.node":
		if e.complexity.SourceTypeEdge.Node == nil {
			break
		}

		return e.complexity.SourceTypeEdge.Node(childComplexity), true

	case "StaffAccount.authRoles":
		if e.complexity.StaffAccount.AuthRoles == nil {
			break
		}

		args, err := ec.field_StaffAccount_authRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.StaffAccount.AuthRoles(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthRoleOrder), args["where"].(*ent.AuthRoleWhereInput)), true

	case "StaffAccount.authType":
		if e.complexity.StaffAccount.AuthType == nil {
			break
		}

		return e.complexity.StaffAccount.AuthType(childComplexity), true

	case "StaffAccount.authTypeID":
		if e.complexity.StaffAccount.AuthTypeID == nil {
			break
		}

		return e.complexity.StaffAccount.AuthTypeID(childComplexity), true

	case "StaffAccount.createdAt":
		if e.complexity.StaffAccount.CreatedAt == nil {
			break
		}

		return e.complexity.StaffAccount.CreatedAt(childComplexity), true

	case "StaffAccount.deletedAt":
		if e.complexity.StaffAccount.DeletedAt == nil {
			break
		}

		return e.complexity.StaffAccount.DeletedAt(childComplexity), true

	case "StaffAccount.email":
		if e.complexity.StaffAccount.Email == nil {
			break
		}

		return e.complexity.StaffAccount.Email(childComplexity), true

	case "StaffAccount.id":
		if e.complexity.StaffAccount.ID == nil {
			break
		}

		return e.complexity.StaffAccount.ID(childComplexity), true

	case "StaffAccount.nickname":
		if e.complexity.StaffAccount.Nickname == nil {
			break
		}

		return e.complexity.StaffAccount.Nickname(childComplexity), true

	case "StaffAccount.password":
		if e.complexity.StaffAccount.Password == nil {
			break
		}

		return e.complexity.StaffAccount.Password(childComplexity), true

	case "StaffAccount.passwordUpdatedAt":
		if e.complexity.StaffAccount.PasswordUpdatedAt == nil {
			break
		}

		return e.complexity.StaffAccount.PasswordUpdatedAt(childComplexity), true

	case "StaffAccount.updatedAt":
		if e.complexity.StaffAccount.UpdatedAt == nil {
			break
		}

		return e.complexity.StaffAccount.UpdatedAt(childComplexity), true

	case "StaffAccountConnection.edges":
		if e.complexity.StaffAccountConnection.Edges == nil {
			break
		}

		return e.complexity.StaffAccountConnection.Edges(childComplexity), true

	case "StaffAccountConnection.pageInfo":
		if e.complexity.StaffAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.StaffAccountConnection.PageInfo(childComplexity), true

	case "StaffAccountConnection.totalCount":
		if e.complexity.StaffAccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.StaffAccountConnection.TotalCount(childComplexity), true

	case "StaffAccountEdge.cursor":
		if e.complexity.StaffAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.StaffAccountEdge.Cursor(childComplexity), true

	case "StaffAccountEdge.node":
		if e.complexity.StaffAccountEdge.Node == nil {
			break
		}

		return e.complexity.StaffAccountEdge.Node(childComplexity), true

	case "Transaction.baseAsset":
		if e.complexity.Transaction.BaseAsset == nil {
			break
		}

		return e.complexity.Transaction.BaseAsset(childComplexity), true

	case "Transaction.baseAssetID":
		if e.complexity.Transaction.BaseAssetID == nil {
			break
		}

		return e.complexity.Transaction.BaseAssetID(childComplexity), true

	case "Transaction.blockchain":
		if e.complexity.Transaction.Blockchain == nil {
			break
		}

		return e.complexity.Transaction.Blockchain(childComplexity), true

	case "Transaction.blockchainID":
		if e.complexity.Transaction.BlockchainID == nil {
			break
		}

		return e.complexity.Transaction.BlockchainID(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.deletedAt":
		if e.complexity.Transaction.DeletedAt == nil {
			break
		}

		return e.complexity.Transaction.DeletedAt(childComplexity), true

	case "Transaction.exchange":
		if e.complexity.Transaction.Exchange == nil {
			break
		}

		return e.complexity.Transaction.Exchange(childComplexity), true

	case "Transaction.exchangeID":
		if e.complexity.Transaction.ExchangeID == nil {
			break
		}

		return e.complexity.Transaction.ExchangeID(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.portfolio":
		if e.complexity.Transaction.Portfolio == nil {
			break
		}

		return e.complexity.Transaction.Portfolio(childComplexity), true

	case "Transaction.portfolioID":
		if e.complexity.Transaction.PortfolioID == nil {
			break
		}

		return e.complexity.Transaction.PortfolioID(childComplexity), true

	case "Transaction.pricePerUnit":
		if e.complexity.Transaction.PricePerUnit == nil {
			break
		}

		return e.complexity.Transaction.PricePerUnit(childComplexity), true

	case "Transaction.quoteAsset":
		if e.complexity.Transaction.QuoteAsset == nil {
			break
		}

		return e.complexity.Transaction.QuoteAsset(childComplexity), true

	case "Transaction.quoteAssetID":
		if e.complexity.Transaction.QuoteAssetID == nil {
			break
		}

		return e.complexity.Transaction.QuoteAssetID(childComplexity), true

	case "Transaction.time":
		if e.complexity.Transaction.Time == nil {
			break
		}

		return e.complexity.Transaction.Time(childComplexity), true

	case "Transaction.transactionType":
		if e.complexity.Transaction.TransactionType == nil {
			break
		}

		return e.complexity.Transaction.TransactionType(childComplexity), true

	case "Transaction.transactionTypeID":
		if e.complexity.Transaction.TransactionTypeID == nil {
			break
		}

		return e.complexity.Transaction.TransactionTypeID(childComplexity), true

	case "Transaction.units":
		if e.complexity.Transaction.Units == nil {
			break
		}

		return e.complexity.Transaction.Units(childComplexity), true

	case "Transaction.updatedAt":
		if e.complexity.Transaction.UpdatedAt == nil {
			break
		}

		return e.complexity.Transaction.UpdatedAt(childComplexity), true

	case "TransactionConnection.edges":
		if e.complexity.TransactionConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionConnection.Edges(childComplexity), true

	case "TransactionConnection.pageInfo":
		if e.complexity.TransactionConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionConnection.PageInfo(childComplexity), true

	case "TransactionConnection.totalCount":
		if e.complexity.TransactionConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionConnection.TotalCount(childComplexity), true

	case "TransactionEdge.cursor":
		if e.complexity.TransactionEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionEdge.Cursor(childComplexity), true

	case "TransactionEdge.node":
		if e.complexity.TransactionEdge.Node == nil {
			break
		}

		return e.complexity.TransactionEdge.Node(childComplexity), true

	case "TransactionType.createdAt":
		if e.complexity.TransactionType.CreatedAt == nil {
			break
		}

		return e.complexity.TransactionType.CreatedAt(childComplexity), true

	case "TransactionType.deletedAt":
		if e.complexity.TransactionType.DeletedAt == nil {
			break
		}

		return e.complexity.TransactionType.DeletedAt(childComplexity), true

	case "TransactionType.description":
		if e.complexity.TransactionType.Description == nil {
			break
		}

		return e.complexity.TransactionType.Description(childComplexity), true

	case "TransactionType.id":
		if e.complexity.TransactionType.ID == nil {
			break
		}

		return e.complexity.TransactionType.ID(childComplexity), true

	case "TransactionType.transactions":
		if e.complexity.TransactionType.Transactions == nil {
			break
		}

		args, err := ec.field_TransactionType_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TransactionType.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "TransactionType.updatedAt":
		if e.complexity.TransactionType.UpdatedAt == nil {
			break
		}

		return e.complexity.TransactionType.UpdatedAt(childComplexity), true

	case "TransactionType.value":
		if e.complexity.TransactionType.Value == nil {
			break
		}

		return e.complexity.TransactionType.Value(childComplexity), true

	case "TransactionTypeConnection.edges":
		if e.complexity.TransactionTypeConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionTypeConnection.Edges(childComplexity), true

	case "TransactionTypeConnection.pageInfo":
		if e.complexity.TransactionTypeConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionTypeConnection.PageInfo(childComplexity), true

	case "TransactionTypeConnection.totalCount":
		if e.complexity.TransactionTypeConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionTypeConnection.TotalCount(childComplexity), true

	case "TransactionTypeEdge.cursor":
		if e.complexity.TransactionTypeEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionTypeEdge.Cursor(childComplexity), true

	case "TransactionTypeEdge.node":
		if e.complexity.TransactionTypeEdge.Node == nil {
			break
		}

		return e.complexity.TransactionTypeEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccountOrder,
		ec.unmarshalInputAccountWhereInput,
		ec.unmarshalInputAssetClassOrder,
		ec.unmarshalInputAssetClassWhereInput,
		ec.unmarshalInputAssetOrder,
		ec.unmarshalInputAssetWhereInput,
		ec.unmarshalInputAuthRoleOrder,
		ec.unmarshalInputAuthRoleWhereInput,
		ec.unmarshalInputAuthTypeOrder,
		ec.unmarshalInputAuthTypeWhereInput,
		ec.unmarshalInputBlockchainOrder,
		ec.unmarshalInputBlockchainWhereInput,
		ec.unmarshalInputConnectionOrder,
		ec.unmarshalInputConnectionWhereInput,
		ec.unmarshalInputCreateAccountInput,
		ec.unmarshalInputCreateAssetClassInput,
		ec.unmarshalInputCreateAssetInput,
		ec.unmarshalInputCreateAuthRoleInput,
		ec.unmarshalInputCreateAuthTypeInput,
		ec.unmarshalInputCreateBlockchainInput,
		ec.unmarshalInputCreateConnectionInput,
		ec.unmarshalInputCreateCryptocurrencyInput,
		ec.unmarshalInputCreateDailyAssetPriceInput,
		ec.unmarshalInputCreateExchangeInput,
		ec.unmarshalInputCreatePortfolioInput,
		ec.unmarshalInputCreateSourceInput,
		ec.unmarshalInputCreateSourceTypeInput,
		ec.unmarshalInputCreateStaffAccountInput,
		ec.unmarshalInputCreateTransactionInput,
		ec.unmarshalInputCreateTransactionTypeInput,
		ec.unmarshalInputCryptocurrencyOrder,
		ec.unmarshalInputCryptocurrencyWhereInput,
		ec.unmarshalInputDailyAssetPriceOrder,
		ec.unmarshalInputDailyAssetPriceWhereInput,
		ec.unmarshalInputExchangeOrder,
		ec.unmarshalInputExchangeWhereInput,
		ec.unmarshalInputPortfolioOrder,
		ec.unmarshalInputPortfolioWhereInput,
		ec.unmarshalInputSourceOrder,
		ec.unmarshalInputSourceTypeOrder,
		ec.unmarshalInputSourceTypeWhereInput,
		ec.unmarshalInputSourceWhereInput,
		ec.unmarshalInputStaffAccountOrder,
		ec.unmarshalInputStaffAccountWhereInput,
		ec.unmarshalInputTransactionOrder,
		ec.unmarshalInputTransactionTypeOrder,
		ec.unmarshalInputTransactionTypeWhereInput,
		ec.unmarshalInputTransactionWhereInput,
		ec.unmarshalInputUpdateAccountInput,
		ec.unmarshalInputUpdateAssetClassInput,
		ec.unmarshalInputUpdateAssetInput,
		ec.unmarshalInputUpdateAuthRoleInput,
		ec.unmarshalInputUpdateAuthTypeInput,
		ec.unmarshalInputUpdateBlockchainInput,
		ec.unmarshalInputUpdateConnectionInput,
		ec.unmarshalInputUpdateCryptocurrencyInput,
		ec.unmarshalInputUpdateDailyAssetPriceInput,
		ec.unmarshalInputUpdateExchangeInput,
		ec.unmarshalInputUpdatePortfolioInput,
		ec.unmarshalInputUpdateSourceInput,
		ec.unmarshalInputUpdateSourceTypeInput,
		ec.unmarshalInputUpdateStaffAccountInput,
		ec.unmarshalInputUpdateTransactionInput,
		ec.unmarshalInputUpdateTransactionTypeInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphql", Input: `# Custom scalars
scalar Time`, BuiltIn: false},
	{Name: "../schema/ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Account implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  nickname: String!
  email: String!
  """Hashed and salted password using Bcrypt."""
  password: String
  passwordUpdatedAt: Time!
  authTypeID: ID!
  authRoles(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for AuthRoles returned from the connection."""
    orderBy: AuthRoleOrder

    """Filtering options for AuthRoles returned from the connection."""
    where: AuthRoleWhereInput
  ): AuthRoleConnection!
  portfolios(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Portfolios returned from the connection."""
    orderBy: PortfolioOrder

    """Filtering options for Portfolios returned from the connection."""
    where: PortfolioWhereInput
  ): PortfolioConnection!
  authType: AuthType!
  connections(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Connections returned from the connection."""
    orderBy: ConnectionOrder

    """Filtering options for Connections returned from the connection."""
    where: ConnectionWhereInput
  ): ConnectionConnection!
}
"""A connection to a list of items."""
type AccountConnection {
  """A list of edges."""
  edges: [AccountEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type AccountEdge {
  """The item at the end of the edge."""
  node: Account
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Account connections"""
input AccountOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Accounts."""
  field: AccountOrderField!
}
"""Properties by which Account connections can be ordered."""
enum AccountOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  NICKNAME
  EMAIL
}
"""
AccountWhereInput is used for filtering Account objects.
Input was generated by ent.
"""
input AccountWhereInput {
  not: AccountWhereInput
  and: [AccountWhereInput!]
  or: [AccountWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """nickname field predicates"""
  nickname: String
  nicknameNEQ: String
  nicknameIn: [String!]
  nicknameNotIn: [String!]
  nicknameGT: String
  nicknameGTE: String
  nicknameLT: String
  nicknameLTE: String
  nicknameContains: String
  nicknameHasPrefix: String
  nicknameHasSuffix: String
  nicknameEqualFold: String
  nicknameContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """password field predicates"""
  password: String
  passwordNEQ: String
  passwordIn: [String!]
  passwordNotIn: [String!]
  passwordGT: String
  passwordGTE: String
  passwordLT: String
  passwordLTE: String
  passwordContains: String
  passwordHasPrefix: String
  passwordHasSuffix: String
  passwordIsNil: Boolean
  passwordNotNil: Boolean
  passwordEqualFold: String
  passwordContainsFold: String
  """password_updated_at field predicates"""
  passwordUpdatedAt: Time
  passwordUpdatedAtNEQ: Time
  passwordUpdatedAtIn: [Time!]
  passwordUpdatedAtNotIn: [Time!]
  passwordUpdatedAtGT: Time
  passwordUpdatedAtGTE: Time
  passwordUpdatedAtLT: Time
  passwordUpdatedAtLTE: Time
  """auth_type_id field predicates"""
  authTypeID: ID
  authTypeIDNEQ: ID
  authTypeIDIn: [ID!]
  authTypeIDNotIn: [ID!]
  authTypeIDGT: ID
  authTypeIDGTE: ID
  authTypeIDLT: ID
  authTypeIDLTE: ID
  authTypeIDContains: ID
  authTypeIDHasPrefix: ID
  authTypeIDHasSuffix: ID
  authTypeIDEqualFold: ID
  authTypeIDContainsFold: ID
  """auth_roles edge predicates"""
  hasAuthRoles: Boolean
  hasAuthRolesWith: [AuthRoleWhereInput!]
  """portfolios edge predicates"""
  hasPortfolios: Boolean
  hasPortfoliosWith: [PortfolioWhereInput!]
  """auth_type edge predicates"""
  hasAuthType: Boolean
  hasAuthTypeWith: [AuthTypeWhereInput!]
  """connections edge predicates"""
  hasConnections: Boolean
  hasConnectionsWith: [ConnectionWhereInput!]
}
type Asset implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  assetClassID: ID!
  assetClass: AssetClass!
  cryptocurrency: Cryptocurrency
  transactionBases(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
  transactionQuotes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
  dailyAssetPrices(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for DailyAssetPrices returned from the connection."""
    orderBy: DailyAssetPriceOrder

    """Filtering options for DailyAssetPrices returned from the connection."""
    where: DailyAssetPriceWhereInput
  ): DailyAssetPriceConnection!
}
type AssetClass implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  value: AssetClassValue!
  description: String
  assets(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Assets returned from the connection."""
    orderBy: AssetOrder

    """Filtering options for Assets returned from the connection."""
    where: AssetWhereInput
  ): AssetConnection!
}
"""A connection to a list of items."""
type AssetClassConnection {
  """A list of edges."""
  edges: [AssetClassEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type AssetClassEdge {
  """The item at the end of the edge."""
  node: AssetClass
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for AssetClass connections"""
input AssetClassOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order AssetClasses."""
  field: AssetClassOrderField!
}
"""Properties by which AssetClass connections can be ordered."""
enum AssetClassOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  ASSET_CLASS
}
"""AssetClassValue is enum for the field value"""
enum AssetClassValue @goModel(model: "github.com/chenningg/hermitboard-api/ent/assetclass.Value") {
  CASH_OR_CASH_EQUIVALENT
  COMMODITY
  CRYPTOCURRENCY
  EQUITY
  FIXED_INCOME
  FUTURE
  REAL_ESTATE
}
"""
AssetClassWhereInput is used for filtering AssetClass objects.
Input was generated by ent.
"""
input AssetClassWhereInput {
  not: AssetClassWhereInput
  and: [AssetClassWhereInput!]
  or: [AssetClassWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """value field predicates"""
  value: AssetClassValue
  valueNEQ: AssetClassValue
  valueIn: [AssetClassValue!]
  valueNotIn: [AssetClassValue!]
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """assets edge predicates"""
  hasAssets: Boolean
  hasAssetsWith: [AssetWhereInput!]
}
"""A connection to a list of items."""
type AssetConnection {
  """A list of edges."""
  edges: [AssetEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type AssetEdge {
  """The item at the end of the edge."""
  node: Asset
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Asset connections"""
input AssetOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Assets."""
  field: AssetOrderField!
}
"""Properties by which Asset connections can be ordered."""
enum AssetOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
}
"""
AssetWhereInput is used for filtering Asset objects.
Input was generated by ent.
"""
input AssetWhereInput {
  not: AssetWhereInput
  and: [AssetWhereInput!]
  or: [AssetWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """asset_class_id field predicates"""
  assetClassID: ID
  assetClassIDNEQ: ID
  assetClassIDIn: [ID!]
  assetClassIDNotIn: [ID!]
  assetClassIDGT: ID
  assetClassIDGTE: ID
  assetClassIDLT: ID
  assetClassIDLTE: ID
  assetClassIDContains: ID
  assetClassIDHasPrefix: ID
  assetClassIDHasSuffix: ID
  assetClassIDEqualFold: ID
  assetClassIDContainsFold: ID
  """asset_class edge predicates"""
  hasAssetClass: Boolean
  hasAssetClassWith: [AssetClassWhereInput!]
  """cryptocurrency edge predicates"""
  hasCryptocurrency: Boolean
  hasCryptocurrencyWith: [CryptocurrencyWhereInput!]
  """transaction_bases edge predicates"""
  hasTransactionBases: Boolean
  hasTransactionBasesWith: [TransactionWhereInput!]
  """transaction_quotes edge predicates"""
  hasTransactionQuotes: Boolean
  hasTransactionQuotesWith: [TransactionWhereInput!]
  """daily_asset_prices edge predicates"""
  hasDailyAssetPrices: Boolean
  hasDailyAssetPricesWith: [DailyAssetPriceWhereInput!]
}
type AuthRole implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  value: AuthRoleValue!
  description: String
  accounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Accounts returned from the connection."""
    orderBy: AccountOrder

    """Filtering options for Accounts returned from the connection."""
    where: AccountWhereInput
  ): AccountConnection!
  staffAccounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for StaffAccounts returned from the connection."""
    orderBy: StaffAccountOrder

    """Filtering options for StaffAccounts returned from the connection."""
    where: StaffAccountWhereInput
  ): StaffAccountConnection!
}
"""A connection to a list of items."""
type AuthRoleConnection {
  """A list of edges."""
  edges: [AuthRoleEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type AuthRoleEdge {
  """The item at the end of the edge."""
  node: AuthRole
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for AuthRole connections"""
input AuthRoleOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order AuthRoles."""
  field: AuthRoleOrderField!
}
"""Properties by which AuthRole connections can be ordered."""
enum AuthRoleOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  AUTH_ROLE
}
"""AuthRoleValue is enum for the field value"""
enum AuthRoleValue @goModel(model: "github.com/chenningg/hermitboard-api/ent/authrole.Value") {
  DEMO
  FREE
  PLUS
  PRO
  ENTERPRISE
  SUPPORT
  ADMIN
  SUPER_ADMIN
}
"""
AuthRoleWhereInput is used for filtering AuthRole objects.
Input was generated by ent.
"""
input AuthRoleWhereInput {
  not: AuthRoleWhereInput
  and: [AuthRoleWhereInput!]
  or: [AuthRoleWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """value field predicates"""
  value: AuthRoleValue
  valueNEQ: AuthRoleValue
  valueIn: [AuthRoleValue!]
  valueNotIn: [AuthRoleValue!]
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """accounts edge predicates"""
  hasAccounts: Boolean
  hasAccountsWith: [AccountWhereInput!]
  """staff_accounts edge predicates"""
  hasStaffAccounts: Boolean
  hasStaffAccountsWith: [StaffAccountWhereInput!]
}
type AuthType implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  value: AuthTypeValue!
  description: String
  accounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Accounts returned from the connection."""
    orderBy: AccountOrder

    """Filtering options for Accounts returned from the connection."""
    where: AccountWhereInput
  ): AccountConnection!
  staffAccounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for StaffAccounts returned from the connection."""
    orderBy: StaffAccountOrder

    """Filtering options for StaffAccounts returned from the connection."""
    where: StaffAccountWhereInput
  ): StaffAccountConnection!
}
"""A connection to a list of items."""
type AuthTypeConnection {
  """A list of edges."""
  edges: [AuthTypeEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type AuthTypeEdge {
  """The item at the end of the edge."""
  node: AuthType
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for AuthType connections"""
input AuthTypeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order AuthTypes."""
  field: AuthTypeOrderField!
}
"""Properties by which AuthType connections can be ordered."""
enum AuthTypeOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  AUTH_TYPE
}
"""AuthTypeValue is enum for the field value"""
enum AuthTypeValue @goModel(model: "github.com/chenningg/hermitboard-api/ent/authtype.Value") {
  LOCAL
  GOOGLE
  APPLE
  FACEBOOK
}
"""
AuthTypeWhereInput is used for filtering AuthType objects.
Input was generated by ent.
"""
input AuthTypeWhereInput {
  not: AuthTypeWhereInput
  and: [AuthTypeWhereInput!]
  or: [AuthTypeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """value field predicates"""
  value: AuthTypeValue
  valueNEQ: AuthTypeValue
  valueIn: [AuthTypeValue!]
  valueNotIn: [AuthTypeValue!]
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """accounts edge predicates"""
  hasAccounts: Boolean
  hasAccountsWith: [AccountWhereInput!]
  """staff_accounts edge predicates"""
  hasStaffAccounts: Boolean
  hasStaffAccountsWith: [StaffAccountWhereInput!]
}
type Blockchain implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  name: String!
  symbol: String!
  icon: String
  chainID: Int
  cryptocurrencies(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Cryptocurrencies returned from the connection."""
    orderBy: CryptocurrencyOrder

    """Filtering options for Cryptocurrencies returned from the connection."""
    where: CryptocurrencyWhereInput
  ): CryptocurrencyConnection!
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
}
"""A connection to a list of items."""
type BlockchainConnection {
  """A list of edges."""
  edges: [BlockchainEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type BlockchainEdge {
  """The item at the end of the edge."""
  node: Blockchain
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Blockchain connections"""
input BlockchainOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Blockchains."""
  field: BlockchainOrderField!
}
"""Properties by which Blockchain connections can be ordered."""
enum BlockchainOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  NAME
  SYMBOL
  CHAIN_ID
}
"""
BlockchainWhereInput is used for filtering Blockchain objects.
Input was generated by ent.
"""
input BlockchainWhereInput {
  not: BlockchainWhereInput
  and: [BlockchainWhereInput!]
  or: [BlockchainWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """symbol field predicates"""
  symbol: String
  symbolNEQ: String
  symbolIn: [String!]
  symbolNotIn: [String!]
  symbolGT: String
  symbolGTE: String
  symbolLT: String
  symbolLTE: String
  symbolContains: String
  symbolHasPrefix: String
  symbolHasSuffix: String
  symbolEqualFold: String
  symbolContainsFold: String
  """icon field predicates"""
  icon: String
  iconNEQ: String
  iconIn: [String!]
  iconNotIn: [String!]
  iconGT: String
  iconGTE: String
  iconLT: String
  iconLTE: String
  iconContains: String
  iconHasPrefix: String
  iconHasSuffix: String
  iconIsNil: Boolean
  iconNotNil: Boolean
  iconEqualFold: String
  iconContainsFold: String
  """chain_id field predicates"""
  chainID: Int
  chainIDNEQ: Int
  chainIDIn: [Int!]
  chainIDNotIn: [Int!]
  chainIDGT: Int
  chainIDGTE: Int
  chainIDLT: Int
  chainIDLTE: Int
  chainIDIsNil: Boolean
  chainIDNotNil: Boolean
  """cryptocurrencies edge predicates"""
  hasCryptocurrencies: Boolean
  hasCryptocurrenciesWith: [CryptocurrencyWhereInput!]
  """transactions edge predicates"""
  hasTransactions: Boolean
  hasTransactionsWith: [TransactionWhereInput!]
}
type Connection implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  name: String!
  accessToken: String!
  accountID: ID!
  account: Account!
  portfolios(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Portfolios returned from the connection."""
    orderBy: PortfolioOrder

    """Filtering options for Portfolios returned from the connection."""
    where: PortfolioWhereInput
  ): PortfolioConnection!
}
"""A connection to a list of items."""
type ConnectionConnection {
  """A list of edges."""
  edges: [ConnectionEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type ConnectionEdge {
  """The item at the end of the edge."""
  node: Connection
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Connection connections"""
input ConnectionOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Connections."""
  field: ConnectionOrderField!
}
"""Properties by which Connection connections can be ordered."""
enum ConnectionOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  NAME
}
"""
ConnectionWhereInput is used for filtering Connection objects.
Input was generated by ent.
"""
input ConnectionWhereInput {
  not: ConnectionWhereInput
  and: [ConnectionWhereInput!]
  or: [ConnectionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """access_token field predicates"""
  accessToken: String
  accessTokenNEQ: String
  accessTokenIn: [String!]
  accessTokenNotIn: [String!]
  accessTokenGT: String
  accessTokenGTE: String
  accessTokenLT: String
  accessTokenLTE: String
  accessTokenContains: String
  accessTokenHasPrefix: String
  accessTokenHasSuffix: String
  accessTokenEqualFold: String
  accessTokenContainsFold: String
  """account_id field predicates"""
  accountID: ID
  accountIDNEQ: ID
  accountIDIn: [ID!]
  accountIDNotIn: [ID!]
  accountIDGT: ID
  accountIDGTE: ID
  accountIDLT: ID
  accountIDLTE: ID
  accountIDContains: ID
  accountIDHasPrefix: ID
  accountIDHasSuffix: ID
  accountIDEqualFold: ID
  accountIDContainsFold: ID
  """account edge predicates"""
  hasAccount: Boolean
  hasAccountWith: [AccountWhereInput!]
  """portfolios edge predicates"""
  hasPortfolios: Boolean
  hasPortfoliosWith: [PortfolioWhereInput!]
}
"""
CreateAccountInput is used for create Account object.
Input was generated by ent.
"""
input CreateAccountInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  nickname: String!
  email: String!
  """Hashed and salted password using Bcrypt."""
  password: String
  passwordUpdatedAt: Time
  authRoleIDs: [ID!]!
  portfolioIDs: [ID!]
  authTypeID: ID!
  connectionIDs: [ID!]
}
"""
CreateAssetClassInput is used for create AssetClass object.
Input was generated by ent.
"""
input CreateAssetClassInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  value: AssetClassValue!
  description: String
  assetIDs: [ID!]
}
"""
CreateAssetInput is used for create Asset object.
Input was generated by ent.
"""
input CreateAssetInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  assetClassID: ID!
  cryptocurrencyID: ID
  transactionBasisIDs: [ID!]
  transactionQuoteIDs: [ID!]
  dailyAssetPriceIDs: [ID!]
}
"""
CreateAuthRoleInput is used for create AuthRole object.
Input was generated by ent.
"""
input CreateAuthRoleInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  value: AuthRoleValue!
  description: String
  accountIDs: [ID!]
  staffAccountIDs: [ID!]
}
"""
CreateAuthTypeInput is used for create AuthType object.
Input was generated by ent.
"""
input CreateAuthTypeInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  value: AuthTypeValue!
  description: String
  accountIDs: [ID!]
  staffAccountIDs: [ID!]
}
"""
CreateBlockchainInput is used for create Blockchain object.
Input was generated by ent.
"""
input CreateBlockchainInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  name: String!
  symbol: String!
  icon: String
  chainID: Int
  cryptocurrencyIDs: [ID!]
  transactionIDs: [ID!]
}
"""
CreateConnectionInput is used for create Connection object.
Input was generated by ent.
"""
input CreateConnectionInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  name: String!
  accessToken: String!
  accountID: ID!
  portfolioIDs: [ID!]
}
"""
CreateCryptocurrencyInput is used for create Cryptocurrency object.
Input was generated by ent.
"""
input CreateCryptocurrencyInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  symbol: String!
  """A url to the image icon for this cryptocurrency."""
  icon: String
  name: String!
  assetID: ID!
  blockchainIDs: [ID!]!
}
"""
CreateDailyAssetPriceInput is used for create DailyAssetPrice object.
Input was generated by ent.
"""
input CreateDailyAssetPriceInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  time: Time
  open: Float
  high: Float
  low: Float
  close: Float
  adjustedClose: Float!
  assetID: ID!
}
"""
CreateExchangeInput is used for create Exchange object.
Input was generated by ent.
"""
input CreateExchangeInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  name: String!
  icon: String
  """A url to the exchange site."""
  url: String
  transactionIDs: [ID!]
}
"""
CreatePortfolioInput is used for create Portfolio object.
Input was generated by ent.
"""
input CreatePortfolioInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  name: String!
  """Whether this portfolio is visible to others."""
  isPublic: Boolean
  """Whether this portfolio is visible to the owner."""
  isVisible: Boolean
  accountID: ID!
  transactionIDs: [ID!]
  connectionIDs: [ID!]
}
"""
CreateSourceInput is used for create Source object.
Input was generated by ent.
"""
input CreateSourceInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  name: String!
  icon: String
  sourceTypeID: ID!
}
"""
CreateSourceTypeInput is used for create SourceType object.
Input was generated by ent.
"""
input CreateSourceTypeInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  value: SourceTypeValue!
  description: String
  sourceIDs: [ID!]
}
"""
CreateStaffAccountInput is used for create StaffAccount object.
Input was generated by ent.
"""
input CreateStaffAccountInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  nickname: String!
  email: String!
  """Hashed and salted password using Bcrypt."""
  password: String
  passwordUpdatedAt: Time
  authRoleIDs: [ID!]
  authTypeID: ID!
}
"""
CreateTransactionInput is used for create Transaction object.
Input was generated by ent.
"""
input CreateTransactionInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  time: Time!
  units: Int!
  pricePerUnit: Float!
  transactionTypeID: ID!
  baseAssetID: ID!
  quoteAssetID: ID
  portfolioID: ID!
  exchangeID: ID!
  blockchainID: ID
}
"""
CreateTransactionTypeInput is used for create TransactionType object.
Input was generated by ent.
"""
input CreateTransactionTypeInput {
  createdAt: Time
  updatedAt: Time
  deletedAt: Time
  value: TransactionTypeValue!
  description: String
  transactionIDs: [ID!]
}
type Cryptocurrency implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  symbol: String!
  """A url to the image icon for this cryptocurrency."""
  icon: String
  name: String!
  assetID: ID!
  asset: Asset!
  blockchains(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Blockchains returned from the connection."""
    orderBy: BlockchainOrder

    """Filtering options for Blockchains returned from the connection."""
    where: BlockchainWhereInput
  ): BlockchainConnection!
}
"""A connection to a list of items."""
type CryptocurrencyConnection {
  """A list of edges."""
  edges: [CryptocurrencyEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type CryptocurrencyEdge {
  """The item at the end of the edge."""
  node: Cryptocurrency
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Cryptocurrency connections"""
input CryptocurrencyOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Cryptocurrencies."""
  field: CryptocurrencyOrderField!
}
"""Properties by which Cryptocurrency connections can be ordered."""
enum CryptocurrencyOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  SYMBOL
  NAME
}
"""
CryptocurrencyWhereInput is used for filtering Cryptocurrency objects.
Input was generated by ent.
"""
input CryptocurrencyWhereInput {
  not: CryptocurrencyWhereInput
  and: [CryptocurrencyWhereInput!]
  or: [CryptocurrencyWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """symbol field predicates"""
  symbol: String
  symbolNEQ: String
  symbolIn: [String!]
  symbolNotIn: [String!]
  symbolGT: String
  symbolGTE: String
  symbolLT: String
  symbolLTE: String
  symbolContains: String
  symbolHasPrefix: String
  symbolHasSuffix: String
  symbolEqualFold: String
  symbolContainsFold: String
  """icon field predicates"""
  icon: String
  iconNEQ: String
  iconIn: [String!]
  iconNotIn: [String!]
  iconGT: String
  iconGTE: String
  iconLT: String
  iconLTE: String
  iconContains: String
  iconHasPrefix: String
  iconHasSuffix: String
  iconIsNil: Boolean
  iconNotNil: Boolean
  iconEqualFold: String
  iconContainsFold: String
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """asset_id field predicates"""
  assetID: ID
  assetIDNEQ: ID
  assetIDIn: [ID!]
  assetIDNotIn: [ID!]
  assetIDGT: ID
  assetIDGTE: ID
  assetIDLT: ID
  assetIDLTE: ID
  assetIDContains: ID
  assetIDHasPrefix: ID
  assetIDHasSuffix: ID
  assetIDEqualFold: ID
  assetIDContainsFold: ID
  """asset edge predicates"""
  hasAsset: Boolean
  hasAssetWith: [AssetWhereInput!]
  """blockchains edge predicates"""
  hasBlockchains: Boolean
  hasBlockchainsWith: [BlockchainWhereInput!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type DailyAssetPrice implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  time: Time!
  open: Float
  high: Float
  low: Float
  close: Float
  adjustedClose: Float!
  assetID: ID!
  asset: Asset!
}
"""A connection to a list of items."""
type DailyAssetPriceConnection {
  """A list of edges."""
  edges: [DailyAssetPriceEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type DailyAssetPriceEdge {
  """The item at the end of the edge."""
  node: DailyAssetPrice
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for DailyAssetPrice connections"""
input DailyAssetPriceOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order DailyAssetPrices."""
  field: DailyAssetPriceOrderField!
}
"""Properties by which DailyAssetPrice connections can be ordered."""
enum DailyAssetPriceOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  TIME
}
"""
DailyAssetPriceWhereInput is used for filtering DailyAssetPrice objects.
Input was generated by ent.
"""
input DailyAssetPriceWhereInput {
  not: DailyAssetPriceWhereInput
  and: [DailyAssetPriceWhereInput!]
  or: [DailyAssetPriceWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """time field predicates"""
  time: Time
  timeNEQ: Time
  timeIn: [Time!]
  timeNotIn: [Time!]
  timeGT: Time
  timeGTE: Time
  timeLT: Time
  timeLTE: Time
  """open field predicates"""
  open: Float
  openNEQ: Float
  openIn: [Float!]
  openNotIn: [Float!]
  openGT: Float
  openGTE: Float
  openLT: Float
  openLTE: Float
  openIsNil: Boolean
  openNotNil: Boolean
  """high field predicates"""
  high: Float
  highNEQ: Float
  highIn: [Float!]
  highNotIn: [Float!]
  highGT: Float
  highGTE: Float
  highLT: Float
  highLTE: Float
  highIsNil: Boolean
  highNotNil: Boolean
  """low field predicates"""
  low: Float
  lowNEQ: Float
  lowIn: [Float!]
  lowNotIn: [Float!]
  lowGT: Float
  lowGTE: Float
  lowLT: Float
  lowLTE: Float
  lowIsNil: Boolean
  lowNotNil: Boolean
  """close field predicates"""
  close: Float
  closeNEQ: Float
  closeIn: [Float!]
  closeNotIn: [Float!]
  closeGT: Float
  closeGTE: Float
  closeLT: Float
  closeLTE: Float
  closeIsNil: Boolean
  closeNotNil: Boolean
  """adjusted_close field predicates"""
  adjustedClose: Float
  adjustedCloseNEQ: Float
  adjustedCloseIn: [Float!]
  adjustedCloseNotIn: [Float!]
  adjustedCloseGT: Float
  adjustedCloseGTE: Float
  adjustedCloseLT: Float
  adjustedCloseLTE: Float
  """asset_id field predicates"""
  assetID: ID
  assetIDNEQ: ID
  assetIDIn: [ID!]
  assetIDNotIn: [ID!]
  assetIDGT: ID
  assetIDGTE: ID
  assetIDLT: ID
  assetIDLTE: ID
  assetIDContains: ID
  assetIDHasPrefix: ID
  assetIDHasSuffix: ID
  assetIDEqualFold: ID
  assetIDContainsFold: ID
  """asset edge predicates"""
  hasAsset: Boolean
  hasAssetWith: [AssetWhereInput!]
}
type Exchange implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  name: String!
  icon: String
  """A url to the exchange site."""
  url: String
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
}
"""A connection to a list of items."""
type ExchangeConnection {
  """A list of edges."""
  edges: [ExchangeEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type ExchangeEdge {
  """The item at the end of the edge."""
  node: Exchange
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Exchange connections"""
input ExchangeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Exchanges."""
  field: ExchangeOrderField!
}
"""Properties by which Exchange connections can be ordered."""
enum ExchangeOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  NAME
}
"""
ExchangeWhereInput is used for filtering Exchange objects.
Input was generated by ent.
"""
input ExchangeWhereInput {
  not: ExchangeWhereInput
  and: [ExchangeWhereInput!]
  or: [ExchangeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """icon field predicates"""
  icon: String
  iconNEQ: String
  iconIn: [String!]
  iconNotIn: [String!]
  iconGT: String
  iconGTE: String
  iconLT: String
  iconLTE: String
  iconContains: String
  iconHasPrefix: String
  iconHasSuffix: String
  iconIsNil: Boolean
  iconNotNil: Boolean
  iconEqualFold: String
  iconContainsFold: String
  """url field predicates"""
  url: String
  urlNEQ: String
  urlIn: [String!]
  urlNotIn: [String!]
  urlGT: String
  urlGTE: String
  urlLT: String
  urlLTE: String
  urlContains: String
  urlHasPrefix: String
  urlHasSuffix: String
  urlIsNil: Boolean
  urlNotNil: Boolean
  urlEqualFold: String
  urlContainsFold: String
  """transactions edge predicates"""
  hasTransactions: Boolean
  hasTransactionsWith: [TransactionWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/chenningg/hermitboard-api/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Portfolio implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  name: String!
  """Whether this portfolio is visible to others."""
  isPublic: Boolean!
  """Whether this portfolio is visible to the owner."""
  isVisible: Boolean!
  accountID: ID!
  account: Account!
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
  connections(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Connections returned from the connection."""
    orderBy: ConnectionOrder

    """Filtering options for Connections returned from the connection."""
    where: ConnectionWhereInput
  ): ConnectionConnection!
}
"""A connection to a list of items."""
type PortfolioConnection {
  """A list of edges."""
  edges: [PortfolioEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PortfolioEdge {
  """The item at the end of the edge."""
  node: Portfolio
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Portfolio connections"""
input PortfolioOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Portfolios."""
  field: PortfolioOrderField!
}
"""Properties by which Portfolio connections can be ordered."""
enum PortfolioOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  NAME
  IS_PUBLIC
  IS_VISIBLE
}
"""
PortfolioWhereInput is used for filtering Portfolio objects.
Input was generated by ent.
"""
input PortfolioWhereInput {
  not: PortfolioWhereInput
  and: [PortfolioWhereInput!]
  or: [PortfolioWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """is_public field predicates"""
  isPublic: Boolean
  isPublicNEQ: Boolean
  """is_visible field predicates"""
  isVisible: Boolean
  isVisibleNEQ: Boolean
  """account_id field predicates"""
  accountID: ID
  accountIDNEQ: ID
  accountIDIn: [ID!]
  accountIDNotIn: [ID!]
  accountIDGT: ID
  accountIDGTE: ID
  accountIDLT: ID
  accountIDLTE: ID
  accountIDContains: ID
  accountIDHasPrefix: ID
  accountIDHasSuffix: ID
  accountIDEqualFold: ID
  accountIDContainsFold: ID
  """account edge predicates"""
  hasAccount: Boolean
  hasAccountWith: [AccountWhereInput!]
  """transactions edge predicates"""
  hasTransactions: Boolean
  hasTransactionsWith: [TransactionWhereInput!]
  """connections edge predicates"""
  hasConnections: Boolean
  hasConnectionsWith: [ConnectionWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  accounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Accounts returned from the connection."""
    orderBy: AccountOrder

    """Filtering options for Accounts returned from the connection."""
    where: AccountWhereInput
  ): AccountConnection!
  assets(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Assets returned from the connection."""
    orderBy: AssetOrder

    """Filtering options for Assets returned from the connection."""
    where: AssetWhereInput
  ): AssetConnection!
  assetclasses(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for AssetClasses returned from the connection."""
    orderBy: AssetClassOrder

    """Filtering options for AssetClasses returned from the connection."""
    where: AssetClassWhereInput
  ): AssetClassConnection!
  authroles(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for AuthRoles returned from the connection."""
    orderBy: AuthRoleOrder

    """Filtering options for AuthRoles returned from the connection."""
    where: AuthRoleWhereInput
  ): AuthRoleConnection!
  authtypes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for AuthTypes returned from the connection."""
    orderBy: AuthTypeOrder

    """Filtering options for AuthTypes returned from the connection."""
    where: AuthTypeWhereInput
  ): AuthTypeConnection!
  blockchains(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Blockchains returned from the connection."""
    orderBy: BlockchainOrder

    """Filtering options for Blockchains returned from the connection."""
    where: BlockchainWhereInput
  ): BlockchainConnection!
  connections(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Connections returned from the connection."""
    orderBy: ConnectionOrder

    """Filtering options for Connections returned from the connection."""
    where: ConnectionWhereInput
  ): ConnectionConnection!
  cryptocurrencies(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Cryptocurrencies returned from the connection."""
    orderBy: CryptocurrencyOrder

    """Filtering options for Cryptocurrencies returned from the connection."""
    where: CryptocurrencyWhereInput
  ): CryptocurrencyConnection!
  dailyassetprices(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for DailyAssetPrices returned from the connection."""
    orderBy: DailyAssetPriceOrder

    """Filtering options for DailyAssetPrices returned from the connection."""
    where: DailyAssetPriceWhereInput
  ): DailyAssetPriceConnection!
  exchanges(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Exchanges returned from the connection."""
    orderBy: ExchangeOrder

    """Filtering options for Exchanges returned from the connection."""
    where: ExchangeWhereInput
  ): ExchangeConnection!
  portfolios(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Portfolios returned from the connection."""
    orderBy: PortfolioOrder

    """Filtering options for Portfolios returned from the connection."""
    where: PortfolioWhereInput
  ): PortfolioConnection!
  sources(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Sources returned from the connection."""
    orderBy: SourceOrder

    """Filtering options for Sources returned from the connection."""
    where: SourceWhereInput
  ): SourceConnection!
  sourcetypes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for SourceTypes returned from the connection."""
    orderBy: SourceTypeOrder

    """Filtering options for SourceTypes returned from the connection."""
    where: SourceTypeWhereInput
  ): SourceTypeConnection!
  staffaccounts(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for StaffAccounts returned from the connection."""
    orderBy: StaffAccountOrder

    """Filtering options for StaffAccounts returned from the connection."""
    where: StaffAccountWhereInput
  ): StaffAccountConnection!
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
  transactiontypes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for TransactionTypes returned from the connection."""
    orderBy: TransactionTypeOrder

    """Filtering options for TransactionTypes returned from the connection."""
    where: TransactionTypeWhereInput
  ): TransactionTypeConnection!
}
type Source implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  name: String!
  icon: String
  sourceTypeID: ID!
  sourceType: SourceType!
}
"""A connection to a list of items."""
type SourceConnection {
  """A list of edges."""
  edges: [SourceEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type SourceEdge {
  """The item at the end of the edge."""
  node: Source
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Source connections"""
input SourceOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Sources."""
  field: SourceOrderField!
}
"""Properties by which Source connections can be ordered."""
enum SourceOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  NAME
}
type SourceType implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  value: SourceTypeValue!
  description: String
  sources(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Sources returned from the connection."""
    orderBy: SourceOrder

    """Filtering options for Sources returned from the connection."""
    where: SourceWhereInput
  ): SourceConnection!
}
"""A connection to a list of items."""
type SourceTypeConnection {
  """A list of edges."""
  edges: [SourceTypeEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type SourceTypeEdge {
  """The item at the end of the edge."""
  node: SourceType
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for SourceType connections"""
input SourceTypeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order SourceTypes."""
  field: SourceTypeOrderField!
}
"""Properties by which SourceType connections can be ordered."""
enum SourceTypeOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  SOURCE_TYPE
}
"""SourceTypeValue is enum for the field value"""
enum SourceTypeValue @goModel(model: "github.com/chenningg/hermitboard-api/ent/sourcetype.Value") {
  EXCHANGE
  BANK
  DECENTRALIZED_EXCHANGE
}
"""
SourceTypeWhereInput is used for filtering SourceType objects.
Input was generated by ent.
"""
input SourceTypeWhereInput {
  not: SourceTypeWhereInput
  and: [SourceTypeWhereInput!]
  or: [SourceTypeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """value field predicates"""
  value: SourceTypeValue
  valueNEQ: SourceTypeValue
  valueIn: [SourceTypeValue!]
  valueNotIn: [SourceTypeValue!]
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """sources edge predicates"""
  hasSources: Boolean
  hasSourcesWith: [SourceWhereInput!]
}
"""
SourceWhereInput is used for filtering Source objects.
Input was generated by ent.
"""
input SourceWhereInput {
  not: SourceWhereInput
  and: [SourceWhereInput!]
  or: [SourceWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """icon field predicates"""
  icon: String
  iconNEQ: String
  iconIn: [String!]
  iconNotIn: [String!]
  iconGT: String
  iconGTE: String
  iconLT: String
  iconLTE: String
  iconContains: String
  iconHasPrefix: String
  iconHasSuffix: String
  iconIsNil: Boolean
  iconNotNil: Boolean
  iconEqualFold: String
  iconContainsFold: String
  """source_type_id field predicates"""
  sourceTypeID: ID
  sourceTypeIDNEQ: ID
  sourceTypeIDIn: [ID!]
  sourceTypeIDNotIn: [ID!]
  sourceTypeIDGT: ID
  sourceTypeIDGTE: ID
  sourceTypeIDLT: ID
  sourceTypeIDLTE: ID
  sourceTypeIDContains: ID
  sourceTypeIDHasPrefix: ID
  sourceTypeIDHasSuffix: ID
  sourceTypeIDEqualFold: ID
  sourceTypeIDContainsFold: ID
  """source_type edge predicates"""
  hasSourceType: Boolean
  hasSourceTypeWith: [SourceTypeWhereInput!]
}
type StaffAccount implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  nickname: String!
  email: String!
  """Hashed and salted password using Bcrypt."""
  password: String
  passwordUpdatedAt: Time!
  authTypeID: ID!
  authRoles(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for AuthRoles returned from the connection."""
    orderBy: AuthRoleOrder

    """Filtering options for AuthRoles returned from the connection."""
    where: AuthRoleWhereInput
  ): AuthRoleConnection!
  authType: AuthType!
}
"""A connection to a list of items."""
type StaffAccountConnection {
  """A list of edges."""
  edges: [StaffAccountEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type StaffAccountEdge {
  """The item at the end of the edge."""
  node: StaffAccount
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for StaffAccount connections"""
input StaffAccountOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order StaffAccounts."""
  field: StaffAccountOrderField!
}
"""Properties by which StaffAccount connections can be ordered."""
enum StaffAccountOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
}
"""
StaffAccountWhereInput is used for filtering StaffAccount objects.
Input was generated by ent.
"""
input StaffAccountWhereInput {
  not: StaffAccountWhereInput
  and: [StaffAccountWhereInput!]
  or: [StaffAccountWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """nickname field predicates"""
  nickname: String
  nicknameNEQ: String
  nicknameIn: [String!]
  nicknameNotIn: [String!]
  nicknameGT: String
  nicknameGTE: String
  nicknameLT: String
  nicknameLTE: String
  nicknameContains: String
  nicknameHasPrefix: String
  nicknameHasSuffix: String
  nicknameEqualFold: String
  nicknameContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """password field predicates"""
  password: String
  passwordNEQ: String
  passwordIn: [String!]
  passwordNotIn: [String!]
  passwordGT: String
  passwordGTE: String
  passwordLT: String
  passwordLTE: String
  passwordContains: String
  passwordHasPrefix: String
  passwordHasSuffix: String
  passwordIsNil: Boolean
  passwordNotNil: Boolean
  passwordEqualFold: String
  passwordContainsFold: String
  """password_updated_at field predicates"""
  passwordUpdatedAt: Time
  passwordUpdatedAtNEQ: Time
  passwordUpdatedAtIn: [Time!]
  passwordUpdatedAtNotIn: [Time!]
  passwordUpdatedAtGT: Time
  passwordUpdatedAtGTE: Time
  passwordUpdatedAtLT: Time
  passwordUpdatedAtLTE: Time
  """auth_type_id field predicates"""
  authTypeID: ID
  authTypeIDNEQ: ID
  authTypeIDIn: [ID!]
  authTypeIDNotIn: [ID!]
  authTypeIDGT: ID
  authTypeIDGTE: ID
  authTypeIDLT: ID
  authTypeIDLTE: ID
  authTypeIDContains: ID
  authTypeIDHasPrefix: ID
  authTypeIDHasSuffix: ID
  authTypeIDEqualFold: ID
  authTypeIDContainsFold: ID
  """auth_roles edge predicates"""
  hasAuthRoles: Boolean
  hasAuthRolesWith: [AuthRoleWhereInput!]
  """auth_type edge predicates"""
  hasAuthType: Boolean
  hasAuthTypeWith: [AuthTypeWhereInput!]
}
type Transaction implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  time: Time!
  units: Int!
  pricePerUnit: Float!
  blockchainID: ID
  transactionTypeID: ID!
  exchangeID: ID!
  portfolioID: ID!
  baseAssetID: ID!
  quoteAssetID: ID
  transactionType: TransactionType!
  baseAsset: Asset!
  quoteAsset: Asset
  portfolio: Portfolio!
  exchange: Exchange!
  blockchain: Blockchain
}
"""A connection to a list of items."""
type TransactionConnection {
  """A list of edges."""
  edges: [TransactionEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TransactionEdge {
  """The item at the end of the edge."""
  node: Transaction
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Transaction connections"""
input TransactionOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Transactions."""
  field: TransactionOrderField!
}
"""Properties by which Transaction connections can be ordered."""
enum TransactionOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
}
type TransactionType implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  deletedAt: Time
  value: TransactionTypeValue!
  description: String
  transactions(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Transactions returned from the connection."""
    orderBy: TransactionOrder

    """Filtering options for Transactions returned from the connection."""
    where: TransactionWhereInput
  ): TransactionConnection!
}
"""A connection to a list of items."""
type TransactionTypeConnection {
  """A list of edges."""
  edges: [TransactionTypeEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TransactionTypeEdge {
  """The item at the end of the edge."""
  node: TransactionType
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for TransactionType connections"""
input TransactionTypeOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order TransactionTypes."""
  field: TransactionTypeOrderField!
}
"""Properties by which TransactionType connections can be ordered."""
enum TransactionTypeOrderField {
  CREATED_AT
  UPDATED_AT
  DELETED_AT
  TRANSACTION_TYPE
}
"""TransactionTypeValue is enum for the field value"""
enum TransactionTypeValue @goModel(model: "github.com/chenningg/hermitboard-api/ent/transactiontype.Value") {
  BUY
  SELL
  SWAP
  STAKE
  DIVIDEND_INCOME
  RENT_PAYMENT
  RENT_INCOME
  STOCK_DIVIDEND
}
"""
TransactionTypeWhereInput is used for filtering TransactionType objects.
Input was generated by ent.
"""
input TransactionTypeWhereInput {
  not: TransactionTypeWhereInput
  and: [TransactionTypeWhereInput!]
  or: [TransactionTypeWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """value field predicates"""
  value: TransactionTypeValue
  valueNEQ: TransactionTypeValue
  valueIn: [TransactionTypeValue!]
  valueNotIn: [TransactionTypeValue!]
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """transactions edge predicates"""
  hasTransactions: Boolean
  hasTransactionsWith: [TransactionWhereInput!]
}
"""
TransactionWhereInput is used for filtering Transaction objects.
Input was generated by ent.
"""
input TransactionWhereInput {
  not: TransactionWhereInput
  and: [TransactionWhereInput!]
  or: [TransactionWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """updated_at field predicates"""
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """deleted_at field predicates"""
  deletedAt: Time
  deletedAtNEQ: Time
  deletedAtIn: [Time!]
  deletedAtNotIn: [Time!]
  deletedAtGT: Time
  deletedAtGTE: Time
  deletedAtLT: Time
  deletedAtLTE: Time
  deletedAtIsNil: Boolean
  deletedAtNotNil: Boolean
  """time field predicates"""
  time: Time
  timeNEQ: Time
  timeIn: [Time!]
  timeNotIn: [Time!]
  timeGT: Time
  timeGTE: Time
  timeLT: Time
  timeLTE: Time
  """units field predicates"""
  units: Int
  unitsNEQ: Int
  unitsIn: [Int!]
  unitsNotIn: [Int!]
  unitsGT: Int
  unitsGTE: Int
  unitsLT: Int
  unitsLTE: Int
  """price_per_unit field predicates"""
  pricePerUnit: Float
  pricePerUnitNEQ: Float
  pricePerUnitIn: [Float!]
  pricePerUnitNotIn: [Float!]
  pricePerUnitGT: Float
  pricePerUnitGTE: Float
  pricePerUnitLT: Float
  pricePerUnitLTE: Float
  """blockchain_id field predicates"""
  blockchainID: ID
  blockchainIDNEQ: ID
  blockchainIDIn: [ID!]
  blockchainIDNotIn: [ID!]
  blockchainIDGT: ID
  blockchainIDGTE: ID
  blockchainIDLT: ID
  blockchainIDLTE: ID
  blockchainIDContains: ID
  blockchainIDHasPrefix: ID
  blockchainIDHasSuffix: ID
  blockchainIDIsNil: Boolean
  blockchainIDNotNil: Boolean
  blockchainIDEqualFold: ID
  blockchainIDContainsFold: ID
  """transaction_type_id field predicates"""
  transactionTypeID: ID
  transactionTypeIDNEQ: ID
  transactionTypeIDIn: [ID!]
  transactionTypeIDNotIn: [ID!]
  transactionTypeIDGT: ID
  transactionTypeIDGTE: ID
  transactionTypeIDLT: ID
  transactionTypeIDLTE: ID
  transactionTypeIDContains: ID
  transactionTypeIDHasPrefix: ID
  transactionTypeIDHasSuffix: ID
  transactionTypeIDEqualFold: ID
  transactionTypeIDContainsFold: ID
  """exchange_id field predicates"""
  exchangeID: ID
  exchangeIDNEQ: ID
  exchangeIDIn: [ID!]
  exchangeIDNotIn: [ID!]
  exchangeIDGT: ID
  exchangeIDGTE: ID
  exchangeIDLT: ID
  exchangeIDLTE: ID
  exchangeIDContains: ID
  exchangeIDHasPrefix: ID
  exchangeIDHasSuffix: ID
  exchangeIDEqualFold: ID
  exchangeIDContainsFold: ID
  """portfolio_id field predicates"""
  portfolioID: ID
  portfolioIDNEQ: ID
  portfolioIDIn: [ID!]
  portfolioIDNotIn: [ID!]
  portfolioIDGT: ID
  portfolioIDGTE: ID
  portfolioIDLT: ID
  portfolioIDLTE: ID
  portfolioIDContains: ID
  portfolioIDHasPrefix: ID
  portfolioIDHasSuffix: ID
  portfolioIDEqualFold: ID
  portfolioIDContainsFold: ID
  """base_asset_id field predicates"""
  baseAssetID: ID
  baseAssetIDNEQ: ID
  baseAssetIDIn: [ID!]
  baseAssetIDNotIn: [ID!]
  baseAssetIDGT: ID
  baseAssetIDGTE: ID
  baseAssetIDLT: ID
  baseAssetIDLTE: ID
  baseAssetIDContains: ID
  baseAssetIDHasPrefix: ID
  baseAssetIDHasSuffix: ID
  baseAssetIDEqualFold: ID
  baseAssetIDContainsFold: ID
  """quote_asset_id field predicates"""
  quoteAssetID: ID
  quoteAssetIDNEQ: ID
  quoteAssetIDIn: [ID!]
  quoteAssetIDNotIn: [ID!]
  quoteAssetIDGT: ID
  quoteAssetIDGTE: ID
  quoteAssetIDLT: ID
  quoteAssetIDLTE: ID
  quoteAssetIDContains: ID
  quoteAssetIDHasPrefix: ID
  quoteAssetIDHasSuffix: ID
  quoteAssetIDIsNil: Boolean
  quoteAssetIDNotNil: Boolean
  quoteAssetIDEqualFold: ID
  quoteAssetIDContainsFold: ID
  """transaction_type edge predicates"""
  hasTransactionType: Boolean
  hasTransactionTypeWith: [TransactionTypeWhereInput!]
  """base_asset edge predicates"""
  hasBaseAsset: Boolean
  hasBaseAssetWith: [AssetWhereInput!]
  """quote_asset edge predicates"""
  hasQuoteAsset: Boolean
  hasQuoteAssetWith: [AssetWhereInput!]
  """portfolio edge predicates"""
  hasPortfolio: Boolean
  hasPortfolioWith: [PortfolioWhereInput!]
  """exchange edge predicates"""
  hasExchange: Boolean
  hasExchangeWith: [ExchangeWhereInput!]
  """blockchain edge predicates"""
  hasBlockchain: Boolean
  hasBlockchainWith: [BlockchainWhereInput!]
}
"""
UpdateAccountInput is used for update Account object.
Input was generated by ent.
"""
input UpdateAccountInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  nickname: String
  email: String
  clearPassword: Boolean
  """Hashed and salted password using Bcrypt."""
  password: String
  passwordUpdatedAt: Time
  addAuthRoleIDs: [ID!]
  removeAuthRoleIDs: [ID!]
  addPortfolioIDs: [ID!]
  removePortfolioIDs: [ID!]
  clearAuthType: Boolean
  authTypeID: ID
  addConnectionIDs: [ID!]
  removeConnectionIDs: [ID!]
}
"""
UpdateAssetClassInput is used for update AssetClass object.
Input was generated by ent.
"""
input UpdateAssetClassInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  value: AssetClassValue
  clearDescription: Boolean
  description: String
  addAssetIDs: [ID!]
  removeAssetIDs: [ID!]
}
"""
UpdateAssetInput is used for update Asset object.
Input was generated by ent.
"""
input UpdateAssetInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  clearAssetClass: Boolean
  assetClassID: ID
  clearCryptocurrency: Boolean
  cryptocurrencyID: ID
  addTransactionBasisIDs: [ID!]
  removeTransactionBasisIDs: [ID!]
  addTransactionQuoteIDs: [ID!]
  removeTransactionQuoteIDs: [ID!]
  addDailyAssetPriceIDs: [ID!]
  removeDailyAssetPriceIDs: [ID!]
}
"""
UpdateAuthRoleInput is used for update AuthRole object.
Input was generated by ent.
"""
input UpdateAuthRoleInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  value: AuthRoleValue
  clearDescription: Boolean
  description: String
  addAccountIDs: [ID!]
  removeAccountIDs: [ID!]
  addStaffAccountIDs: [ID!]
  removeStaffAccountIDs: [ID!]
}
"""
UpdateAuthTypeInput is used for update AuthType object.
Input was generated by ent.
"""
input UpdateAuthTypeInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  value: AuthTypeValue
  clearDescription: Boolean
  description: String
  addAccountIDs: [ID!]
  removeAccountIDs: [ID!]
  addStaffAccountIDs: [ID!]
  removeStaffAccountIDs: [ID!]
}
"""
UpdateBlockchainInput is used for update Blockchain object.
Input was generated by ent.
"""
input UpdateBlockchainInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  name: String
  symbol: String
  clearIcon: Boolean
  icon: String
  clearChainID: Boolean
  chainID: Int
  addCryptocurrencyIDs: [ID!]
  removeCryptocurrencyIDs: [ID!]
  addTransactionIDs: [ID!]
  removeTransactionIDs: [ID!]
}
"""
UpdateConnectionInput is used for update Connection object.
Input was generated by ent.
"""
input UpdateConnectionInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  name: String
  accessToken: String
  clearAccount: Boolean
  accountID: ID
  addPortfolioIDs: [ID!]
  removePortfolioIDs: [ID!]
}
"""
UpdateCryptocurrencyInput is used for update Cryptocurrency object.
Input was generated by ent.
"""
input UpdateCryptocurrencyInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  symbol: String
  clearIcon: Boolean
  """A url to the image icon for this cryptocurrency."""
  icon: String
  name: String
  clearAsset: Boolean
  assetID: ID
  addBlockchainIDs: [ID!]
  removeBlockchainIDs: [ID!]
}
"""
UpdateDailyAssetPriceInput is used for update DailyAssetPrice object.
Input was generated by ent.
"""
input UpdateDailyAssetPriceInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  time: Time
  clearOpen: Boolean
  open: Float
  clearHigh: Boolean
  high: Float
  clearLow: Boolean
  low: Float
  clearClose: Boolean
  close: Float
  adjustedClose: Float
  clearAsset: Boolean
  assetID: ID
}
"""
UpdateExchangeInput is used for update Exchange object.
Input was generated by ent.
"""
input UpdateExchangeInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  name: String
  clearIcon: Boolean
  icon: String
  clearURL: Boolean
  """A url to the exchange site."""
  url: String
  addTransactionIDs: [ID!]
  removeTransactionIDs: [ID!]
}
"""
UpdatePortfolioInput is used for update Portfolio object.
Input was generated by ent.
"""
input UpdatePortfolioInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  name: String
  """Whether this portfolio is visible to others."""
  isPublic: Boolean
  """Whether this portfolio is visible to the owner."""
  isVisible: Boolean
  clearAccount: Boolean
  accountID: ID
  addTransactionIDs: [ID!]
  removeTransactionIDs: [ID!]
  addConnectionIDs: [ID!]
  removeConnectionIDs: [ID!]
}
"""
UpdateSourceInput is used for update Source object.
Input was generated by ent.
"""
input UpdateSourceInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  name: String
  clearIcon: Boolean
  icon: String
  clearSourceType: Boolean
  sourceTypeID: ID
}
"""
UpdateSourceTypeInput is used for update SourceType object.
Input was generated by ent.
"""
input UpdateSourceTypeInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  value: SourceTypeValue
  clearDescription: Boolean
  description: String
  addSourceIDs: [ID!]
  removeSourceIDs: [ID!]
}
"""
UpdateStaffAccountInput is used for update StaffAccount object.
Input was generated by ent.
"""
input UpdateStaffAccountInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  nickname: String
  email: String
  clearPassword: Boolean
  """Hashed and salted password using Bcrypt."""
  password: String
  passwordUpdatedAt: Time
  addAuthRoleIDs: [ID!]
  removeAuthRoleIDs: [ID!]
  clearAuthType: Boolean
  authTypeID: ID
}
"""
UpdateTransactionInput is used for update Transaction object.
Input was generated by ent.
"""
input UpdateTransactionInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  time: Time
  units: Int
  pricePerUnit: Float
  clearTransactionType: Boolean
  transactionTypeID: ID
  clearBaseAsset: Boolean
  baseAssetID: ID
  clearQuoteAsset: Boolean
  quoteAssetID: ID
  clearPortfolio: Boolean
  portfolioID: ID
  clearExchange: Boolean
  exchangeID: ID
  clearBlockchain: Boolean
  blockchainID: ID
}
"""
UpdateTransactionTypeInput is used for update TransactionType object.
Input was generated by ent.
"""
input UpdateTransactionTypeInput {
  updatedAt: Time
  clearDeletedAt: Boolean
  deletedAt: Time
  value: TransactionTypeValue
  clearDescription: Boolean
  description: String
  addTransactionIDs: [ID!]
  removeTransactionIDs: [ID!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
