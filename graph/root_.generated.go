// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/chenningg/hermitboard-api/ent"
	"github.com/chenningg/hermitboard-api/pulid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		AuthRoles         func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthRoleOrder, where *ent.AuthRoleWhereInput) int
		AuthType          func(childComplexity int) int
		AuthTypeID        func(childComplexity int) int
		Connections       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ConnectionOrder, where *ent.ConnectionWhereInput) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Email             func(childComplexity int) int
		ID                func(childComplexity int) int
		Nickname          func(childComplexity int) int
		Password          func(childComplexity int) int
		PasswordUpdatedAt func(childComplexity int) int
		Portfolios        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PortfolioOrder, where *ent.PortfolioWhereInput) int
		UpdatedAt         func(childComplexity int) int
	}

	AccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Asset struct {
		AssetClass        func(childComplexity int) int
		AssetClassID      func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Cryptocurrency    func(childComplexity int) int
		DailyAssetPrices  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DailyAssetPriceOrder, where *ent.DailyAssetPriceWhereInput) int
		DeletedAt         func(childComplexity int) int
		ID                func(childComplexity int) int
		TransactionBases  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		TransactionQuotes func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt         func(childComplexity int) int
	}

	AssetClass struct {
		Assets      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AssetOrder, where *ent.AssetWhereInput) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	AssetClassConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AssetClassEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AssetConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AssetEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AuthRole struct {
		Accounts      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AccountOrder, where *ent.AccountWhereInput) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		StaffAccounts func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.StaffAccountOrder, where *ent.StaffAccountWhereInput) int
		UpdatedAt     func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	AuthRoleConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AuthRoleEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	AuthType struct {
		Accounts      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AccountOrder, where *ent.AccountWhereInput) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		StaffAccounts func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.StaffAccountOrder, where *ent.StaffAccountWhereInput) int
		UpdatedAt     func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	AuthTypeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AuthTypeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Blockchain struct {
		ChainID          func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Cryptocurrencies func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.CryptocurrencyOrder, where *ent.CryptocurrencyWhereInput) int
		DeletedAt        func(childComplexity int) int
		ID               func(childComplexity int) int
		Icon             func(childComplexity int) int
		Name             func(childComplexity int) int
		Symbol           func(childComplexity int) int
		Transactions     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt        func(childComplexity int) int
	}

	BlockchainConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BlockchainEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Connection struct {
		AccessToken func(childComplexity int) int
		Account     func(childComplexity int) int
		AccountID   func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Portfolios  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PortfolioOrder, where *ent.PortfolioWhereInput) int
		UpdatedAt   func(childComplexity int) int
	}

	ConnectionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ConnectionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Cryptocurrency struct {
		Asset       func(childComplexity int) int
		AssetID     func(childComplexity int) int
		Blockchains func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.BlockchainOrder, where *ent.BlockchainWhereInput) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Icon        func(childComplexity int) int
		Name        func(childComplexity int) int
		Symbol      func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	CryptocurrencyConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CryptocurrencyEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	DailyAssetPrice struct {
		AdjustedClose func(childComplexity int) int
		Asset         func(childComplexity int) int
		AssetID       func(childComplexity int) int
		Close         func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		High          func(childComplexity int) int
		ID            func(childComplexity int) int
		Low           func(childComplexity int) int
		Open          func(childComplexity int) int
		Time          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
	}

	DailyAssetPriceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DailyAssetPriceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Exchange struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Icon         func(childComplexity int) int
		Name         func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		URL          func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	ExchangeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ExchangeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Portfolio struct {
		Account      func(childComplexity int) int
		AccountID    func(childComplexity int) int
		Connections  func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ConnectionOrder, where *ent.ConnectionWhereInput) int
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		IsPublic     func(childComplexity int) int
		IsVisible    func(childComplexity int) int
		Name         func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt    func(childComplexity int) int
	}

	PortfolioConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PortfolioEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		Accounts         func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AccountOrder, where *ent.AccountWhereInput) int
		Assetclasses     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AssetClassOrder, where *ent.AssetClassWhereInput) int
		Assets           func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AssetOrder, where *ent.AssetWhereInput) int
		Authroles        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthRoleOrder, where *ent.AuthRoleWhereInput) int
		Authtypes        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthTypeOrder, where *ent.AuthTypeWhereInput) int
		Blockchains      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.BlockchainOrder, where *ent.BlockchainWhereInput) int
		Connections      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ConnectionOrder, where *ent.ConnectionWhereInput) int
		Cryptocurrencies func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.CryptocurrencyOrder, where *ent.CryptocurrencyWhereInput) int
		Dailyassetprices func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.DailyAssetPriceOrder, where *ent.DailyAssetPriceWhereInput) int
		Exchanges        func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.ExchangeOrder, where *ent.ExchangeWhereInput) int
		Node             func(childComplexity int, id pulid.PULID) int
		Nodes            func(childComplexity int, ids []pulid.PULID) int
		Portfolios       func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.PortfolioOrder, where *ent.PortfolioWhereInput) int
		Sources          func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SourceOrder, where *ent.SourceWhereInput) int
		Sourcetypes      func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SourceTypeOrder, where *ent.SourceTypeWhereInput) int
		Staffaccounts    func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.StaffAccountOrder, where *ent.StaffAccountWhereInput) int
		Transactions     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		Transactiontypes func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionTypeOrder, where *ent.TransactionTypeWhereInput) int
	}

	Source struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Icon         func(childComplexity int) int
		Name         func(childComplexity int) int
		SourceType   func(childComplexity int) int
		SourceTypeID func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	SourceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SourceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	SourceType struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Sources     func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.SourceOrder, where *ent.SourceWhereInput) int
		UpdatedAt   func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	SourceTypeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SourceTypeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	StaffAccount struct {
		AuthRoles         func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.AuthRoleOrder, where *ent.AuthRoleWhereInput) int
		AuthType          func(childComplexity int) int
		AuthTypeID        func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Email             func(childComplexity int) int
		ID                func(childComplexity int) int
		Nickname          func(childComplexity int) int
		Password          func(childComplexity int) int
		PasswordUpdatedAt func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	StaffAccountConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	StaffAccountEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Transaction struct {
		BaseAsset         func(childComplexity int) int
		BaseAssetID       func(childComplexity int) int
		Blockchain        func(childComplexity int) int
		BlockchainID      func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		DeletedAt         func(childComplexity int) int
		Exchange          func(childComplexity int) int
		ExchangeID        func(childComplexity int) int
		ID                func(childComplexity int) int
		Portfolio         func(childComplexity int) int
		PortfolioID       func(childComplexity int) int
		PricePerUnit      func(childComplexity int) int
		QuoteAsset        func(childComplexity int) int
		QuoteAssetID      func(childComplexity int) int
		Time              func(childComplexity int) int
		TransactionType   func(childComplexity int) int
		TransactionTypeID func(childComplexity int) int
		Units             func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
	}

	TransactionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	TransactionType struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Transactions func(childComplexity int, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TransactionOrder, where *ent.TransactionWhereInput) int
		UpdatedAt    func(childComplexity int) int
		Value        func(childComplexity int) int
	}

	TransactionTypeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TransactionTypeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.authRoles":
		if e.complexity.Account.AuthRoles == nil {
			break
		}

		args, err := ec.field_Account_authRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.AuthRoles(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthRoleOrder), args["where"].(*ent.AuthRoleWhereInput)), true

	case "Account.authType":
		if e.complexity.Account.AuthType == nil {
			break
		}

		return e.complexity.Account.AuthType(childComplexity), true

	case "Account.authTypeID":
		if e.complexity.Account.AuthTypeID == nil {
			break
		}

		return e.complexity.Account.AuthTypeID(childComplexity), true

	case "Account.connections":
		if e.complexity.Account.Connections == nil {
			break
		}

		args, err := ec.field_Account_connections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.Connections(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ConnectionOrder), args["where"].(*ent.ConnectionWhereInput)), true

	case "Account.createdAt":
		if e.complexity.Account.CreatedAt == nil {
			break
		}

		return e.complexity.Account.CreatedAt(childComplexity), true

	case "Account.deletedAt":
		if e.complexity.Account.DeletedAt == nil {
			break
		}

		return e.complexity.Account.DeletedAt(childComplexity), true

	case "Account.email":
		if e.complexity.Account.Email == nil {
			break
		}

		return e.complexity.Account.Email(childComplexity), true

	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true

	case "Account.nickname":
		if e.complexity.Account.Nickname == nil {
			break
		}

		return e.complexity.Account.Nickname(childComplexity), true

	case "Account.password":
		if e.complexity.Account.Password == nil {
			break
		}

		return e.complexity.Account.Password(childComplexity), true

	case "Account.passwordUpdatedAt":
		if e.complexity.Account.PasswordUpdatedAt == nil {
			break
		}

		return e.complexity.Account.PasswordUpdatedAt(childComplexity), true

	case "Account.portfolios":
		if e.complexity.Account.Portfolios == nil {
			break
		}

		args, err := ec.field_Account_portfolios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Account.Portfolios(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PortfolioOrder), args["where"].(*ent.PortfolioWhereInput)), true

	case "Account.updatedAt":
		if e.complexity.Account.UpdatedAt == nil {
			break
		}

		return e.complexity.Account.UpdatedAt(childComplexity), true

	case "AccountConnection.edges":
		if e.complexity.AccountConnection.Edges == nil {
			break
		}

		return e.complexity.AccountConnection.Edges(childComplexity), true

	case "AccountConnection.pageInfo":
		if e.complexity.AccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.AccountConnection.PageInfo(childComplexity), true

	case "AccountConnection.totalCount":
		if e.complexity.AccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.AccountConnection.TotalCount(childComplexity), true

	case "AccountEdge.cursor":
		if e.complexity.AccountEdge.Cursor == nil {
			break
		}

		return e.complexity.AccountEdge.Cursor(childComplexity), true

	case "AccountEdge.node":
		if e.complexity.AccountEdge.Node == nil {
			break
		}

		return e.complexity.AccountEdge.Node(childComplexity), true

	case "Asset.assetClass":
		if e.complexity.Asset.AssetClass == nil {
			break
		}

		return e.complexity.Asset.AssetClass(childComplexity), true

	case "Asset.assetClassID":
		if e.complexity.Asset.AssetClassID == nil {
			break
		}

		return e.complexity.Asset.AssetClassID(childComplexity), true

	case "Asset.createdAt":
		if e.complexity.Asset.CreatedAt == nil {
			break
		}

		return e.complexity.Asset.CreatedAt(childComplexity), true

	case "Asset.cryptocurrency":
		if e.complexity.Asset.Cryptocurrency == nil {
			break
		}

		return e.complexity.Asset.Cryptocurrency(childComplexity), true

	case "Asset.dailyAssetPrices":
		if e.complexity.Asset.DailyAssetPrices == nil {
			break
		}

		args, err := ec.field_Asset_dailyAssetPrices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.DailyAssetPrices(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DailyAssetPriceOrder), args["where"].(*ent.DailyAssetPriceWhereInput)), true

	case "Asset.deletedAt":
		if e.complexity.Asset.DeletedAt == nil {
			break
		}

		return e.complexity.Asset.DeletedAt(childComplexity), true

	case "Asset.id":
		if e.complexity.Asset.ID == nil {
			break
		}

		return e.complexity.Asset.ID(childComplexity), true

	case "Asset.transactionBases":
		if e.complexity.Asset.TransactionBases == nil {
			break
		}

		args, err := ec.field_Asset_transactionBases_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.TransactionBases(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Asset.transactionQuotes":
		if e.complexity.Asset.TransactionQuotes == nil {
			break
		}

		args, err := ec.field_Asset_transactionQuotes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Asset.TransactionQuotes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Asset.updatedAt":
		if e.complexity.Asset.UpdatedAt == nil {
			break
		}

		return e.complexity.Asset.UpdatedAt(childComplexity), true

	case "AssetClass.assets":
		if e.complexity.AssetClass.Assets == nil {
			break
		}

		args, err := ec.field_AssetClass_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AssetClass.Assets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AssetOrder), args["where"].(*ent.AssetWhereInput)), true

	case "AssetClass.createdAt":
		if e.complexity.AssetClass.CreatedAt == nil {
			break
		}

		return e.complexity.AssetClass.CreatedAt(childComplexity), true

	case "AssetClass.deletedAt":
		if e.complexity.AssetClass.DeletedAt == nil {
			break
		}

		return e.complexity.AssetClass.DeletedAt(childComplexity), true

	case "AssetClass.description":
		if e.complexity.AssetClass.Description == nil {
			break
		}

		return e.complexity.AssetClass.Description(childComplexity), true

	case "AssetClass.id":
		if e.complexity.AssetClass.ID == nil {
			break
		}

		return e.complexity.AssetClass.ID(childComplexity), true

	case "AssetClass.updatedAt":
		if e.complexity.AssetClass.UpdatedAt == nil {
			break
		}

		return e.complexity.AssetClass.UpdatedAt(childComplexity), true

	case "AssetClass.value":
		if e.complexity.AssetClass.Value == nil {
			break
		}

		return e.complexity.AssetClass.Value(childComplexity), true

	case "AssetClassConnection.edges":
		if e.complexity.AssetClassConnection.Edges == nil {
			break
		}

		return e.complexity.AssetClassConnection.Edges(childComplexity), true

	case "AssetClassConnection.pageInfo":
		if e.complexity.AssetClassConnection.PageInfo == nil {
			break
		}

		return e.complexity.AssetClassConnection.PageInfo(childComplexity), true

	case "AssetClassConnection.totalCount":
		if e.complexity.AssetClassConnection.TotalCount == nil {
			break
		}

		return e.complexity.AssetClassConnection.TotalCount(childComplexity), true

	case "AssetClassEdge.cursor":
		if e.complexity.AssetClassEdge.Cursor == nil {
			break
		}

		return e.complexity.AssetClassEdge.Cursor(childComplexity), true

	case "AssetClassEdge.node":
		if e.complexity.AssetClassEdge.Node == nil {
			break
		}

		return e.complexity.AssetClassEdge.Node(childComplexity), true

	case "AssetConnection.edges":
		if e.complexity.AssetConnection.Edges == nil {
			break
		}

		return e.complexity.AssetConnection.Edges(childComplexity), true

	case "AssetConnection.pageInfo":
		if e.complexity.AssetConnection.PageInfo == nil {
			break
		}

		return e.complexity.AssetConnection.PageInfo(childComplexity), true

	case "AssetConnection.totalCount":
		if e.complexity.AssetConnection.TotalCount == nil {
			break
		}

		return e.complexity.AssetConnection.TotalCount(childComplexity), true

	case "AssetEdge.cursor":
		if e.complexity.AssetEdge.Cursor == nil {
			break
		}

		return e.complexity.AssetEdge.Cursor(childComplexity), true

	case "AssetEdge.node":
		if e.complexity.AssetEdge.Node == nil {
			break
		}

		return e.complexity.AssetEdge.Node(childComplexity), true

	case "AuthRole.accounts":
		if e.complexity.AuthRole.Accounts == nil {
			break
		}

		args, err := ec.field_AuthRole_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthRole.Accounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AccountOrder), args["where"].(*ent.AccountWhereInput)), true

	case "AuthRole.createdAt":
		if e.complexity.AuthRole.CreatedAt == nil {
			break
		}

		return e.complexity.AuthRole.CreatedAt(childComplexity), true

	case "AuthRole.deletedAt":
		if e.complexity.AuthRole.DeletedAt == nil {
			break
		}

		return e.complexity.AuthRole.DeletedAt(childComplexity), true

	case "AuthRole.description":
		if e.complexity.AuthRole.Description == nil {
			break
		}

		return e.complexity.AuthRole.Description(childComplexity), true

	case "AuthRole.id":
		if e.complexity.AuthRole.ID == nil {
			break
		}

		return e.complexity.AuthRole.ID(childComplexity), true

	case "AuthRole.staffAccounts":
		if e.complexity.AuthRole.StaffAccounts == nil {
			break
		}

		args, err := ec.field_AuthRole_staffAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthRole.StaffAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.StaffAccountOrder), args["where"].(*ent.StaffAccountWhereInput)), true

	case "AuthRole.updatedAt":
		if e.complexity.AuthRole.UpdatedAt == nil {
			break
		}

		return e.complexity.AuthRole.UpdatedAt(childComplexity), true

	case "AuthRole.value":
		if e.complexity.AuthRole.Value == nil {
			break
		}

		return e.complexity.AuthRole.Value(childComplexity), true

	case "AuthRoleConnection.edges":
		if e.complexity.AuthRoleConnection.Edges == nil {
			break
		}

		return e.complexity.AuthRoleConnection.Edges(childComplexity), true

	case "AuthRoleConnection.pageInfo":
		if e.complexity.AuthRoleConnection.PageInfo == nil {
			break
		}

		return e.complexity.AuthRoleConnection.PageInfo(childComplexity), true

	case "AuthRoleConnection.totalCount":
		if e.complexity.AuthRoleConnection.TotalCount == nil {
			break
		}

		return e.complexity.AuthRoleConnection.TotalCount(childComplexity), true

	case "AuthRoleEdge.cursor":
		if e.complexity.AuthRoleEdge.Cursor == nil {
			break
		}

		return e.complexity.AuthRoleEdge.Cursor(childComplexity), true

	case "AuthRoleEdge.node":
		if e.complexity.AuthRoleEdge.Node == nil {
			break
		}

		return e.complexity.AuthRoleEdge.Node(childComplexity), true

	case "AuthType.accounts":
		if e.complexity.AuthType.Accounts == nil {
			break
		}

		args, err := ec.field_AuthType_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthType.Accounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AccountOrder), args["where"].(*ent.AccountWhereInput)), true

	case "AuthType.createdAt":
		if e.complexity.AuthType.CreatedAt == nil {
			break
		}

		return e.complexity.AuthType.CreatedAt(childComplexity), true

	case "AuthType.deletedAt":
		if e.complexity.AuthType.DeletedAt == nil {
			break
		}

		return e.complexity.AuthType.DeletedAt(childComplexity), true

	case "AuthType.description":
		if e.complexity.AuthType.Description == nil {
			break
		}

		return e.complexity.AuthType.Description(childComplexity), true

	case "AuthType.id":
		if e.complexity.AuthType.ID == nil {
			break
		}

		return e.complexity.AuthType.ID(childComplexity), true

	case "AuthType.staffAccounts":
		if e.complexity.AuthType.StaffAccounts == nil {
			break
		}

		args, err := ec.field_AuthType_staffAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.AuthType.StaffAccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.StaffAccountOrder), args["where"].(*ent.StaffAccountWhereInput)), true

	case "AuthType.updatedAt":
		if e.complexity.AuthType.UpdatedAt == nil {
			break
		}

		return e.complexity.AuthType.UpdatedAt(childComplexity), true

	case "AuthType.value":
		if e.complexity.AuthType.Value == nil {
			break
		}

		return e.complexity.AuthType.Value(childComplexity), true

	case "AuthTypeConnection.edges":
		if e.complexity.AuthTypeConnection.Edges == nil {
			break
		}

		return e.complexity.AuthTypeConnection.Edges(childComplexity), true

	case "AuthTypeConnection.pageInfo":
		if e.complexity.AuthTypeConnection.PageInfo == nil {
			break
		}

		return e.complexity.AuthTypeConnection.PageInfo(childComplexity), true

	case "AuthTypeConnection.totalCount":
		if e.complexity.AuthTypeConnection.TotalCount == nil {
			break
		}

		return e.complexity.AuthTypeConnection.TotalCount(childComplexity), true

	case "AuthTypeEdge.cursor":
		if e.complexity.AuthTypeEdge.Cursor == nil {
			break
		}

		return e.complexity.AuthTypeEdge.Cursor(childComplexity), true

	case "AuthTypeEdge.node":
		if e.complexity.AuthTypeEdge.Node == nil {
			break
		}

		return e.complexity.AuthTypeEdge.Node(childComplexity), true

	case "Blockchain.chainID":
		if e.complexity.Blockchain.ChainID == nil {
			break
		}

		return e.complexity.Blockchain.ChainID(childComplexity), true

	case "Blockchain.createdAt":
		if e.complexity.Blockchain.CreatedAt == nil {
			break
		}

		return e.complexity.Blockchain.CreatedAt(childComplexity), true

	case "Blockchain.cryptocurrencies":
		if e.complexity.Blockchain.Cryptocurrencies == nil {
			break
		}

		args, err := ec.field_Blockchain_cryptocurrencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blockchain.Cryptocurrencies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.CryptocurrencyOrder), args["where"].(*ent.CryptocurrencyWhereInput)), true

	case "Blockchain.deletedAt":
		if e.complexity.Blockchain.DeletedAt == nil {
			break
		}

		return e.complexity.Blockchain.DeletedAt(childComplexity), true

	case "Blockchain.id":
		if e.complexity.Blockchain.ID == nil {
			break
		}

		return e.complexity.Blockchain.ID(childComplexity), true

	case "Blockchain.icon":
		if e.complexity.Blockchain.Icon == nil {
			break
		}

		return e.complexity.Blockchain.Icon(childComplexity), true

	case "Blockchain.name":
		if e.complexity.Blockchain.Name == nil {
			break
		}

		return e.complexity.Blockchain.Name(childComplexity), true

	case "Blockchain.symbol":
		if e.complexity.Blockchain.Symbol == nil {
			break
		}

		return e.complexity.Blockchain.Symbol(childComplexity), true

	case "Blockchain.transactions":
		if e.complexity.Blockchain.Transactions == nil {
			break
		}

		args, err := ec.field_Blockchain_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Blockchain.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Blockchain.updatedAt":
		if e.complexity.Blockchain.UpdatedAt == nil {
			break
		}

		return e.complexity.Blockchain.UpdatedAt(childComplexity), true

	case "BlockchainConnection.edges":
		if e.complexity.BlockchainConnection.Edges == nil {
			break
		}

		return e.complexity.BlockchainConnection.Edges(childComplexity), true

	case "BlockchainConnection.pageInfo":
		if e.complexity.BlockchainConnection.PageInfo == nil {
			break
		}

		return e.complexity.BlockchainConnection.PageInfo(childComplexity), true

	case "BlockchainConnection.totalCount":
		if e.complexity.BlockchainConnection.TotalCount == nil {
			break
		}

		return e.complexity.BlockchainConnection.TotalCount(childComplexity), true

	case "BlockchainEdge.cursor":
		if e.complexity.BlockchainEdge.Cursor == nil {
			break
		}

		return e.complexity.BlockchainEdge.Cursor(childComplexity), true

	case "BlockchainEdge.node":
		if e.complexity.BlockchainEdge.Node == nil {
			break
		}

		return e.complexity.BlockchainEdge.Node(childComplexity), true

	case "Connection.accessToken":
		if e.complexity.Connection.AccessToken == nil {
			break
		}

		return e.complexity.Connection.AccessToken(childComplexity), true

	case "Connection.account":
		if e.complexity.Connection.Account == nil {
			break
		}

		return e.complexity.Connection.Account(childComplexity), true

	case "Connection.accountID":
		if e.complexity.Connection.AccountID == nil {
			break
		}

		return e.complexity.Connection.AccountID(childComplexity), true

	case "Connection.createdAt":
		if e.complexity.Connection.CreatedAt == nil {
			break
		}

		return e.complexity.Connection.CreatedAt(childComplexity), true

	case "Connection.deletedAt":
		if e.complexity.Connection.DeletedAt == nil {
			break
		}

		return e.complexity.Connection.DeletedAt(childComplexity), true

	case "Connection.id":
		if e.complexity.Connection.ID == nil {
			break
		}

		return e.complexity.Connection.ID(childComplexity), true

	case "Connection.name":
		if e.complexity.Connection.Name == nil {
			break
		}

		return e.complexity.Connection.Name(childComplexity), true

	case "Connection.portfolios":
		if e.complexity.Connection.Portfolios == nil {
			break
		}

		args, err := ec.field_Connection_portfolios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Connection.Portfolios(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PortfolioOrder), args["where"].(*ent.PortfolioWhereInput)), true

	case "Connection.updatedAt":
		if e.complexity.Connection.UpdatedAt == nil {
			break
		}

		return e.complexity.Connection.UpdatedAt(childComplexity), true

	case "ConnectionConnection.edges":
		if e.complexity.ConnectionConnection.Edges == nil {
			break
		}

		return e.complexity.ConnectionConnection.Edges(childComplexity), true

	case "ConnectionConnection.pageInfo":
		if e.complexity.ConnectionConnection.PageInfo == nil {
			break
		}

		return e.complexity.ConnectionConnection.PageInfo(childComplexity), true

	case "ConnectionConnection.totalCount":
		if e.complexity.ConnectionConnection.TotalCount == nil {
			break
		}

		return e.complexity.ConnectionConnection.TotalCount(childComplexity), true

	case "ConnectionEdge.cursor":
		if e.complexity.ConnectionEdge.Cursor == nil {
			break
		}

		return e.complexity.ConnectionEdge.Cursor(childComplexity), true

	case "ConnectionEdge.node":
		if e.complexity.ConnectionEdge.Node == nil {
			break
		}

		return e.complexity.ConnectionEdge.Node(childComplexity), true

	case "Cryptocurrency.asset":
		if e.complexity.Cryptocurrency.Asset == nil {
			break
		}

		return e.complexity.Cryptocurrency.Asset(childComplexity), true

	case "Cryptocurrency.assetID":
		if e.complexity.Cryptocurrency.AssetID == nil {
			break
		}

		return e.complexity.Cryptocurrency.AssetID(childComplexity), true

	case "Cryptocurrency.blockchains":
		if e.complexity.Cryptocurrency.Blockchains == nil {
			break
		}

		args, err := ec.field_Cryptocurrency_blockchains_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Cryptocurrency.Blockchains(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.BlockchainOrder), args["where"].(*ent.BlockchainWhereInput)), true

	case "Cryptocurrency.createdAt":
		if e.complexity.Cryptocurrency.CreatedAt == nil {
			break
		}

		return e.complexity.Cryptocurrency.CreatedAt(childComplexity), true

	case "Cryptocurrency.deletedAt":
		if e.complexity.Cryptocurrency.DeletedAt == nil {
			break
		}

		return e.complexity.Cryptocurrency.DeletedAt(childComplexity), true

	case "Cryptocurrency.id":
		if e.complexity.Cryptocurrency.ID == nil {
			break
		}

		return e.complexity.Cryptocurrency.ID(childComplexity), true

	case "Cryptocurrency.icon":
		if e.complexity.Cryptocurrency.Icon == nil {
			break
		}

		return e.complexity.Cryptocurrency.Icon(childComplexity), true

	case "Cryptocurrency.name":
		if e.complexity.Cryptocurrency.Name == nil {
			break
		}

		return e.complexity.Cryptocurrency.Name(childComplexity), true

	case "Cryptocurrency.symbol":
		if e.complexity.Cryptocurrency.Symbol == nil {
			break
		}

		return e.complexity.Cryptocurrency.Symbol(childComplexity), true

	case "Cryptocurrency.updatedAt":
		if e.complexity.Cryptocurrency.UpdatedAt == nil {
			break
		}

		return e.complexity.Cryptocurrency.UpdatedAt(childComplexity), true

	case "CryptocurrencyConnection.edges":
		if e.complexity.CryptocurrencyConnection.Edges == nil {
			break
		}

		return e.complexity.CryptocurrencyConnection.Edges(childComplexity), true

	case "CryptocurrencyConnection.pageInfo":
		if e.complexity.CryptocurrencyConnection.PageInfo == nil {
			break
		}

		return e.complexity.CryptocurrencyConnection.PageInfo(childComplexity), true

	case "CryptocurrencyConnection.totalCount":
		if e.complexity.CryptocurrencyConnection.TotalCount == nil {
			break
		}

		return e.complexity.CryptocurrencyConnection.TotalCount(childComplexity), true

	case "CryptocurrencyEdge.cursor":
		if e.complexity.CryptocurrencyEdge.Cursor == nil {
			break
		}

		return e.complexity.CryptocurrencyEdge.Cursor(childComplexity), true

	case "CryptocurrencyEdge.node":
		if e.complexity.CryptocurrencyEdge.Node == nil {
			break
		}

		return e.complexity.CryptocurrencyEdge.Node(childComplexity), true

	case "DailyAssetPrice.adjustedClose":
		if e.complexity.DailyAssetPrice.AdjustedClose == nil {
			break
		}

		return e.complexity.DailyAssetPrice.AdjustedClose(childComplexity), true

	case "DailyAssetPrice.asset":
		if e.complexity.DailyAssetPrice.Asset == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Asset(childComplexity), true

	case "DailyAssetPrice.assetID":
		if e.complexity.DailyAssetPrice.AssetID == nil {
			break
		}

		return e.complexity.DailyAssetPrice.AssetID(childComplexity), true

	case "DailyAssetPrice.close":
		if e.complexity.DailyAssetPrice.Close == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Close(childComplexity), true

	case "DailyAssetPrice.createdAt":
		if e.complexity.DailyAssetPrice.CreatedAt == nil {
			break
		}

		return e.complexity.DailyAssetPrice.CreatedAt(childComplexity), true

	case "DailyAssetPrice.deletedAt":
		if e.complexity.DailyAssetPrice.DeletedAt == nil {
			break
		}

		return e.complexity.DailyAssetPrice.DeletedAt(childComplexity), true

	case "DailyAssetPrice.high":
		if e.complexity.DailyAssetPrice.High == nil {
			break
		}

		return e.complexity.DailyAssetPrice.High(childComplexity), true

	case "DailyAssetPrice.id":
		if e.complexity.DailyAssetPrice.ID == nil {
			break
		}

		return e.complexity.DailyAssetPrice.ID(childComplexity), true

	case "DailyAssetPrice.low":
		if e.complexity.DailyAssetPrice.Low == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Low(childComplexity), true

	case "DailyAssetPrice.open":
		if e.complexity.DailyAssetPrice.Open == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Open(childComplexity), true

	case "DailyAssetPrice.time":
		if e.complexity.DailyAssetPrice.Time == nil {
			break
		}

		return e.complexity.DailyAssetPrice.Time(childComplexity), true

	case "DailyAssetPrice.updatedAt":
		if e.complexity.DailyAssetPrice.UpdatedAt == nil {
			break
		}

		return e.complexity.DailyAssetPrice.UpdatedAt(childComplexity), true

	case "DailyAssetPriceConnection.edges":
		if e.complexity.DailyAssetPriceConnection.Edges == nil {
			break
		}

		return e.complexity.DailyAssetPriceConnection.Edges(childComplexity), true

	case "DailyAssetPriceConnection.pageInfo":
		if e.complexity.DailyAssetPriceConnection.PageInfo == nil {
			break
		}

		return e.complexity.DailyAssetPriceConnection.PageInfo(childComplexity), true

	case "DailyAssetPriceConnection.totalCount":
		if e.complexity.DailyAssetPriceConnection.TotalCount == nil {
			break
		}

		return e.complexity.DailyAssetPriceConnection.TotalCount(childComplexity), true

	case "DailyAssetPriceEdge.cursor":
		if e.complexity.DailyAssetPriceEdge.Cursor == nil {
			break
		}

		return e.complexity.DailyAssetPriceEdge.Cursor(childComplexity), true

	case "DailyAssetPriceEdge.node":
		if e.complexity.DailyAssetPriceEdge.Node == nil {
			break
		}

		return e.complexity.DailyAssetPriceEdge.Node(childComplexity), true

	case "Exchange.createdAt":
		if e.complexity.Exchange.CreatedAt == nil {
			break
		}

		return e.complexity.Exchange.CreatedAt(childComplexity), true

	case "Exchange.deletedAt":
		if e.complexity.Exchange.DeletedAt == nil {
			break
		}

		return e.complexity.Exchange.DeletedAt(childComplexity), true

	case "Exchange.id":
		if e.complexity.Exchange.ID == nil {
			break
		}

		return e.complexity.Exchange.ID(childComplexity), true

	case "Exchange.icon":
		if e.complexity.Exchange.Icon == nil {
			break
		}

		return e.complexity.Exchange.Icon(childComplexity), true

	case "Exchange.name":
		if e.complexity.Exchange.Name == nil {
			break
		}

		return e.complexity.Exchange.Name(childComplexity), true

	case "Exchange.transactions":
		if e.complexity.Exchange.Transactions == nil {
			break
		}

		args, err := ec.field_Exchange_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Exchange.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Exchange.url":
		if e.complexity.Exchange.URL == nil {
			break
		}

		return e.complexity.Exchange.URL(childComplexity), true

	case "Exchange.updatedAt":
		if e.complexity.Exchange.UpdatedAt == nil {
			break
		}

		return e.complexity.Exchange.UpdatedAt(childComplexity), true

	case "ExchangeConnection.edges":
		if e.complexity.ExchangeConnection.Edges == nil {
			break
		}

		return e.complexity.ExchangeConnection.Edges(childComplexity), true

	case "ExchangeConnection.pageInfo":
		if e.complexity.ExchangeConnection.PageInfo == nil {
			break
		}

		return e.complexity.ExchangeConnection.PageInfo(childComplexity), true

	case "ExchangeConnection.totalCount":
		if e.complexity.ExchangeConnection.TotalCount == nil {
			break
		}

		return e.complexity.ExchangeConnection.TotalCount(childComplexity), true

	case "ExchangeEdge.cursor":
		if e.complexity.ExchangeEdge.Cursor == nil {
			break
		}

		return e.complexity.ExchangeEdge.Cursor(childComplexity), true

	case "ExchangeEdge.node":
		if e.complexity.ExchangeEdge.Node == nil {
			break
		}

		return e.complexity.ExchangeEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Portfolio.account":
		if e.complexity.Portfolio.Account == nil {
			break
		}

		return e.complexity.Portfolio.Account(childComplexity), true

	case "Portfolio.accountID":
		if e.complexity.Portfolio.AccountID == nil {
			break
		}

		return e.complexity.Portfolio.AccountID(childComplexity), true

	case "Portfolio.connections":
		if e.complexity.Portfolio.Connections == nil {
			break
		}

		args, err := ec.field_Portfolio_connections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Portfolio.Connections(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ConnectionOrder), args["where"].(*ent.ConnectionWhereInput)), true

	case "Portfolio.createdAt":
		if e.complexity.Portfolio.CreatedAt == nil {
			break
		}

		return e.complexity.Portfolio.CreatedAt(childComplexity), true

	case "Portfolio.deletedAt":
		if e.complexity.Portfolio.DeletedAt == nil {
			break
		}

		return e.complexity.Portfolio.DeletedAt(childComplexity), true

	case "Portfolio.id":
		if e.complexity.Portfolio.ID == nil {
			break
		}

		return e.complexity.Portfolio.ID(childComplexity), true

	case "Portfolio.isPublic":
		if e.complexity.Portfolio.IsPublic == nil {
			break
		}

		return e.complexity.Portfolio.IsPublic(childComplexity), true

	case "Portfolio.isVisible":
		if e.complexity.Portfolio.IsVisible == nil {
			break
		}

		return e.complexity.Portfolio.IsVisible(childComplexity), true

	case "Portfolio.name":
		if e.complexity.Portfolio.Name == nil {
			break
		}

		return e.complexity.Portfolio.Name(childComplexity), true

	case "Portfolio.transactions":
		if e.complexity.Portfolio.Transactions == nil {
			break
		}

		args, err := ec.field_Portfolio_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Portfolio.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Portfolio.updatedAt":
		if e.complexity.Portfolio.UpdatedAt == nil {
			break
		}

		return e.complexity.Portfolio.UpdatedAt(childComplexity), true

	case "PortfolioConnection.edges":
		if e.complexity.PortfolioConnection.Edges == nil {
			break
		}

		return e.complexity.PortfolioConnection.Edges(childComplexity), true

	case "PortfolioConnection.pageInfo":
		if e.complexity.PortfolioConnection.PageInfo == nil {
			break
		}

		return e.complexity.PortfolioConnection.PageInfo(childComplexity), true

	case "PortfolioConnection.totalCount":
		if e.complexity.PortfolioConnection.TotalCount == nil {
			break
		}

		return e.complexity.PortfolioConnection.TotalCount(childComplexity), true

	case "PortfolioEdge.cursor":
		if e.complexity.PortfolioEdge.Cursor == nil {
			break
		}

		return e.complexity.PortfolioEdge.Cursor(childComplexity), true

	case "PortfolioEdge.node":
		if e.complexity.PortfolioEdge.Node == nil {
			break
		}

		return e.complexity.PortfolioEdge.Node(childComplexity), true

	case "Query.accounts":
		if e.complexity.Query.Accounts == nil {
			break
		}

		args, err := ec.field_Query_accounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Accounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AccountOrder), args["where"].(*ent.AccountWhereInput)), true

	case "Query.assetclasses":
		if e.complexity.Query.Assetclasses == nil {
			break
		}

		args, err := ec.field_Query_assetclasses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assetclasses(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AssetClassOrder), args["where"].(*ent.AssetClassWhereInput)), true

	case "Query.assets":
		if e.complexity.Query.Assets == nil {
			break
		}

		args, err := ec.field_Query_assets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Assets(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AssetOrder), args["where"].(*ent.AssetWhereInput)), true

	case "Query.authroles":
		if e.complexity.Query.Authroles == nil {
			break
		}

		args, err := ec.field_Query_authroles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Authroles(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthRoleOrder), args["where"].(*ent.AuthRoleWhereInput)), true

	case "Query.authtypes":
		if e.complexity.Query.Authtypes == nil {
			break
		}

		args, err := ec.field_Query_authtypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Authtypes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthTypeOrder), args["where"].(*ent.AuthTypeWhereInput)), true

	case "Query.blockchains":
		if e.complexity.Query.Blockchains == nil {
			break
		}

		args, err := ec.field_Query_blockchains_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blockchains(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.BlockchainOrder), args["where"].(*ent.BlockchainWhereInput)), true

	case "Query.connections":
		if e.complexity.Query.Connections == nil {
			break
		}

		args, err := ec.field_Query_connections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Connections(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ConnectionOrder), args["where"].(*ent.ConnectionWhereInput)), true

	case "Query.cryptocurrencies":
		if e.complexity.Query.Cryptocurrencies == nil {
			break
		}

		args, err := ec.field_Query_cryptocurrencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cryptocurrencies(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.CryptocurrencyOrder), args["where"].(*ent.CryptocurrencyWhereInput)), true

	case "Query.dailyassetprices":
		if e.complexity.Query.Dailyassetprices == nil {
			break
		}

		args, err := ec.field_Query_dailyassetprices_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Dailyassetprices(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.DailyAssetPriceOrder), args["where"].(*ent.DailyAssetPriceWhereInput)), true

	case "Query.exchanges":
		if e.complexity.Query.Exchanges == nil {
			break
		}

		args, err := ec.field_Query_exchanges_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Exchanges(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.ExchangeOrder), args["where"].(*ent.ExchangeWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(pulid.PULID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]pulid.PULID)), true

	case "Query.portfolios":
		if e.complexity.Query.Portfolios == nil {
			break
		}

		args, err := ec.field_Query_portfolios_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Portfolios(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.PortfolioOrder), args["where"].(*ent.PortfolioWhereInput)), true

	case "Query.sources":
		if e.complexity.Query.Sources == nil {
			break
		}

		args, err := ec.field_Query_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sources(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SourceOrder), args["where"].(*ent.SourceWhereInput)), true

	case "Query.sourcetypes":
		if e.complexity.Query.Sourcetypes == nil {
			break
		}

		args, err := ec.field_Query_sourcetypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Sourcetypes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SourceTypeOrder), args["where"].(*ent.SourceTypeWhereInput)), true

	case "Query.staffaccounts":
		if e.complexity.Query.Staffaccounts == nil {
			break
		}

		args, err := ec.field_Query_staffaccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Staffaccounts(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.StaffAccountOrder), args["where"].(*ent.StaffAccountWhereInput)), true

	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "Query.transactiontypes":
		if e.complexity.Query.Transactiontypes == nil {
			break
		}

		args, err := ec.field_Query_transactiontypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactiontypes(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionTypeOrder), args["where"].(*ent.TransactionTypeWhereInput)), true

	case "Source.createdAt":
		if e.complexity.Source.CreatedAt == nil {
			break
		}

		return e.complexity.Source.CreatedAt(childComplexity), true

	case "Source.deletedAt":
		if e.complexity.Source.DeletedAt == nil {
			break
		}

		return e.complexity.Source.DeletedAt(childComplexity), true

	case "Source.id":
		if e.complexity.Source.ID == nil {
			break
		}

		return e.complexity.Source.ID(childComplexity), true

	case "Source.icon":
		if e.complexity.Source.Icon == nil {
			break
		}

		return e.complexity.Source.Icon(childComplexity), true

	case "Source.name":
		if e.complexity.Source.Name == nil {
			break
		}

		return e.complexity.Source.Name(childComplexity), true

	case "Source.sourceType":
		if e.complexity.Source.SourceType == nil {
			break
		}

		return e.complexity.Source.SourceType(childComplexity), true

	case "Source.sourceTypeID":
		if e.complexity.Source.SourceTypeID == nil {
			break
		}

		return e.complexity.Source.SourceTypeID(childComplexity), true

	case "Source.updatedAt":
		if e.complexity.Source.UpdatedAt == nil {
			break
		}

		return e.complexity.Source.UpdatedAt(childComplexity), true

	case "SourceConnection.edges":
		if e.complexity.SourceConnection.Edges == nil {
			break
		}

		return e.complexity.SourceConnection.Edges(childComplexity), true

	case "SourceConnection.pageInfo":
		if e.complexity.SourceConnection.PageInfo == nil {
			break
		}

		return e.complexity.SourceConnection.PageInfo(childComplexity), true

	case "SourceConnection.totalCount":
		if e.complexity.SourceConnection.TotalCount == nil {
			break
		}

		return e.complexity.SourceConnection.TotalCount(childComplexity), true

	case "SourceEdge.cursor":
		if e.complexity.SourceEdge.Cursor == nil {
			break
		}

		return e.complexity.SourceEdge.Cursor(childComplexity), true

	case "SourceEdge.node":
		if e.complexity.SourceEdge.Node == nil {
			break
		}

		return e.complexity.SourceEdge.Node(childComplexity), true

	case "SourceType.createdAt":
		if e.complexity.SourceType.CreatedAt == nil {
			break
		}

		return e.complexity.SourceType.CreatedAt(childComplexity), true

	case "SourceType.deletedAt":
		if e.complexity.SourceType.DeletedAt == nil {
			break
		}

		return e.complexity.SourceType.DeletedAt(childComplexity), true

	case "SourceType.description":
		if e.complexity.SourceType.Description == nil {
			break
		}

		return e.complexity.SourceType.Description(childComplexity), true

	case "SourceType.id":
		if e.complexity.SourceType.ID == nil {
			break
		}

		return e.complexity.SourceType.ID(childComplexity), true

	case "SourceType.sources":
		if e.complexity.SourceType.Sources == nil {
			break
		}

		args, err := ec.field_SourceType_sources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.SourceType.Sources(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.SourceOrder), args["where"].(*ent.SourceWhereInput)), true

	case "SourceType.updatedAt":
		if e.complexity.SourceType.UpdatedAt == nil {
			break
		}

		return e.complexity.SourceType.UpdatedAt(childComplexity), true

	case "SourceType.value":
		if e.complexity.SourceType.Value == nil {
			break
		}

		return e.complexity.SourceType.Value(childComplexity), true

	case "SourceTypeConnection.edges":
		if e.complexity.SourceTypeConnection.Edges == nil {
			break
		}

		return e.complexity.SourceTypeConnection.Edges(childComplexity), true

	case "SourceTypeConnection.pageInfo":
		if e.complexity.SourceTypeConnection.PageInfo == nil {
			break
		}

		return e.complexity.SourceTypeConnection.PageInfo(childComplexity), true

	case "SourceTypeConnection.totalCount":
		if e.complexity.SourceTypeConnection.TotalCount == nil {
			break
		}

		return e.complexity.SourceTypeConnection.TotalCount(childComplexity), true

	case "SourceTypeEdge.cursor":
		if e.complexity.SourceTypeEdge.Cursor == nil {
			break
		}

		return e.complexity.SourceTypeEdge.Cursor(childComplexity), true

	case "SourceTypeEdge.node":
		if e.complexity.SourceTypeEdge.Node == nil {
			break
		}

		return e.complexity.SourceTypeEdge.Node(childComplexity), true

	case "StaffAccount.authRoles":
		if e.complexity.StaffAccount.AuthRoles == nil {
			break
		}

		args, err := ec.field_StaffAccount_authRoles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.StaffAccount.AuthRoles(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.AuthRoleOrder), args["where"].(*ent.AuthRoleWhereInput)), true

	case "StaffAccount.authType":
		if e.complexity.StaffAccount.AuthType == nil {
			break
		}

		return e.complexity.StaffAccount.AuthType(childComplexity), true

	case "StaffAccount.authTypeID":
		if e.complexity.StaffAccount.AuthTypeID == nil {
			break
		}

		return e.complexity.StaffAccount.AuthTypeID(childComplexity), true

	case "StaffAccount.createdAt":
		if e.complexity.StaffAccount.CreatedAt == nil {
			break
		}

		return e.complexity.StaffAccount.CreatedAt(childComplexity), true

	case "StaffAccount.deletedAt":
		if e.complexity.StaffAccount.DeletedAt == nil {
			break
		}

		return e.complexity.StaffAccount.DeletedAt(childComplexity), true

	case "StaffAccount.email":
		if e.complexity.StaffAccount.Email == nil {
			break
		}

		return e.complexity.StaffAccount.Email(childComplexity), true

	case "StaffAccount.id":
		if e.complexity.StaffAccount.ID == nil {
			break
		}

		return e.complexity.StaffAccount.ID(childComplexity), true

	case "StaffAccount.nickname":
		if e.complexity.StaffAccount.Nickname == nil {
			break
		}

		return e.complexity.StaffAccount.Nickname(childComplexity), true

	case "StaffAccount.password":
		if e.complexity.StaffAccount.Password == nil {
			break
		}

		return e.complexity.StaffAccount.Password(childComplexity), true

	case "StaffAccount.passwordUpdatedAt":
		if e.complexity.StaffAccount.PasswordUpdatedAt == nil {
			break
		}

		return e.complexity.StaffAccount.PasswordUpdatedAt(childComplexity), true

	case "StaffAccount.updatedAt":
		if e.complexity.StaffAccount.UpdatedAt == nil {
			break
		}

		return e.complexity.StaffAccount.UpdatedAt(childComplexity), true

	case "StaffAccountConnection.edges":
		if e.complexity.StaffAccountConnection.Edges == nil {
			break
		}

		return e.complexity.StaffAccountConnection.Edges(childComplexity), true

	case "StaffAccountConnection.pageInfo":
		if e.complexity.StaffAccountConnection.PageInfo == nil {
			break
		}

		return e.complexity.StaffAccountConnection.PageInfo(childComplexity), true

	case "StaffAccountConnection.totalCount":
		if e.complexity.StaffAccountConnection.TotalCount == nil {
			break
		}

		return e.complexity.StaffAccountConnection.TotalCount(childComplexity), true

	case "StaffAccountEdge.cursor":
		if e.complexity.StaffAccountEdge.Cursor == nil {
			break
		}

		return e.complexity.StaffAccountEdge.Cursor(childComplexity), true

	case "StaffAccountEdge.node":
		if e.complexity.StaffAccountEdge.Node == nil {
			break
		}

		return e.complexity.StaffAccountEdge.Node(childComplexity), true

	case "Transaction.baseAsset":
		if e.complexity.Transaction.BaseAsset == nil {
			break
		}

		return e.complexity.Transaction.BaseAsset(childComplexity), true

	case "Transaction.baseAssetID":
		if e.complexity.Transaction.BaseAssetID == nil {
			break
		}

		return e.complexity.Transaction.BaseAssetID(childComplexity), true

	case "Transaction.blockchain":
		if e.complexity.Transaction.Blockchain == nil {
			break
		}

		return e.complexity.Transaction.Blockchain(childComplexity), true

	case "Transaction.blockchainID":
		if e.complexity.Transaction.BlockchainID == nil {
			break
		}

		return e.complexity.Transaction.BlockchainID(childComplexity), true

	case "Transaction.createdAt":
		if e.complexity.Transaction.CreatedAt == nil {
			break
		}

		return e.complexity.Transaction.CreatedAt(childComplexity), true

	case "Transaction.deletedAt":
		if e.complexity.Transaction.DeletedAt == nil {
			break
		}

		return e.complexity.Transaction.DeletedAt(childComplexity), true

	case "Transaction.exchange":
		if e.complexity.Transaction.Exchange == nil {
			break
		}

		return e.complexity.Transaction.Exchange(childComplexity), true

	case "Transaction.exchangeID":
		if e.complexity.Transaction.ExchangeID == nil {
			break
		}

		return e.complexity.Transaction.ExchangeID(childComplexity), true

	case "Transaction.id":
		if e.complexity.Transaction.ID == nil {
			break
		}

		return e.complexity.Transaction.ID(childComplexity), true

	case "Transaction.portfolio":
		if e.complexity.Transaction.Portfolio == nil {
			break
		}

		return e.complexity.Transaction.Portfolio(childComplexity), true

	case "Transaction.portfolioID":
		if e.complexity.Transaction.PortfolioID == nil {
			break
		}

		return e.complexity.Transaction.PortfolioID(childComplexity), true

	case "Transaction.pricePerUnit":
		if e.complexity.Transaction.PricePerUnit == nil {
			break
		}

		return e.complexity.Transaction.PricePerUnit(childComplexity), true

	case "Transaction.quoteAsset":
		if e.complexity.Transaction.QuoteAsset == nil {
			break
		}

		return e.complexity.Transaction.QuoteAsset(childComplexity), true

	case "Transaction.quoteAssetID":
		if e.complexity.Transaction.QuoteAssetID == nil {
			break
		}

		return e.complexity.Transaction.QuoteAssetID(childComplexity), true

	case "Transaction.time":
		if e.complexity.Transaction.Time == nil {
			break
		}

		return e.complexity.Transaction.Time(childComplexity), true

	case "Transaction.transactionType":
		if e.complexity.Transaction.TransactionType == nil {
			break
		}

		return e.complexity.Transaction.TransactionType(childComplexity), true

	case "Transaction.transactionTypeID":
		if e.complexity.Transaction.TransactionTypeID == nil {
			break
		}

		return e.complexity.Transaction.TransactionTypeID(childComplexity), true

	case "Transaction.units":
		if e.complexity.Transaction.Units == nil {
			break
		}

		return e.complexity.Transaction.Units(childComplexity), true

	case "Transaction.updatedAt":
		if e.complexity.Transaction.UpdatedAt == nil {
			break
		}

		return e.complexity.Transaction.UpdatedAt(childComplexity), true

	case "TransactionConnection.edges":
		if e.complexity.TransactionConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionConnection.Edges(childComplexity), true

	case "TransactionConnection.pageInfo":
		if e.complexity.TransactionConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionConnection.PageInfo(childComplexity), true

	case "TransactionConnection.totalCount":
		if e.complexity.TransactionConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionConnection.TotalCount(childComplexity), true

	case "TransactionEdge.cursor":
		if e.complexity.TransactionEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionEdge.Cursor(childComplexity), true

	case "TransactionEdge.node":
		if e.complexity.TransactionEdge.Node == nil {
			break
		}

		return e.complexity.TransactionEdge.Node(childComplexity), true

	case "TransactionType.createdAt":
		if e.complexity.TransactionType.CreatedAt == nil {
			break
		}

		return e.complexity.TransactionType.CreatedAt(childComplexity), true

	case "TransactionType.deletedAt":
		if e.complexity.TransactionType.DeletedAt == nil {
			break
		}

		return e.complexity.TransactionType.DeletedAt(childComplexity), true

	case "TransactionType.description":
		if e.complexity.TransactionType.Description == nil {
			break
		}

		return e.complexity.TransactionType.Description(childComplexity), true

	case "TransactionType.id":
		if e.complexity.TransactionType.ID == nil {
			break
		}

		return e.complexity.TransactionType.ID(childComplexity), true

	case "TransactionType.transactions":
		if e.complexity.TransactionType.Transactions == nil {
			break
		}

		args, err := ec.field_TransactionType_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.TransactionType.Transactions(childComplexity, args["after"].(*ent.Cursor), args["first"].(*int), args["before"].(*ent.Cursor), args["last"].(*int), args["orderBy"].(*ent.TransactionOrder), args["where"].(*ent.TransactionWhereInput)), true

	case "TransactionType.updatedAt":
		if e.complexity.TransactionType.UpdatedAt == nil {
			break
		}

		return e.complexity.TransactionType.UpdatedAt(childComplexity), true

	case "TransactionType.value":
		if e.complexity.TransactionType.Value == nil {
			break
		}

		return e.complexity.TransactionType.Value(childComplexity), true

	case "TransactionTypeConnection.edges":
		if e.complexity.TransactionTypeConnection.Edges == nil {
			break
		}

		return e.complexity.TransactionTypeConnection.Edges(childComplexity), true

	case "TransactionTypeConnection.pageInfo":
		if e.complexity.TransactionTypeConnection.PageInfo == nil {
			break
		}

		return e.complexity.TransactionTypeConnection.PageInfo(childComplexity), true

	case "TransactionTypeConnection.totalCount":
		if e.complexity.TransactionTypeConnection.TotalCount == nil {
			break
		}

		return e.complexity.TransactionTypeConnection.TotalCount(childComplexity), true

	case "TransactionTypeEdge.cursor":
		if e.complexity.TransactionTypeEdge.Cursor == nil {
			break
		}

		return e.complexity.TransactionTypeEdge.Cursor(childComplexity), true

	case "TransactionTypeEdge.node":
		if e.complexity.TransactionTypeEdge.Node == nil {
			break
		}

		return e.complexity.TransactionTypeEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAccountOrder,
		ec.unmarshalInputAccountWhereInput,
		ec.unmarshalInputAssetClassOrder,
		ec.unmarshalInputAssetClassWhereInput,
		ec.unmarshalInputAssetOrder,
		ec.unmarshalInputAssetWhereInput,
		ec.unmarshalInputAuthRoleOrder,
		ec.unmarshalInputAuthRoleWhereInput,
		ec.unmarshalInputAuthTypeOrder,
		ec.unmarshalInputAuthTypeWhereInput,
		ec.unmarshalInputBlockchainOrder,
		ec.unmarshalInputBlockchainWhereInput,
		ec.unmarshalInputConnectionOrder,
		ec.unmarshalInputConnectionWhereInput,
		ec.unmarshalInputCreateAccountInput,
		ec.unmarshalInputCreateAssetClassInput,
		ec.unmarshalInputCreateAssetInput,
		ec.unmarshalInputCreateAuthRoleInput,
		ec.unmarshalInputCreateAuthTypeInput,
		ec.unmarshalInputCreateBlockchainInput,
		ec.unmarshalInputCreateConnectionInput,
		ec.unmarshalInputCreateCryptocurrencyInput,
		ec.unmarshalInputCreateDailyAssetPriceInput,
		ec.unmarshalInputCreateExchangeInput,
		ec.unmarshalInputCreatePortfolioInput,
		ec.unmarshalInputCreateSourceInput,
		ec.unmarshalInputCreateSourceTypeInput,
		ec.unmarshalInputCreateStaffAccountInput,
		ec.unmarshalInputCreateTransactionInput,
		ec.unmarshalInputCreateTransactionTypeInput,
		ec.unmarshalInputCryptocurrencyOrder,
		ec.unmarshalInputCryptocurrencyWhereInput,
		ec.unmarshalInputDailyAssetPriceOrder,
		ec.unmarshalInputDailyAssetPriceWhereInput,
		ec.unmarshalInputExchangeOrder,
		ec.unmarshalInputExchangeWhereInput,
		ec.unmarshalInputPortfolioOrder,
		ec.unmarshalInputPortfolioWhereInput,
		ec.unmarshalInputSourceOrder,
		ec.unmarshalInputSourceTypeOrder,
		ec.unmarshalInputSourceTypeWhereInput,
		ec.unmarshalInputSourceWhereInput,
		ec.unmarshalInputStaffAccountOrder,
		ec.unmarshalInputStaffAccountWhereInput,
		ec.unmarshalInputTransactionOrder,
		ec.unmarshalInputTransactionTypeOrder,
		ec.unmarshalInputTransactionTypeWhereInput,
		ec.unmarshalInputTransactionWhereInput,
		ec.unmarshalInputUpdateAccountInput,
		ec.unmarshalInputUpdateAssetClassInput,
		ec.unmarshalInputUpdateAssetInput,
		ec.unmarshalInputUpdateAuthRoleInput,
		ec.unmarshalInputUpdateAuthTypeInput,
		ec.unmarshalInputUpdateBlockchainInput,
		ec.unmarshalInputUpdateConnectionInput,
		ec.unmarshalInputUpdateCryptocurrencyInput,
		ec.unmarshalInputUpdateDailyAssetPriceInput,
		ec.unmarshalInputUpdateExchangeInput,
		ec.unmarshalInputUpdatePortfolioInput,
		ec.unmarshalInputUpdateSourceInput,
		ec.unmarshalInputUpdateSourceTypeInput,
		ec.unmarshalInputUpdateStaffAccountInput,
		ec.unmarshalInputUpdateTransactionInput,
		ec.unmarshalInputUpdateTransactionTypeInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

//go:embed "schema/schema.graphql" "schema/ent.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/schema.graphql", Input: sourceData("schema/schema.graphql"), BuiltIn: false},
	{Name: "schema/ent.graphql", Input: sourceData("schema/ent.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
